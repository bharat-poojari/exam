<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>R Notes</title>
    <style>
        /* ============================================================================
   ELEGANT CSS FOR ACADEMIC MARKDOWN CONVERTER
   Clean book/PDF style with white background and black text
   ============================================================================ */

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

html {
    font-size: 16px;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    scroll-behavior: smooth;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', sans-serif;
    line-height: 1.6;
    color: #000000;
    background: #ffffff;
    min-height: 100vh;
    overflow-x: hidden;
}

/* ============================================================================
   CONTAINER
   ============================================================================ */

.container {
    max-width: 8.5in;
    margin: 0 auto;
    padding: 40px;
    background: #ffffff;
}

/* ============================================================================
   HEADER STYLES
   ============================================================================ */

.document-header {
    text-align: center;
    margin-bottom: 40px;
    padding-bottom: 25px;
    border-bottom: 2px solid #000000;
}

.document-title {
    font-size: 32px;
    font-weight: 800;
    line-height: 1.2;
    margin-bottom: 20px;
    color: #000000;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.document-meta {
    display: flex;
    justify-content: center;
    gap: 25px;
    margin-top: 15px;
    flex-wrap: wrap;
}

.document-meta .meta-item {
    font-size: 14px;
    color: #333333;
    font-weight: 500;
    padding: 5px 12px;
    background: #f8f8f8;
    border-radius: 4px;
    border: 1px solid #e0e0e0;
}

.document-meta .meta-item strong {
    color: #000000;
    font-weight: 600;
    margin-right: 4px;
}

/* ============================================================================
   TABLE OF CONTENTS
   ============================================================================ */

.table-of-contents {
    margin-bottom: 40px;
    padding: 20px;
    background: #f9f9f9;
    border-left: 4px solid #000000;
    border-radius: 0 4px 4px 0;
}

.toc-title {
    font-size: 18px;
    font-weight: 700;
    color: #000000;
    margin-bottom: 15px;
    padding-bottom: 8px;
    border-bottom: 1px solid #cccccc;
}

.toc-list {
    list-style: none;
    padding-left: 0;
}

.toc-list li {
    margin-bottom: 8px;
    padding-left: 0;
    position: relative;
}

.toc-list li.toc-indent {
    padding-left: 20px;
}

.toc-list a {
    color: #333333;
    text-decoration: none;
    font-size: 15px;
    transition: color 0.2s ease;
    display: block;
    padding: 4px 0;
}

.toc-list a:hover {
    color: #000000;
    text-decoration: underline;
}

/* ============================================================================
   CONTENT AREA
   ============================================================================ */

.content {
    padding: 20px 0;
}

/* ============================================================================
   SECTION STYLES
   ============================================================================ */

.content-section {
    margin-bottom: 40px;
    page-break-inside: avoid;
}

.section-heading {
    font-weight: 700;
    color: #000000;
    margin-bottom: 20px;
    padding-bottom: 10px;
    border-bottom: 1px solid #e0e0e0;
}

h1.section-heading {
    font-size: 26px;
    border-bottom: 2px solid #000000;
}

h2.section-heading {
    font-size: 22px;
}

h3.section-heading {
    font-size: 18px;
}

h4.section-heading {
    font-size: 16px;
}

h5.section-heading, h6.section-heading {
    font-size: 15px;
}

/* ============================================================================
   PARAGRAPH STYLES
   ============================================================================ */

.paragraph {
    font-size: 15px;
    color: #333333;
    line-height: 1.7;
    margin-bottom: 20px;
    text-align: justify;
}

.paragraph strong {
    color: #000000;
    font-weight: 700;
}

.paragraph em {
    font-style: italic;
}

.paragraph code {
    font-family: 'Courier New', monospace;
    background: #f5f5f5;
    padding: 2px 6px;
    border-radius: 3px;
    font-size: 14px;
    border: 1px solid #e0e0e0;
}

/* ============================================================================
   LIST STYLES
   ============================================================================ */

.content-list {
    margin-left: 20px;
    margin-bottom: 20px;
}

.content-list ul, .content-list ol {
    margin-left: 20px;
    margin-top: 10px;
}

.content-list li {
    margin-bottom: 10px;
    color: #333333;
    font-size: 15px;
    line-height: 1.6;
}

.content-list li strong {
    color: #000000;
    font-weight: 700;
}

.content-list li code {
    font-family: 'Courier New', monospace;
    background: #f5f5f5;
    padding: 2px 6px;
    border-radius: 3px;
    font-size: 14px;
    border: 1px solid #e0e0e0;
}

/* ============================================================================
   CODE BLOCK STYLES
   ============================================================================ */

.code-block {
    margin: 25px 0;
    position: relative;
}

.code-block pre {
    margin: 0;
    padding: 0;
    border-radius: 6px;
    overflow: hidden;
    border: 1px solid #e0e0e0;
    background: #f8f9fa !important;
}

.code-block code {
    font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
    font-size: 14px;
    line-height: 1.5;
    display: block;
    padding: 20px;
    overflow-x: auto;
    color: #333333;
}

.copy-button {
    position: absolute;
    top: 10px;
    right: 10px;
    padding: 6px 12px;
    background: #000000;
    color: #ffffff;
    border: none;
    border-radius: 4px;
    font-size: 12px;
    cursor: pointer;
    opacity: 0.7;
    transition: opacity 0.2s ease;
    z-index: 10;
}

.copy-button:hover {
    opacity: 1;
}

.copy-button.copied {
    background: #2e7d32;
    opacity: 1;
}

/* Prism.js theme adjustments */
.token.comment, .token.prolog, .token.doctype, .token.cdata {
    color: #6a737d;
}

.token.punctuation {
    color: #333333;
}

.token.property, .token.tag, .token.boolean, .token.number, .token.constant, .token.symbol, .token.deleted {
    color: #005cc5;
}

.token.selector, .token.attr-name, .token.string, .token.char, .token.builtin, .token.inserted {
    color: #032f62;
}

.token.operator, .token.entity, .token.url, .language-css .token.string, .style .token.string {
    color: #d73a49;
}

.token.atrule, .token.attr-value, .token.keyword {
    color: #d73a49;
    font-weight: bold;
}

.token.function, .token.class-name {
    color: #6f42c1;
}

.token.regex, .token.important, .token.variable {
    color: #e36209;
}

/* ============================================================================
   SPECIAL CONTENT BLOCKS
   ============================================================================ */

.special-block {
    margin: 25px 0;
    padding: 20px;
    border-radius: 6px;
    border-left: 4px solid #000000;
    background: #f9f9f9;
}

.special-block.reference {
    border-left-color: #2e7d32;
}

.special-block.example {
    border-left-color: #1565c0;
}

.special-block.syntax {
    border-left-color: #6a1b9a;
}

.special-block.functions {
    border-left-color: #c62828;
}

.special-label {
    font-size: 16px;
    font-weight: 700;
    color: #000000;
    margin-bottom: 12px;
    display: flex;
    align-items: center;
}

.special-label::before {
    content: "";
    display: inline-block;
    width: 12px;
    height: 12px;
    background: currentColor;
    margin-right: 10px;
    border-radius: 2px;
}

.special-content {
    font-size: 15px;
    color: #333333;
    line-height: 1.6;
}

.special-content .content-line {
    margin-bottom: 8px;
}

/* ============================================================================
   HORIZONTAL RULE
   ============================================================================ */

.content-hr {
    border: none;
    height: 1px;
    background: linear-gradient(to right, transparent, #cccccc, transparent);
    margin: 40px 0;
}

/* ============================================================================
   FOOTER
   ============================================================================ */

.document-footer {
    margin-top: 60px;
    padding-top: 25px;
    border-top: 1px solid #cccccc;
    text-align: center;
}

.footer-content p {
    font-size: 14px;
    color: #666666;
    margin-bottom: 8px;
}

.document-stats {
    font-size: 13px !important;
    color: #888888 !important;
    font-style: italic;
}

/* ============================================================================
   RESPONSIVE DESIGN - MOBILE
   ============================================================================ */

@media (max-width: 900px) {
    .container {
        padding: 30px;
        max-width: 100%;
    }
    
    .document-title {
        font-size: 28px;
    }
    
    .document-meta {
        gap: 15px;
    }
    
    h1.section-heading {
        font-size: 24px;
    }
    
    h2.section-heading {
        font-size: 20px;
    }
    
    .code-block code {
        font-size: 13px;
        padding: 15px;
    }
}

@media (max-width: 768px) {
    .container {
        padding: 20px;
    }
    
    .document-title {
        font-size: 24px;
    }
    
    .document-meta {
        flex-direction: column;
        gap: 8px;
        align-items: center;
    }
    
    .document-meta .meta-item {
        width: 100%;
        max-width: 300px;
        text-align: center;
    }
    
    .table-of-contents {
        padding: 15px;
    }
    
    .toc-title {
        font-size: 16px;
    }
    
    .toc-list a {
        font-size: 14px;
    }
    
    h1.section-heading {
        font-size: 22px;
    }
    
    h2.section-heading {
        font-size: 18px;
    }
    
    h3.section-heading {
        font-size: 16px;
    }
    
    .paragraph {
        font-size: 14px;
    }
    
    .content-list li {
        font-size: 14px;
    }
    
    .special-block {
        padding: 15px;
    }
    
    .special-content {
        font-size: 14px;
    }
    
    .code-block code {
        font-size: 12px;
        padding: 12px;
    }
    
    .copy-button {
        font-size: 11px;
        padding: 5px 10px;
    }
}

@media (max-width: 480px) {
    .container {
        padding: 15px;
    }
    
    .document-title {
        font-size: 20px;
    }
    
    .document-header {
        margin-bottom: 30px;
        padding-bottom: 20px;
    }
    
    h1.section-heading {
        font-size: 20px;
    }
    
    h2.section-heading {
        font-size: 17px;
    }
    
    .paragraph {
        font-size: 13px;
    }
    
    .content-list {
        margin-left: 15px;
    }
    
    .content-list li {
        font-size: 13px;
    }
    
    .code-block {
        margin: 20px -15px;
        border-radius: 0;
    }
    
    .code-block pre {
        border-radius: 0;
        border-left: none;
        border-right: none;
    }
    
    .special-block {
        margin: 20px -15px;
        border-radius: 0;
        border-left: none;
        border-right: 4px solid #000000;
    }
}

/* ============================================================================
   PRINT STYLES
   ============================================================================ */

@media print {
    @page {
        margin: 0.5in;
        size: letter;
    }
    
    body {
        font-size: 12pt;
        line-height: 1.5;
        background: white !important;
        color: black !important;
    }
    
    .container {
        max-width: 100%;
        padding: 0;
        margin: 0;
    }
    
    .document-header {
        border-bottom: 1pt solid black;
        margin-bottom: 0.3in;
        padding-bottom: 0.2in;
    }
    
    .document-title {
        font-size: 16pt;
        margin-bottom: 0.1in;
    }
    
    .document-meta .meta-item {
        font-size: 9pt;
        border: 0.5pt solid #cccccc;
        background: #ffffff;
    }
    
    .table-of-contents {
        border-left: 2pt solid black;
        background: #ffffff !important;
        margin-bottom: 0.3in;
    }
    
    .toc-title {
        font-size: 11pt;
        border-bottom: 0.5pt solid #cccccc;
    }
    
    .toc-list a {
        font-size: 10pt;
        color: #000000;
    }
    
    .content-section {
        margin-bottom: 0.3in;
        page-break-inside: avoid;
    }
    
    .section-heading {
        font-weight: 700;
        color: #000000;
        border-bottom: 0.5pt solid #cccccc;
        page-break-after: avoid;
    }
    
    h1.section-heading {
        font-size: 14pt;
        border-bottom: 1pt solid black;
    }
    
    h2.section-heading {
        font-size: 12pt;
    }
    
    h3.section-heading {
        font-size: 11pt;
    }
    
    .paragraph {
        font-size: 11pt;
        text-align: left;
        margin-bottom: 0.15in;
    }
    
    .content-list {
        margin-left: 0.2in;
        margin-bottom: 0.15in;
    }
    
    .content-list li {
        font-size: 11pt;
        margin-bottom: 0.05in;
    }
    
    .code-block {
        margin: 0.2in 0;
        break-inside: avoid;
    }
    
    .code-block pre {
        border: 0.5pt solid #cccccc;
        background: #ffffff !important;
    }
    
    .code-block code {
        font-size: 9pt;
        padding: 0.15in;
        color: #000000;
    }
    
    /* Hide copy buttons in print */
    .copy-button {
        display: none !important;
    }
    
    .special-block {
        margin: 0.2in 0;
        padding: 0.15in;
        border-left: 2pt solid #000000;
        background: #ffffff !important;
        break-inside: avoid;
    }
    
    .special-label {
        font-size: 11pt;
    }
    
    .special-content {
        font-size: 11pt;
    }
    
    .content-hr {
        height: 0.5pt;
        margin: 0.3in 0;
    }
    
    .document-footer {
        margin-top: 0.3in;
        padding-top: 0.1in;
        border-top: 0.5pt solid #cccccc;
    }
    
    .footer-content p {
        font-size: 9pt;
        color: #666666;
    }
    
    /* Remove all transitions, shadows, and backgrounds for print */
    * {
        box-shadow: none !important;
        transition: none !important;
    }
    
    /* Ensure proper page breaks */
    .content-section, .special-block, .code-block {
        page-break-inside: avoid;
    }
    
    h1, h2 {
        page-break-after: avoid;
    }
    
    /* No URLs in print */
    a[href]::after {
        content: " (" attr(href) ")";
        font-size: 9pt;
        color: #666666;
    }
    
    a[href^="#"]::after {
        content: "";
    }
}

/* ============================================================================
   UTILITY CLASSES
   ============================================================================ */

::selection {
    background: rgba(0, 0, 0, 0.1);
    color: #000000;
}

/* Hide scrollbar for print */
@media print {
    ::-webkit-scrollbar {
        display: none;
    }
}

/* Focus styles for accessibility */
:focus {
    outline: 2px solid #000000;
    outline-offset: 2px;
}

:focus:not(:focus-visible) {
    outline: none;
}

/* Improve dark mode compatibility */
@media (prefers-color-scheme: dark) {
    .container, body {
        background: #ffffff !important;
        color: #000000 !important;
    }
}
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css">
</head>
<body>
    <div class="container">
        
        <header class="document-header">
            <h1 class="document-title">R Notes</h1>
          </header>
        
        
        <nav class="table-of-contents">
            <h2 class="toc-title">Table of Contents</h2>
            <ul class="toc-list">
                
            <li class="toc-indent">
                <a href="#introduction-to-the-r-language"><strong>Introduction to the R Language</strong></a>
            </li>
            

            <li class="toc-indent">
                <a href="#1-numeric-data"><strong>1. Numeric Data</strong></a>
            </li>
            

            <li class="toc-indent">
                <a href="#2-arithmetic-operations"><strong>2. Arithmetic Operations</strong></a>
            </li>
            

            <li class="toc-indent">
                <a href="#3-assignment-operators"><strong>3. Assignment Operators</strong></a>
            </li>
            

            <li class="toc-indent">
                <a href="#4-vectors"><strong>4. Vectors</strong></a>
            </li>
            

            <li class="toc-indent">
                <a href="#5-matrices"><strong>5. Matrices</strong></a>
            </li>
            

            <li class="toc-indent">
                <a href="#6-arrays"><strong>6. Arrays</strong></a>
            </li>
            

            <li class="toc-indent">
                <a href="#7-non-numeric-values"><strong>7. Non-numeric Values</strong></a>
            </li>
            

            <li class="toc-indent">
                <a href="#8-lists"><strong>8. Lists</strong></a>
            </li>
            

            <li class="toc-indent">
                <a href="#9-data-frames"><strong>9. Data Frames</strong></a>
            </li>
            

            <li class="toc-indent">
                <a href="#10-special-values"><strong>10. Special Values</strong></a>
            </li>
            

            <li class="toc-indent">
                <a href="#11-classes-and-coercion"><strong>11. Classes and Coercion</strong></a>
            </li>
            

            <li class="toc-indent">
                <a href="#12-basic-plotting"><strong>12. Basic Plotting</strong></a>
            </li>
            

            <li class="toc-indent">
                <a href="#13-reading-and-writing-files"><strong>13. Reading and Writing Files</strong></a>
            </li>
            

            <li class="toc-indent">
                <a href="#14-programming-fundamentals"><strong>14. Programming Fundamentals</strong></a>
            </li>
            

            <li class="toc-indent">
                <a href="#15-writing-functions"><strong>15. Writing Functions</strong></a>
            </li>
            

            <li class="toc-indent">
                <a href="#16-exceptions-and-error-handling"><strong>16. Exceptions and Error Handling</strong></a>
            </li>
            

            <li class="toc-indent">
                <a href="#17-timings-and-performance"><strong>17. Timings and Performance</strong></a>
            </li>
            

            <li class="toc-indent">
                <a href="#18-visibility-return-values"><strong>18. Visibility (Return Values)</strong></a>
            </li>
            

            <li class="toc-indent">
                <a href="#practical-examples-solutions"><strong>Practical Examples & Solutions</strong></a>
            </li>
            

            <li class="toc-indent">
                <a href="#important-formulas-functions-reference"><strong>Important Formulas & Functions Reference</strong></a>
            </li>
            

            <li class="toc-indent">
                <a href="#books-reference-as-per-karnataka-university-dharwad"><strong>Books Reference as per Karnataka University Dharwad</strong></a>
            </li>
            

            <li class="toc-indent">
                <a href="#examination-preparation-tips"><strong>Examination Preparation Tips</strong></a>
            </li>
            

            <li class="">
                <a href="#unit-2-statistics-and-probability"><strong>Unit 2: Statistics and Probability</strong></a>
            </li>
            

            <li class="toc-indent">
                <a href="#1-statistics-and-probability-overview"><strong>1. Statistics and Probability - Overview</strong></a>
            </li>
            

            <li class="toc-indent">
                <a href="#2-basic-data-visualization"><strong>2. Basic Data Visualization</strong></a>
            </li>
            

            <li class="toc-indent">
                <a href="#3-probability-fundamental-concepts"><strong>3. Probability - Fundamental Concepts</strong></a>
            </li>
            

            <li class="toc-indent">
                <a href="#4-common-probability-distributions"><strong>4. Common Probability Distributions</strong></a>
            </li>
            

            <li class="toc-indent">
                <a href="#5-common-probability-mass-functions-discrete-distributions"><strong>5. Common Probability Mass Functions (Discrete Distributions)</strong></a>
            </li>
            

            <li class="toc-indent">
                <a href="#6-common-probability-density-functions-continuous-distributions"><strong>6. Common Probability Density Functions (Continuous Distributions)</strong></a>
            </li>
            

            <li class="toc-indent">
                <a href="#7-distribution-relationships-and-transformations"><strong>7. Distribution Relationships and Transformations</strong></a>
            </li>
            

            <li class="toc-indent">
                <a href="#8-practical-applications-and-problem-solving"><strong>8. Practical Applications and Problem Solving</strong></a>
            </li>
            

            <li class="toc-indent">
                <a href="#9-formulas-and-reference-tables"><strong>9. Formulas and Reference Tables</strong></a>
            </li>
            

            <li class="toc-indent">
                <a href="#10-examination-focused-content"><strong>10. Examination-Focused Content</strong></a>
            </li>
            

            <li class="">
                <a href="#statistical-computing-r-programming-unit-3-statistical-testing-and-modelling-comprehensive-guide"><strong>Statistical Computing & R Programming - Unit 3: Statistical Testing and Modelling (Comprehensive Guide)</strong></a>
            </li>
            

            <li class="toc-indent">
                <a href="#1-statistical-testing-and-modelling-overview"><strong>1. Statistical Testing and Modelling - Overview</strong></a>
            </li>
            

            <li class="toc-indent">
                <a href="#2-sampling-distributions"><strong>2. Sampling Distributions</strong></a>
            </li>
            

            <li class="toc-indent">
                <a href="#3-hypothesis-testing"><strong>3. Hypothesis Testing</strong></a>
            </li>
            

            <li class="toc-indent">
                <a href="#4-testing-means"><strong>4. Testing Means</strong></a>
            </li>
            

            <li class="toc-indent">
                <a href="#5-testing-proportions"><strong>5. Testing Proportions</strong></a>
            </li>
            

            <li class="toc-indent">
                <a href="#6-testing-categorical-variables"><strong>6. Testing Categorical Variables</strong></a>
            </li>
            

            <li class="toc-indent">
                <a href="#7-errors-and-power"><strong>7. Errors and Power</strong></a>
            </li>
            

            <li class="toc-indent">
                <a href="#8-analysis-of-variance-anova"><strong>8. Analysis of Variance (ANOVA)</strong></a>
            </li>
            

            <li class="toc-indent">
                <a href="#9-complete-statistical-analysis-framework"><strong>9. Complete Statistical Analysis Framework</strong></a>
            </li>
            

            <li class="toc-indent">
                <a href="#10-books-reference-as-per-karnataka-university-dharwad"><strong>10. Books Reference as per Karnataka University Dharwad</strong></a>
            </li>
            

            <li class="toc-indent">
                <a href="#important-formulas-reference"><strong>Important Formulas Reference</strong></a>
            </li>
            

            <li class="toc-indent">
                <a href="#examination-preparation"><strong>Examination Preparation</strong></a>
            </li>
            

            <li class="toc-indent">
                <a href="#1-simple-linear-regression"><strong>1. Simple Linear Regression</strong></a>
            </li>
            

            <li class="toc-indent">
                <a href="#2-multiple-linear-regression"><strong>2. Multiple Linear Regression</strong></a>
            </li>
            

            <li class="toc-indent">
                <a href="#3-linear-model-selection-and-diagnostics"><strong>3. Linear Model Selection and Diagnostics</strong></a>
            </li>
            

            <li class="toc-indent">
                <a href="#4-advanced-graphics-plot-customization"><strong>4. Advanced Graphics: Plot Customization</strong></a>
            </li>
            

            <li class="toc-indent">
                <a href="#5-defining-colors-and-plotting-in-higher-dimensions"><strong>5. Defining Colors and Plotting in Higher Dimensions</strong></a>
            </li>
            

            <li class="toc-indent">
                <a href="#6-complete-unit-4-integration-example"><strong>6. Complete Unit 4 Integration Example</strong></a>
            </li>
            

            <li class="toc-indent">
                <a href="#books-reference-as-per-karnataka-university-dharwad"><strong>Books Reference as per Karnataka University Dharwad</strong></a>
            </li>
            

            <li class="toc-indent">
                <a href="#important-formulas-and-concepts"><strong>Important Formulas and Concepts</strong></a>
            </li>
            

            <li class="toc-indent">
                <a href="#examination-preparation"><strong>Examination Preparation</strong></a>
            </li>
            
            </ul>
        </nav>
        
        <main class="content">
            
            <section class="content-section" id="statistical-computing-r-programming">
                <h3 class="section-heading"><strong>Statistical Computing & R Programming </strong></h3>
            
<p class="paragraph">##<strong>Unit 1: Introduction </strong></p>
</section>

            <section class="content-section" id="introduction-to-the-r-language">
                <h2 class="section-heading"><strong>Introduction to the R Language</strong></h2>
            
<ul class="content-list"><li><strong>Meaning</strong>: R is an open-source programming language and environment for statistical computing, data analysis, and graphical visualization.</li>
<li><strong>Definition</strong>: R is a functional programming language developed by Ross Ihaka and Robert Gentleman (1993) implementing the S language. It provides:</li></ul>
<ul class="content-list"><li><strong>Characteristics</strong>:</li></ul>
<pre class="paragraph">- Statistical techniques (linear/nonlinear modeling, tests, time-series analysis, classification, clustering)
  - Extensive graphical capabilities
  - Extensibility through packages
  - Interpreted language (no compilation needed)
  - Object-oriented and functional features
  - Vectorized operations
  - Cross-platform (Windows, macOS, Linux)
  - Large community with 18,000+ packages on CRAN</pre>

            <div class="special-block reference">
                <div class="special-label">Reference: Davies (2016) Chapter 1; Pawgi (2022) Chapter 1</div>
                <div class="special-content"></div>
            </div>
            
<hr class="content-hr">
</section>

            <section class="content-section" id="1-numeric-data">
                <h2 class="section-heading"><strong>1. Numeric Data</strong></h2>
            
<ul class="content-list"><li><strong>Definition</strong>: Basic numeric data types in R for representing numbers</li>
<li><strong>Types</strong>:</li></ul>
<ul class="content-list"><li><strong>Syntax</strong>:</li></ul>

            <div class="code-block">
                <pre><code class="language-r">  x &lt;- 10      # Double by default
  y &lt;- 15L     # Integer (with L suffix)
  z &lt;- 3+4i    # Complex</code></pre>
            </div>
            
<ul class="content-list"><li><strong>Functions</strong>:</li></ul>

            <div class="code-block">
                <pre><code class="language-r">  class(5)      # &quot;numeric&quot;
  is.numeric(5) # TRUE
  as.integer(3.14) # 3</code></pre>
            </div>
            
<p class="paragraph">1. <strong>Integer</strong>: Whole numbers (e.g., <code>42L</code>)
  2. <strong>Double</strong>: Decimal numbers (e.g., <code>3.14</code>)
  3. <strong>Complex</strong>: Complex numbers (e.g., <code>3+2i</code>)</p>
<hr class="content-hr">
</section>

            <section class="content-section" id="2-arithmetic-operations">
                <h2 class="section-heading"><strong>2. Arithmetic Operations</strong></h2>
            
<ul class="content-list"><li><strong>Operators</strong>:</li></ul>
<ul class="content-list"><li><strong>Example</strong>:</li></ul>

            <div class="code-block">
                <pre><code class="language-r">  5 + 3 * 2^2  # Result: 17 (order: ^, *, +)
  (5 + 3) * 2^2 # Result: 32
  10 %% 3      # Remainder: 1
  10 %/% 3     # Quotient: 3</code></pre>
            </div>
            
<ul class="content-list"><li><strong>Vectorized Arithmetic</strong>:</li></ul>

            <div class="code-block">
                <pre><code class="language-r">  c(1,2,3) * 2  # Returns: 2,4,6
  c(1,2,3) + c(4,5,6) # Returns: 5,7,9</code></pre>
            </div>
            
<p class="paragraph">- Addition: <code>+</code>
  - Subtraction: <code>-</code>
  - Multiplication: <code>*</code>
  - Division: <code>/</code>
  - Exponentiation: <code>^</code> or <code>**</code>
  - Modulus: <code>%%</code>
  - Integer Division: <code>%/%</code></p>
<hr class="content-hr">
</section>

            <section class="content-section" id="3-assignment-operators">
                <h2 class="section-heading"><strong>3. Assignment Operators</strong></h2>
            
<ul class="content-list"><li><strong>Types</strong>:</li></ul>
<ul class="content-list"><li><strong>Syntax</strong>:</li></ul>

            <div class="code-block">
                <pre><code class="language-r">  x &lt;- 5      # Assign 5 to x
  x = 5       # Alternative
  5 -&gt; x      # Rightward assignment
  assign(&quot;x&quot;, 5) # Using function</code></pre>
            </div>
            
<ul class="content-list"><li><strong>Characteristics</strong>:</li></ul>
<p class="paragraph">1. <code><-</code> : Preferred assignment operator
  2. <code>=</code> : Alternative assignment
  3. <code><<-</code> : Global assignment
  4. <code>-></code> : Rightward assignment
  - <code><-</code> is directional (value to variable)
  - Can chain assignments: <code>x <- y <- 5</code>
  - Variables are case-sensitive</p>
<hr class="content-hr">
</section>

            <section class="content-section" id="4-vectors">
                <h2 class="section-heading"><strong>4. Vectors</strong></h2>
            
<ul class="content-list"><li><strong>Definition</strong>: One-dimensional array holding elements of same type</li>
<li><strong>Creation</strong>:</li></ul>

            <div class="code-block">
                <pre><code class="language-r">  # Using c() function
  v1 &lt;- c(1, 2, 3, 4, 5)
  
  # Using sequence operator
  v2 &lt;- 1:5           # 1,2,3,4,5
  
  # Using seq() function
  v3 &lt;- seq(1, 10, by=2) # 1,3,5,7,9
  
  # Using rep() function
  v4 &lt;- rep(1:3, times=2) # 1,2,3,1,2,3</code></pre>
            </div>
            
<ul class="content-list"><li><strong>Operations</strong>:</li></ul>

            <div class="code-block">
                <pre><code class="language-r">  # Element-wise operations
  v1 + v2
  v1 * 2
  
  # Vector functions
  length(v1)    # Number of elements
  sum(v1)       # Sum of elements
  mean(v1)      # Average
  sort(v1)      # Sorted vector
  rev(v1)       # Reversed vector</code></pre>
            </div>
            
<ul class="content-list"><li><strong>Indexing</strong>:</li></ul>

            <div class="code-block">
                <pre><code class="language-r">  v1[3]         # Third element
  v1[2:4]       # Elements 2 through 4
  v1[c(1,3,5)]  # Specific elements
  v1[v1 &gt; 2]    # Elements greater than 2</code></pre>
            </div>
            

            <div class="special-block reference">
                <div class="special-label">Reference: Davies (2016) Chapter 2; Pawgi (2022) Chapter 2</div>
                <div class="special-content"></div>
            </div>
            
<hr class="content-hr">
</section>

            <section class="content-section" id="5-matrices">
                <h2 class="section-heading"><strong>5. Matrices</strong></h2>
            
<ul class="content-list"><li><strong>Definition</strong>: Two-dimensional rectangular data structure with rows and columns</li>
<li><strong>Creation</strong>:</li></ul>

            <div class="code-block">
                <pre><code class="language-r">  # Using matrix() function
  m1 &lt;- matrix(1:12, nrow=3, ncol=4)
  m2 &lt;- matrix(1:12, nrow=3, ncol=4, byrow=TRUE)
  
  # Using rbind() and cbind()
  m3 &lt;- rbind(c(1,2,3), c(4,5,6))
  m4 &lt;- cbind(c(1,2,3), c(4,5,6))</code></pre>
            </div>
            
<ul class="content-list"><li><strong>Operations</strong>:</li></ul>

            <div class="code-block">
                <pre><code class="language-r">  dim(m1)       # Dimensions: rows, columns
  nrow(m1)      # Number of rows
  ncol(m1)      # Number of columns
  t(m1)         # Transpose
  m1 %*% t(m1)  # Matrix multiplication
  
  # Element access
  m1[2,3]       # Element at row 2, column 3
  m1[2,]        # Entire second row
  m1[,3]        # Entire third column</code></pre>
            </div>
            
<hr class="content-hr">
</section>

            <section class="content-section" id="6-arrays">
                <h2 class="section-heading"><strong>6. Arrays</strong></h2>
            
<ul class="content-list"><li><strong>Definition</strong>: Multi-dimensional generalization of matrices</li>
<li><strong>Creation</strong>:</li></ul>

            <div class="code-block">
                <pre><code class="language-r">  # 3-dimensional array
  arr &lt;- array(1:24, dim=c(3,4,2))
  
  # Accessing elements
  arr[2,3,1]    # Element at position (2,3,1)
  arr[,,2]      # Entire second layer</code></pre>
            </div>
            
<ul class="content-list"><li><strong>Characteristics</strong>:</li></ul>
<p class="paragraph">- Can have more than 2 dimensions
  - All elements must be of same type
  - <code>dim()</code> returns dimensions</p>
<hr class="content-hr">
</section>

            <section class="content-section" id="7-non-numeric-values">
                <h2 class="section-heading"><strong>7. Non-numeric Values</strong></h2>
            
<ul class="content-list"><li><strong>Types</strong>:</li></ul>

            <div class="code-block">
                <pre><code class="language-r">     str1 &lt;- &quot;Hello&quot;
     str2 &lt;- &#x27;World&#x27;
     paste(str1, str2) # &quot;Hello World&quot;</code></pre>
            </div>
            

            <div class="code-block">
                <pre><code class="language-r">     x &lt;- TRUE
     y &lt;- FALSE
     z &lt;- 5 &gt; 3  # TRUE</code></pre>
            </div>
            

            <div class="code-block">
                <pre><code class="language-r">     gender &lt;- factor(c(&quot;M&quot;,&quot;F&quot;,&quot;M&quot;,&quot;F&quot;))
     levels(gender)  # &quot;F&quot; &quot;M&quot;</code></pre>
            </div>
            
<p class="paragraph">1. <strong>Character</strong>: Text strings
  2. <strong>Logical</strong>: TRUE/FALSE
  3. <strong>Factors</strong>: Categorical variables</p>
<hr class="content-hr">
</section>

            <section class="content-section" id="8-lists">
                <h2 class="section-heading"><strong>8. Lists</strong></h2>
            
<ul class="content-list"><li><strong>Definition</strong>: Ordered collection of objects (can be of different types)</li>
<li><strong>Creation</strong>:</li></ul>

            <div class="code-block">
                <pre><code class="language-r">  mylist &lt;- list(
    name = &quot;John&quot;,
    age = 25,
    scores = c(85, 90, 78),
    passed = TRUE
  )</code></pre>
            </div>
            
<ul class="content-list"><li><strong>Access</strong>:</li></ul>

            <div class="code-block">
                <pre><code class="language-r">  mylist$name          # &quot;John&quot;
  mylist[[2]]          # 25
  mylist[[&quot;scores&quot;]]   # Vector of scores
  mylist[[3]][2]       # Second score: 90</code></pre>
            </div>
            
<ul class="content-list"><li><strong>Functions</strong>:</li></ul>

            <div class="code-block">
                <pre><code class="language-r">  length(mylist)       # Number of elements
  names(mylist)        # Element names
  unlist(mylist)       # Convert to vector</code></pre>
            </div>
            
<hr class="content-hr">
</section>

            <section class="content-section" id="9-data-frames">
                <h2 class="section-heading"><strong>9. Data Frames</strong></h2>
            
<ul class="content-list"><li><strong>Definition</strong>: Tabular data structure with rows and columns (like spreadsheet)</li>
<li><strong>Characteristics</strong>:</li></ul>
<ul class="content-list"><li><strong>Creation</strong>:</li></ul>

            <div class="code-block">
                <pre><code class="language-r">  df &lt;- data.frame(
    Name = c(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;),
    Age = c(25, 30, 35),
    Score = c(85.5, 92.0, 78.5),
    Passed = c(TRUE, TRUE, FALSE)
  )</code></pre>
            </div>
            
<ul class="content-list"><li><strong>Operations</strong>:</li></ul>

            <div class="code-block">
                <pre><code class="language-r">  dim(df)             # Dimensions
  nrow(df)            # Number of rows
  ncol(df)            # Number of columns
  names(df)           # Column names
  head(df, 2)         # First 2 rows
  summary(df)         # Summary statistics
  
  # Accessing elements
  df$Age              # Age column
  df[2,3]             # Row 2, Column 3
  df[,&quot;Name&quot;]         # Name column
  df[df$Score &gt; 80,]  # Filter rows</code></pre>
            </div>
            
<p class="paragraph">- Columns can be of different types
  - Each column has same length
  - Most common structure for datasets</p>

            <div class="special-block reference">
                <div class="special-label">Reference: Davies (2016) Chapter 3; Pawgi (2022) Chapter 3</div>
                <div class="special-content"></div>
            </div>
            
<hr class="content-hr">
</section>

            <section class="content-section" id="10-special-values">
                <h2 class="section-heading"><strong>10. Special Values</strong></h2>
            
<ul class="content-list"><li><strong>NA</strong>: Missing/Not Available</li></ul>

            <div class="code-block">
                <pre><code class="language-r">  x &lt;- c(1, NA, 3)
  is.na(x)  # FALSE TRUE FALSE</code></pre>
            </div>
            
<ul class="content-list"><li><strong>NULL</strong>: Empty object</li>
<li><strong>NaN</strong>: Not a Number (mathematically undefined)</li></ul>

            <div class="code-block">
                <pre><code class="language-r">  0/0  # NaN</code></pre>
            </div>
            
<ul class="content-list"><li><strong>Inf / -Inf</strong>: Infinity</li></ul>

            <div class="code-block">
                <pre><code class="language-r">  1/0  # Inf
  -1/0 # -Inf</code></pre>
            </div>
            
<ul class="content-list"><li><strong>Testing Functions</strong>:</li></ul>

            <div class="code-block">
                <pre><code class="language-r">  is.na(), is.null(), is.nan(), is.infinite()</code></pre>
            </div>
            
<hr class="content-hr">
</section>

            <section class="content-section" id="11-classes-and-coercion">
                <h2 class="section-heading"><strong>11. Classes and Coercion</strong></h2>
            
<ul class="content-list"><li><strong>Classes</strong>: Object type/classification</li></ul>

            <div class="code-block">
                <pre><code class="language-r">  class(5)        # &quot;numeric&quot;
  class(&quot;hello&quot;)  # &quot;character&quot;
  class(TRUE)     # &quot;logical&quot;</code></pre>
            </div>
            
<ul class="content-list"><li><strong>Coercion</strong>: Converting between types</li></ul>

            <div class="code-block">
                <pre><code class="language-r">  # Automatic coercion (less restrictive to more restrictive)
  x &lt;- c(1, &quot;hello&quot;)  # Becomes character
  
  # Explicit coercion
  as.numeric(&quot;123&quot;)   # 123
  as.character(456)   # &quot;456&quot;
  as.logical(1)       # TRUE
  as.logical(0)       # FALSE
  
  # Coercion hierarchy: logical → integer → numeric → complex → character</code></pre>
            </div>
            
<hr class="content-hr">
</section>

            <section class="content-section" id="12-basic-plotting">
                <h2 class="section-heading"><strong>12. Basic Plotting</strong></h2>
            
<ul class="content-list"><li><strong>Types of Plots</strong>:</li></ul>

            <div class="code-block">
                <pre><code class="language-r">  # Scatter plot
  plot(x, y, main=&quot;Scatter Plot&quot;, xlab=&quot;X-axis&quot;, ylab=&quot;Y-axis&quot;)
  
  # Line plot
  plot(x, y, type=&quot;l&quot;)
  
  # Histogram
  hist(data, main=&quot;Histogram&quot;, col=&quot;blue&quot;)
  
  # Boxplot
  boxplot(data, main=&quot;Boxplot&quot;)
  
  # Bar plot
  barplot(c(10,20,15), names=c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;))
  
  # Multiple plots
  par(mfrow=c(2,2))  # 2x2 grid</code></pre>
            </div>
            
<ul class="content-list"><li><strong>Customization</strong>:</li></ul>

            <div class="code-block">
                <pre><code class="language-r">  plot(x, y, 
       col=&quot;red&quot;,        # Color
       pch=19,           # Point shape
       cex=1.5,          # Point size
       lwd=2,            # Line width
       lty=2)            # Line type</code></pre>
            </div>
            
<hr class="content-hr">
</section>

            <section class="content-section" id="13-reading-and-writing-files">
                <h2 class="section-heading"><strong>13. Reading and Writing Files</strong></h2>
            
<ul class="content-list"><li><strong>Reading Files</strong>:</li></ul>

            <div class="code-block">
                <pre><code class="language-r">  # CSV files
  data &lt;- read.csv(&quot;filename.csv&quot;)
  data &lt;- read.csv(&quot;filename.csv&quot;, header=TRUE, stringsAsFactors=FALSE)
  
  # Text files
  data &lt;- read.table(&quot;filename.txt&quot;, sep=&quot;\t&quot;)
  
  # Excel files (need readxl package)
  # library(readxl)
  # data &lt;- read_excel(&quot;filename.xlsx&quot;)</code></pre>
            </div>
            
<ul class="content-list"><li><strong>Writing Files</strong>:</li></ul>

            <div class="code-block">
                <pre><code class="language-r">  write.csv(data, &quot;output.csv&quot;, row.names=FALSE)
  write.table(data, &quot;output.txt&quot;, sep=&quot;\t&quot;)</code></pre>
            </div>
            
<ul class="content-list"><li><strong>File Connections</strong>:</li></ul>

            <div class="code-block">
                <pre><code class="language-r">  # For large files
  con &lt;- file(&quot;largefile.txt&quot;, &quot;r&quot;)
  data &lt;- readLines(con, n=1000)
  close(con)</code></pre>
            </div>
            

            <div class="special-block reference">
                <div class="special-label">Reference: Davies (2016) Chapter 4; Pawgi (2022) Chapter 4</div>
                <div class="special-content"></div>
            </div>
            
<hr class="content-hr">
</section>

            <section class="content-section" id="14-programming-fundamentals">
                <h2 class="section-heading"><strong>14. Programming Fundamentals</strong></h2>
            
</section>

            <section class="content-section" id="calling-functions">
                <h3 class="section-heading"><strong>Calling Functions</strong></h3>
            
<ul class="content-list"><li><strong>Syntax</strong>: <code>function_name(arguments)</code></li>
<li><strong>Components</strong>:</li></ul>

            <div class="code-block">
                <pre><code class="language-r">  result &lt;- function_name(arg1, arg2, arg3)
  # function_name: name of function
  # arguments: input values
  # result: returned value</code></pre>
            </div>
            
<ul class="content-list"><li><strong>Example</strong>:</li></ul>

            <div class="code-block">
                <pre><code class="language-r">  mean(x, na.rm=TRUE)  # na.rm is argument name</code></pre>
            </div>
            
</section>

            <section class="content-section" id="conditions-control-structures">
                <h3 class="section-heading"><strong>Conditions (Control Structures)</strong></h3>
            
<ul class="content-list"><li><strong>if statement</strong>:</li></ul>

            <div class="code-block">
                <pre><code class="language-r">  if (condition) {
    # code to execute if TRUE
  }</code></pre>
            </div>
            
<ul class="content-list"><li><strong>if-else</strong>:</li></ul>

            <div class="code-block">
                <pre><code class="language-r">  if (condition) {
    # code if TRUE
  } else {
    # code if FALSE
  }</code></pre>
            </div>
            
<ul class="content-list"><li><strong>if-else ladder</strong>:</li></ul>

            <div class="code-block">
                <pre><code class="language-r">  if (score &gt;= 90) {
    grade &lt;- &quot;A&quot;
  } else if (score &gt;= 80) {
    grade &lt;- &quot;B&quot;
  } else {
    grade &lt;- &quot;C&quot;
  }</code></pre>
            </div>
            
<ul class="content-list"><li><strong>switch statement</strong>:</li></ul>

            <div class="code-block">
                <pre><code class="language-r">  day &lt;- 3
  day_name &lt;- switch(day,
                     &quot;Monday&quot;,
                     &quot;Tuesday&quot;,
                     &quot;Wednesday&quot;,
                     &quot;Thursday&quot;)</code></pre>
            </div>
            
</section>

            <section class="content-section" id="loops">
                <h3 class="section-heading"><strong>Loops</strong></h3>
            
<ul class="content-list"><li><strong>for loop</strong>:</li></ul>

            <div class="code-block">
                <pre><code class="language-r">  for (variable in sequence) {
    # code to repeat
  }
  
  # Example
  for (i in 1:5) {
    print(i^2)
  }</code></pre>
            </div>
            
<ul class="content-list"><li><strong>while loop</strong>:</li></ul>

            <div class="code-block">
                <pre><code class="language-r">  while (condition) {
    # code to repeat while TRUE
  }
  
  # Example
  x &lt;- 1
  while (x &lt;= 5) {
    print(x)
    x &lt;- x + 1
  }</code></pre>
            </div>
            
<ul class="content-list"><li><strong>repeat loop</strong>:</li></ul>

            <div class="code-block">
                <pre><code class="language-r">  repeat {
    # code
    if (condition) break
  }</code></pre>
            </div>
            
</section>

            <section class="content-section" id="stand-alone-statements-with-illustrations">
                <h3 class="section-heading"><strong>Stand-alone Statements with Illustrations</strong></h3>
            
<ul class="content-list"><li><strong>Break</strong>: Exits loop</li></ul>

            <div class="code-block">
                <pre><code class="language-r">  for (i in 1:10) {
    if (i == 5) break
    print(i)
  }</code></pre>
            </div>
            
<ul class="content-list"><li><strong>Next</strong>: Skips current iteration</li></ul>

            <div class="code-block">
                <pre><code class="language-r">  for (i in 1:5) {
    if (i == 3) next
    print(i)
  }</code></pre>
            </div>
            
<ul class="content-list"><li><strong>Return</strong>: Exits function with value</li></ul>
</section>

            <section class="content-section" id="stacking-statements">
                <h3 class="section-heading"><strong>Stacking Statements</strong></h3>
            
<ul class="content-list"><li><strong>Multiple statements in one line</strong>:</li></ul>

            <div class="code-block">
                <pre><code class="language-r">  x &lt;- 5; y &lt;- 10; z &lt;- x + y</code></pre>
            </div>
            
<ul class="content-list"><li><strong>Using braces</strong>:</li></ul>

            <div class="code-block">
                <pre><code class="language-r">  {
    x &lt;- 5
    y &lt;- 10
    z &lt;- x + y
  }</code></pre>
            </div>
            
</section>

            <section class="content-section" id="coding-loops-best-practices">
                <h3 class="section-heading"><strong>Coding Loops - Best Practices</strong></h3>
            
<ol class="content-list"><li><strong>Pre-allocation</strong>:</li></ol>

            <div class="code-block">
                <pre><code class="language-r">   # Inefficient
   result &lt;- NULL
   for (i in 1:10000) {
     result &lt;- c(result, i^2)
   }
   
   # Efficient
   result &lt;- numeric(10000)
   for (i in 1:10000) {
     result[i] &lt;- i^2
   }</code></pre>
            </div>
            
<ol class="content-list"><li><strong>Vectorization over loops</strong>:</li></ol>

            <div class="code-block">
                <pre><code class="language-r">   # Instead of loop
   result &lt;- 1:10000 ^ 2</code></pre>
            </div>
            
<hr class="content-hr">
</section>

            <section class="content-section" id="15-writing-functions">
                <h2 class="section-heading"><strong>15. Writing Functions</strong></h2>
            
<ul class="content-list"><li><strong>Syntax</strong>:</li></ul>

            <div class="code-block">
                <pre><code class="language-r">  function_name &lt;- function(parameters) {
    # Function body
    return(value)
  }</code></pre>
            </div>
            
<ul class="content-list"><li><strong>Example</strong>:</li></ul>

            <div class="code-block">
                <pre><code class="language-r">  # Function to calculate area of circle
  circle_area &lt;- function(radius) {
    area &lt;- pi * radius^2
    return(area)
  }
  
  # Calling function
  circle_area(5)  # 78.53982</code></pre>
            </div>
            
<ul class="content-list"><li><strong>Default Arguments</strong>:</li></ul>

            <div class="code-block">
                <pre><code class="language-r">  power &lt;- function(x, exponent=2) {
    return(x^exponent)
  }
  
  power(5)     # 25 (uses default exponent=2)
  power(5, 3)  # 125</code></pre>
            </div>
            
<ul class="content-list"><li><strong>Multiple Returns</strong>:</li></ul>

            <div class="code-block">
                <pre><code class="language-r">  stats &lt;- function(x) {
    return(list(
      mean = mean(x),
      sd = sd(x),
      length = length(x)
    ))
  }</code></pre>
            </div>
            
<hr class="content-hr">
</section>

            <section class="content-section" id="16-exceptions-and-error-handling">
                <h2 class="section-heading"><strong>16. Exceptions and Error Handling</strong></h2>
            
<ul class="content-list"><li><strong>tryCatch()</strong>:</li></ul>

            <div class="code-block">
                <pre><code class="language-r">  result &lt;- tryCatch({
    # Code that might fail
    sqrt(-1)
  }, warning = function(w) {
    # Handle warning
    message(&quot;Warning: &quot;, w)
    return(NA)
  }, error = function(e) {
    # Handle error
    message(&quot;Error: &quot;, e)
    return(NA)
  })</code></pre>
            </div>
            
<ul class="content-list"><li><strong>stop()</strong>: Generate error</li></ul>

            <div class="code-block">
                <pre><code class="language-r">  validate_input &lt;- function(x) {
    if (!is.numeric(x)) {
      stop(&quot;Input must be numeric&quot;)
    }
  }</code></pre>
            </div>
            
<ul class="content-list"><li><strong>warning()</strong>: Generate warning</li>
<li><strong>message()</strong>: Informative message</li></ul>
<hr class="content-hr">
</section>

            <section class="content-section" id="17-timings-and-performance">
                <h2 class="section-heading"><strong>17. Timings and Performance</strong></h2>
            
<ul class="content-list"><li><strong>System Time</strong>:</li></ul>

            <div class="code-block">
                <pre><code class="language-r">  # Measure execution time
  start_time &lt;- Sys.time()
  # Code to time
  end_time &lt;- Sys.time()
  elapsed &lt;- end_time - start_time</code></pre>
            </div>
            
<ul class="content-list"><li><strong>system.time()</strong>:</li></ul>

            <div class="code-block">
                <pre><code class="language-r">  system.time({
    # Code block
    x &lt;- rnorm(1000000)
    mean(x)
  })</code></pre>
            </div>
            
<ul class="content-list"><li><strong>microbenchmark package</strong>:</li></ul>

            <div class="code-block">
                <pre><code class="language-r">  # library(microbenchmark)
  # microbenchmark(
  #   mean(x),
  #   sum(x)/length(x),
  #   times=1000
  # )</code></pre>
            </div>
            
<hr class="content-hr">
</section>

            <section class="content-section" id="18-visibility-return-values">
                <h2 class="section-heading"><strong>18. Visibility (Return Values)</strong></h2>
            
<ul class="content-list"><li><strong>Explicit return</strong>:</li></ul>

            <div class="code-block">
                <pre><code class="language-r">  f1 &lt;- function(x) {
    return(x^2)  # Explicit
  }</code></pre>
            </div>
            
<ul class="content-list"><li><strong>Implicit return</strong>: Last evaluated expression</li></ul>

            <div class="code-block">
                <pre><code class="language-r">  f2 &lt;- function(x) {
    x^2  # Implicit return
  }</code></pre>
            </div>
            
<ul class="content-list"><li><strong>Invisible return</strong>:</li></ul>

            <div class="code-block">
                <pre><code class="language-r">  f3 &lt;- function(x) {
    invisible(x^2)  # Won&#x27;t auto-print
  }
  
  result &lt;- f3(5)  # No output
  print(result)    # Shows 25</code></pre>
            </div>
            
<hr class="content-hr">
</section>

            <section class="content-section" id="practical-examples-solutions">
                <h2 class="section-heading"><strong>Practical Examples & Solutions</strong></h2>
            
</section>

            <section class="content-section" id="example-1-complete-program-structure">
                <h3 class="section-heading"><strong>Example 1: Complete Program Structure</strong></h3>
            

            <div class="code-block">
                <pre><code class="language-r"># 1. Data input
data &lt;- read.csv(&quot;students.csv&quot;)

# 2. Data cleaning
data$Score[is.na(data$Score)] &lt;- mean(data$Score, na.rm=TRUE)

# 3. Function definition
calculate_grade &lt;- function(score) {
  if(score &gt;= 90) return(&quot;A&quot;)
  else if(score &gt;= 80) return(&quot;B&quot;)
  else if(score &gt;= 70) return(&quot;C&quot;)
  else return(&quot;F&quot;)
}

# 4. Apply function
data$Grade &lt;- sapply(data$Score, calculate_grade)

# 5. Summary statistics
summary_stats &lt;- list(
  Mean = mean(data$Score),
  Median = median(data$Score),
  SD = sd(data$Score)
)

# 6. Visualization
hist(data$Score, main=&quot;Score Distribution&quot;, col=&quot;lightblue&quot;)
boxplot(Score ~ Grade, data=data, main=&quot;Scores by Grade&quot;)

# 7. Output
write.csv(data, &quot;students_with_grades.csv&quot;, row.names=FALSE)
print(summary_stats)</code></pre>
            </div>
            
</section>

            <section class="content-section" id="example-2-matrix-operations">
                <h3 class="section-heading"><strong>Example 2: Matrix Operations</strong></h3>
            

            <div class="code-block">
                <pre><code class="language-r"># Create matrices
A &lt;- matrix(1:9, nrow=3, byrow=TRUE)
B &lt;- matrix(9:1, nrow=3, byrow=TRUE)

# Operations
C &lt;- A + B        # Element-wise addition
D &lt;- A %*% B      # Matrix multiplication
E &lt;- solve(D)     # Inverse (if square and invertible)
F &lt;- t(A)         # Transpose

# Eigen decomposition
eigen_result &lt;- eigen(D)</code></pre>
            </div>
            
</section>

            <section class="content-section" id="example-3-data-frame-manipulation">
                <h3 class="section-heading"><strong>Example 3: Data Frame Manipulation</strong></h3>
            

            <div class="code-block">
                <pre><code class="language-r"># Create sample data
students &lt;- data.frame(
  ID = 1:10,
  Name = paste(&quot;Student&quot;, 1:10),
  Math = round(rnorm(10, 75, 10)),
  Science = round(rnorm(10, 80, 8)),
  English = round(rnorm(10, 70, 12))
)

# Add calculated column
students$Average &lt;- rowMeans(students[,3:5])

# Subset data
top_students &lt;- students[students$Average &gt; 80,]
math_high &lt;- students[students$Math &gt; 85,]

# Aggregate
subject_means &lt;- colMeans(students[,3:5])</code></pre>
            </div>
            
<hr class="content-hr">
</section>

            <section class="content-section" id="important-formulas-functions-reference">
                <h2 class="section-heading"><strong>Important Formulas & Functions Reference</strong></h2>
            
</section>

            <section class="content-section" id="mathematical-formulas-in-r">
                <h3 class="section-heading"><strong>Mathematical Formulas in R</strong></h3>
            
<ol class="content-list"><li><strong>Mean</strong>: <code>sum(x)/length(x)</code> or <code>mean(x)</code></li>
<li><strong>Variance</strong>: <code>sum((x-mean(x))^2)/(length(x)-1)</code> or <code>var(x)</code></li>
<li><strong>Standard Deviation</strong>: <code>sqrt(var(x))</code> or <code>sd(x)</code></li>
<li><strong>Correlation</strong>: <code>cor(x, y)</code></li>
<li><strong>Linear Regression</strong>: <code>lm(y ~ x)</code></li></ol>
</section>

            <section class="content-section" id="essential-functions-summary">
                <h3 class="section-heading"><strong>Essential Functions Summary</strong></h3>
            

            <div class="code-block">
                <pre><code class="language-r"># Statistical
mean(), median(), sd(), var(), quantile(), summary()

# Mathematical
sum(), prod(), min(), max(), range(), diff(), cumsum()

# Data manipulation
length(), dim(), nrow(), ncol(), names(), colnames(), rownames()

# Type checking
is.numeric(), is.character(), is.logical(), is.factor(), is.data.frame()

# Type conversion
as.numeric(), as.character(), as.factor(), as.data.frame(), as.matrix()</code></pre>
            </div>
            
<hr class="content-hr">
</section>

            <section class="content-section" id="books-reference-as-per-karnataka-university-dharwad">
                <h2 class="section-heading"><strong>Books Reference as per Karnataka University Dharwad</strong></h2>
            
</section>

            <section class="content-section" id="primary-references">
                <h3 class="section-heading"><strong>Primary References:</strong></h3>
            
<ol class="content-list"><li><strong>Tilman M. Davies (2016)</strong> - "The Book of R"</li></ol>
<p class="paragraph">- Chapters 1-7 cover all Unit 1 topics comprehensively
   - Excellent for beginners with detailed examples
   - Practical approach with exercises</p>
<ol class="content-list"><li><strong>Vishwas R. Pawgi (2022)</strong> - "Statistical Computing using R Software"</li></ol>
<p class="paragraph">- Specifically designed for Indian university curriculum
   - Covers BCA/MCA syllabus requirements
   - Includes Indian context examples</p>
</section>

            <section class="content-section" id="additional-references">
                <h3 class="section-heading"><strong>Additional References:</strong></h3>
            
<ul class="content-list"><li>Norman Matloff (2011) - "The Art of R Programming"</li>
<li>Hadley Wickham (2014) - "Advanced R"</li>
<li>Venables & Smith - "An Introduction to R"</li></ul>
<hr class="content-hr">
</section>

            <section class="content-section" id="examination-preparation-tips">
                <h2 class="section-heading"><strong>Examination Preparation Tips</strong></h2>
            
</section>

            <section class="content-section" id="important-concepts-for-exams">
                <h3 class="section-heading"><strong>Important Concepts for Exams:</strong></h3>
            
<ol class="content-list"><li><strong>Difference between</strong>:</li></ol>
<p class="paragraph">- <code>[ ]</code> and <code>[[ ]]</code> for lists
   - <code><-</code> and <code>=</code>
   - <code>matrix()</code> and <code>data.frame()</code>
   - <code>NA</code>, <code>NULL</code>, <code>NaN</code></p>
<ol class="content-list"><li><strong>Must-know Functions</strong>:</li></ol>
<p class="paragraph">- <code>apply()</code>, <code>lapply()</code>, <code>sapply()</code>, <code>tapply()</code>
   - <code>subset()</code>, <code>merge()</code>, <code>aggregate()</code>
   - <code>str()</code>, <code>typeof()</code>, <code>class()</code></p>
<ol class="content-list"><li><strong>Common Errors & Solutions</strong>:</li></ol>
<p class="paragraph">- Recycling rule in vector operations
   - Factor vs character handling
   - Missing value handling
   - Dimension mismatch errors</p>
</section>

            <section class="content-section" id="practice-problems">
                <h3 class="section-heading"><strong>Practice Problems:</strong></h3>
            
<ol class="content-list"><li>Create a function to calculate compound interest</li>
<li>Read a CSV file, clean missing values, calculate summary statistics</li>
<li>Create a matrix and perform various operations</li>
<li>Write a loop to generate Fibonacci sequence</li>
<li>Create a plot with custom labels and colors</li></ol>
<hr class="content-hr">
</section>

            <section class="content-section" id="unit-2-statistics-and-probability">
                <h1 class="section-heading"><strong>Unit 2: Statistics and Probability</strong></h1>
            
</section>

            <section class="content-section" id="1-statistics-and-probability-overview">
                <h2 class="section-heading"><strong>1. Statistics and Probability - Overview</strong></h2>
            
<ul class="content-list"><li><strong>Meaning</strong>: Statistics is the science of collecting, analyzing, interpreting, and presenting data. Probability is the mathematical framework for quantifying uncertainty.</li>
<li><strong>Relationship</strong>: Probability provides theoretical foundation → Statistics applies it to real data</li>
<li><strong>Key Divisions</strong>:</li></ul>
<p class="paragraph">1. <strong>Descriptive Statistics</strong>: Summarizing data (measures of center, spread)
  2. <strong>Inferential Statistics</strong>: Drawing conclusions about populations from samples
  3. <strong>Probability Theory</strong>: Mathematical models of random phenomena</p>

            <div class="special-block reference">
                <div class="special-label">Reference: Davies (2016) Chapters 8-12; Pawgi (2022) Chapters 5-7</div>
                <div class="special-content"></div>
            </div>
            
<hr class="content-hr">
</section>

            <section class="content-section" id="2-basic-data-visualization">
                <h2 class="section-heading"><strong>2. Basic Data Visualization</strong></h2>
            
</section>

            <section class="content-section" id="types-of-statistical-plots">
                <h3 class="section-heading"><strong>Types of Statistical Plots</strong></h3>
            
</section>

            <section class="content-section" id="a-univariate-plots">
                <h4 class="section-heading"><strong>A. Univariate Plots</strong></h4>
            
<ol class="content-list"><li><strong>Histogram</strong>:</li></ol>

            <div class="code-block">
                <pre><code class="language-r">   # Syntax
   hist(x, breaks=&quot;Sturges&quot;, freq=TRUE/FALSE, 
        main=&quot;Title&quot;, xlab=&quot;X-label&quot;, ylab=&quot;Y-label&quot;,
        col=&quot;color&quot;, border=&quot;color&quot;)
   
   # Example
   data &lt;- rnorm(1000, mean=50, sd=10)
   hist(data, 
        main=&quot;Distribution of Scores&quot;,
        xlab=&quot;Scores&quot;,
        col=&quot;lightblue&quot;,
        border=&quot;darkblue&quot;,
        freq=FALSE)  # Shows density instead of frequency
   lines(density(data), col=&quot;red&quot;, lwd=2)  # Add density curve</code></pre>
            </div>
            
<ol class="content-list"><li><strong>Boxplot (Box-and-Whisker Plot)</strong>:</li></ol>

            <div class="code-block">
                <pre><code class="language-r">   # Syntax
   boxplot(x, range=1.5, notch=FALSE, 
           main=&quot;Title&quot;, ylab=&quot;Label&quot;)
   
   # Example
   scores &lt;- list(
     Group1 = rnorm(100, 70, 10),
     Group2 = rnorm(100, 80, 8),
     Group3 = rnorm(100, 65, 12)
   )
   
   boxplot(scores,
           main=&quot;Score Distribution by Group&quot;,
           ylab=&quot;Scores&quot;,
           col=c(&quot;lightblue&quot;, &quot;lightgreen&quot;, &quot;pink&quot;),
           notch=TRUE,  # Shows confidence interval for median
           las=1)       # Horizontal labels
   
   # Statistics from boxplot
   stats &lt;- boxplot(scores, plot=FALSE)
   stats$stats  # Matrix: min, Q1, median, Q3, max for each group
   stats$out    # Outliers</code></pre>
            </div>
            
<ol class="content-list"><li><strong>Q-Q Plot (Quantile-Quantile)</strong>:</li></ol>

            <div class="code-block">
                <pre><code class="language-r">   # For normality checking
   qqnorm(data, main=&quot;Q-Q Plot&quot;)
   qqline(data, col=&quot;red&quot;)  # Reference line
   
   # Shapiro-Wilk test for normality
   shapiro.test(data)</code></pre>
            </div>
            
</section>

            <section class="content-section" id="b-bivariate-plots">
                <h4 class="section-heading"><strong>B. Bivariate Plots</strong></h4>
            
<ol class="content-list"><li><strong>Scatter Plot</strong>:</li></ol>

            <div class="code-block">
                <pre><code class="language-r">   x &lt;- rnorm(100, mean=50, sd=10)
   y &lt;- 2*x + rnorm(100, mean=0, sd=20)  # Linear relationship with noise
   
   plot(x, y,
        main=&quot;Scatter Plot with Regression Line&quot;,
        xlab=&quot;X Variable&quot;,
        ylab=&quot;Y Variable&quot;,
        pch=19,        # Solid circles
        col=rgb(0,0,1,0.5),  # Semi-transparent blue
        cex=1.2)
   
   # Add regression line
   abline(lm(y ~ x), col=&quot;red&quot;, lwd=2)
   
   # Add correlation coefficient
   correlation &lt;- cor(x, y)
   text(min(x), max(y), 
        paste(&quot;r =&quot;, round(correlation, 3)),
        pos=4, col=&quot;darkred&quot;)</code></pre>
            </div>
            
<ol class="content-list"><li><strong>Pairs Plot (Scatterplot Matrix)</strong>:</li></ol>

            <div class="code-block">
                <pre><code class="language-r">   # Create data frame with multiple variables
   data &lt;- data.frame(
     Var1 = rnorm(100),
     Var2 = rnorm(100),
     Var3 = rnorm(100),
     Group = sample(c(&quot;A&quot;,&quot;B&quot;), 100, replace=TRUE)
   )
   
   # Basic pairs plot
   pairs(data[,1:3], 
         main=&quot;Scatterplot Matrix&quot;,
         pch=19,
         col=as.numeric(data$Group))  # Color by group
   
   # Enhanced with psych package
   # install.packages(&quot;psych&quot;)
   # library(psych)
   # pairs.panels(data[,1:3], 
   #              method=&quot;pearson&quot;,  # correlation method
   #              hist.col=&quot;lightblue&quot;,
   #              density=TRUE,      # show density curves
   #              ellipses=TRUE)     # show correlation ellipses</code></pre>
            </div>
            
</section>

            <section class="content-section" id="c-multivariate-plots">
                <h4 class="section-heading"><strong>C. Multivariate Plots</strong></h4>
            
<ol class="content-list"><li><strong>Heatmap</strong>:</li></ol>

            <div class="code-block">
                <pre><code class="language-r">   # Create correlation matrix
   cor_matrix &lt;- cor(mtcars)
   
   heatmap(cor_matrix,
           main=&quot;Correlation Heatmap&quot;,
           col=colorRampPalette(c(&quot;blue&quot;, &quot;white&quot;, &quot;red&quot;))(100),
           scale=&quot;none&quot;,
           margins=c(10,10),
           cexRow=0.8, cexCol=0.8)</code></pre>
            </div>
            
<ol class="content-list"><li><strong>3D Scatter Plot</strong>:</li></ol>

            <div class="code-block">
                <pre><code class="language-r">   # install.packages(&quot;scatterplot3d&quot;)
   library(scatterplot3d)
   
   scatterplot3d(mtcars$mpg, mtcars$hp, mtcars$wt,
                 main=&quot;3D Scatter Plot&quot;,
                 xlab=&quot;MPG&quot;,
                 ylab=&quot;Horsepower&quot;,
                 zlab=&quot;Weight&quot;,
                 pch=16,
                 color=&quot;blue&quot;,
                 angle=55)</code></pre>
            </div>
            
</section>

            <section class="content-section" id="d-specialized-statistical-plots">
                <h4 class="section-heading"><strong>D. Specialized Statistical Plots</strong></h4>
            
<ol class="content-list"><li><strong>ECDF Plot (Empirical Cumulative Distribution Function)</strong>:</li></ol>

            <div class="code-block">
                <pre><code class="language-r">   plot(ecdf(data),
        main=&quot;ECDF Plot&quot;,
        xlab=&quot;Values&quot;,
        ylab=&quot;Cumulative Probability&quot;,
        verticals=TRUE,
        col.01line=&quot;gray&quot;)
   grid()  # Add grid lines</code></pre>
            </div>
            
<ol class="content-list"><li><strong>Violin Plot</strong> (Combines boxplot and density plot):</li></ol>

            <div class="code-block">
                <pre><code class="language-r">   # install.packages(&quot;vioplot&quot;)
   library(vioplot)
   
   vioplot(Group1, Group2, Group3,
           names=c(&quot;Group 1&quot;, &quot;Group 2&quot;, &quot;Group 3&quot;),
           col=&quot;lightblue&quot;,
           main=&quot;Violin Plots&quot;)</code></pre>
            </div>
            

            <div class="special-block reference">
                <div class="special-label">Reference: Davies (2016) Chapter 9; Pawgi (2022) Chapter 5</div>
                <div class="special-content"></div>
            </div>
            
<hr class="content-hr">
</section>

            <section class="content-section" id="3-probability-fundamental-concepts">
                <h2 class="section-heading"><strong>3. Probability - Fundamental Concepts</strong></h2>
            
</section>

            <section class="content-section" id="a-basic-probability-rules">
                <h3 class="section-heading"><strong>A. Basic Probability Rules</strong></h3>
            
<ol class="content-list"><li><strong>Sample Space (S)</strong>: Set of all possible outcomes</li>
<li><strong>Event (E)</strong>: Subset of sample space</li>
<li><strong>Probability Axioms</strong>:</li></ol>
<p class="paragraph">- P(S) = 1
   - 0 ≤ P(E) ≤ 1
   - For mutually exclusive events: P(A ∪ B) = P(A) + P(B)</p>
</section>

            <section class="content-section" id="b-probability-calculations-in-r">
                <h3 class="section-heading"><strong>B. Probability Calculations in R</strong></h3>
            

            <div class="code-block">
                <pre><code class="language-r"># 1. Empirical Probability
# Example: Coin toss simulation
n_trials &lt;- 1000
coin_tosses &lt;- sample(c(&quot;H&quot;,&quot;T&quot;), n_trials, replace=TRUE)
heads_prob &lt;- sum(coin_tosses == &quot;H&quot;) / n_trials
tails_prob &lt;- sum(coin_tosses == &quot;T&quot;) / n_trials

# 2. Combinatorics
# Factorial
factorial(5)  # 120

# Combinations: nCr
choose(10, 3)  # 120 ways to choose 3 from 10

# Permutations: nPr
perm &lt;- function(n, r) {
  factorial(n) / factorial(n-r)
}
perm(10, 3)  # 720

# 3. Conditional Probability: P(A|B) = P(A∩B)/P(B)
# Example: Deck of cards
cards &lt;- rep(c(&quot;Hearts&quot;,&quot;Diamonds&quot;,&quot;Clubs&quot;,&quot;Spades&quot;), each=13)
values &lt;- rep(1:13, 4)

# Probability of drawing an Ace given it&#x27;s a Heart
total_cards &lt;- 52
hearts &lt;- sum(cards == &quot;Hearts&quot;)  # 13
ace_of_hearts &lt;- 1
p_ace_given_heart &lt;- ace_of_hearts / hearts  # 1/13

# 4. Bayes Theorem Implementation
bayes_theorem &lt;- function(p_a, p_b_given_a, p_b) {
  # P(A|B) = [P(B|A) * P(A)] / P(B)
  return((p_b_given_a * p_a) / p_b)
}

# Example: Medical test
p_disease &lt;- 0.01          # Prevalence
p_positive_given_disease &lt;- 0.99   # Sensitivity
p_positive_given_no_disease &lt;- 0.05 # False positive rate

# Total probability of positive test
p_positive &lt;- p_positive_given_disease * p_disease + 
              p_positive_given_no_disease * (1 - p_disease)

# Probability of disease given positive test
p_disease_given_positive &lt;- bayes_theorem(
  p_a = p_disease,
  p_b_given_a = p_positive_given_disease,
  p_b = p_positive
)  # Approximately 0.167</code></pre>
            </div>
            

            <div class="special-block reference">
                <div class="special-label">Reference: Davies (2016) Chapter 10; Pawgi (2022) Chapter 6</div>
                <div class="special-content"></div>
            </div>
            
<hr class="content-hr">
</section>

            <section class="content-section" id="4-common-probability-distributions">
                <h2 class="section-heading"><strong>4. Common Probability Distributions</strong></h2>
            
</section>

            <section class="content-section" id="classification-of-distributions">
                <h3 class="section-heading"><strong>Classification of Distributions</strong></h3>
            
<ol class="content-list"><li><strong>Discrete Distributions</strong>: PMF (Probability Mass Function)</li></ol>
<ol class="content-list"><li><strong>Continuous Distributions</strong>: PDF (Probability Density Function)</li></ol>
<ol class="content-list"><li><strong>Relationships Between Distributions</strong>:</li></ol>

            <div class="code-block">
                <pre><code class="language-text">   Bernoulli → Binomial (sum of independent Bernoullis)
   Binomial → Normal (when n is large, Central Limit Theorem)
   Poisson → Normal (when λ is large)</code></pre>
            </div>
            
<p class="paragraph">- Bernoulli, Binomial, Poisson, Geometric, Negative Binomial
   - Uniform, Normal, t, Chi-square, F, Exponential</p>
<hr class="content-hr">
</section>

            <section class="content-section" id="5-common-probability-mass-functions-discrete-distributions">
                <h2 class="section-heading"><strong>5. Common Probability Mass Functions (Discrete Distributions)</strong></h2>
            
</section>

            <section class="content-section" id="a-bernoulli-distribution">
                <h3 class="section-heading"><strong>A. Bernoulli Distribution</strong></h3>
            
<ul class="content-list"><li><strong>Definition</strong>: Single trial with two outcomes (success/failure)</li>
<li><strong>Parameter</strong>: p = probability of success</li>
<li><strong>PMF</strong>: P(X=x) = p^x * (1-p)^(1-x) for x ∈ {0,1}</li>
<li><strong>Mean</strong>: μ = p</li>
<li><strong>Variance</strong>: σ² = p(1-p)</li></ul>

            <div class="code-block">
                <pre><code class="language-r"># Bernoulli Functions in R
# Since Bernoulli is Binomial with n=1, use binomial functions

# 1. Generate random Bernoulli variables
n &lt;- 1000
p &lt;- 0.3
bernoulli_samples &lt;- rbinom(n, size=1, prob=p)

# 2. PMF: Probability of success
dbinom(1, size=1, prob=p)  # P(X=1) = 0.3
dbinom(0, size=1, prob=p)  # P(X=0) = 0.7

# 3. CDF: Cumulative distribution
pbinom(0, size=1, prob=p)  # P(X≤0) = 0.7
pbinom(1, size=1, prob=p)  # P(X≤1) = 1.0

# 4. Quantile function
qbinom(0.5, size=1, prob=p)  # Median (smallest x where P(X≤x) ≥ 0.5)

# 5. Visualizing Bernoulli Distribution
x &lt;- 0:1
prob &lt;- dbinom(x, size=1, prob=p)

barplot(prob,
        names.arg=c(&quot;Failure (0)&quot;, &quot;Success (1)&quot;),
        main=&quot;Bernoulli Distribution (p=0.3)&quot;,
        xlab=&quot;Outcome&quot;,
        ylab=&quot;Probability&quot;,
        col=c(&quot;red&quot;, &quot;green&quot;),
        ylim=c(0,1))
text(x=1:2, y=prob+0.05, labels=round(prob,3))</code></pre>
            </div>
            
</section>

            <section class="content-section" id="b-binomial-distribution">
                <h3 class="section-heading"><strong>B. Binomial Distribution</strong></h3>
            
<ul class="content-list"><li><strong>Definition</strong>: Number of successes in n independent Bernoulli trials</li>
<li><strong>Parameters</strong>: n = number of trials, p = probability of success</li>
<li><strong>PMF</strong>: P(X=k) = C(n,k) <em> p^k </em> (1-p)^(n-k)</li>
<li><strong>Mean</strong>: μ = np</li>
<li><strong>Variance</strong>: σ² = np(1-p)</li></ul>

            <div class="code-block">
                <pre><code class="language-r"># Binomial Distribution in R
n &lt;- 10      # Number of trials
p &lt;- 0.4     # Probability of success

# 1. Random generation
binom_samples &lt;- rbinom(1000, size=n, prob=p)

# 2. PMF: Probability of exactly k successes
k &lt;- 5
prob_exact &lt;- dbinom(k, size=n, prob=p)
# P(X=5) = C(10,5) * 0.4^5 * 0.6^5

# 3. CDF: Probability of at most k successes
prob_at_most &lt;- pbinom(k, size=n, prob=p)
# P(X≤5) = sum_{i=0}^{5} P(X=i)

# 4. Survival function: Probability of more than k successes
prob_more_than &lt;- 1 - pbinom(k, size=n, prob=p)
# or use lower.tail=FALSE
prob_more_than &lt;- pbinom(k, size=n, prob=p, lower.tail=FALSE)

# 5. Quantile function
qbinom(0.95, size=n, prob=p)  # 95th percentile

# 6. Comprehensive visualization
par(mfrow=c(2,2))  # 2x2 plot grid

# a. PMF plot
x &lt;- 0:n
pmf_values &lt;- dbinom(x, size=n, prob=p)
barplot(pmf_values,
        names.arg=x,
        main=paste(&quot;Binomial PMF (n=&quot;,n,&quot;, p=&quot;,p,&quot;)&quot;,sep=&quot;&quot;),
        xlab=&quot;Number of Successes&quot;,
        ylab=&quot;Probability&quot;,
        col=&quot;lightblue&quot;)

# b. CDF plot
cdf_values &lt;- pbinom(x, size=n, prob=p)
plot(x, cdf_values, type=&quot;s&quot;,
     main=&quot;Binomial CDF&quot;,
     xlab=&quot;Number of Successes&quot;,
     ylab=&quot;Cumulative Probability&quot;,
     pch=19, col=&quot;darkred&quot;)
grid()

# c. Random sample histogram
hist(binom_samples,
     breaks=seq(-0.5, n+0.5, by=1),
     main=&quot;Histogram of Binomial Samples&quot;,
     xlab=&quot;Number of Successes&quot;,
     col=&quot;lightgreen&quot;,
     freq=FALSE)
lines(density(binom_samples, adjust=2), col=&quot;blue&quot;, lwd=2)

# d. Q-Q plot for distribution checking
qqplot(rbinom(1000, size=n, prob=p), binom_samples,
       main=&quot;Q-Q Plot&quot;,
       xlab=&quot;Theoretical Quantiles&quot;,
       ylab=&quot;Sample Quantiles&quot;)
abline(0,1, col=&quot;red&quot;)

par(mfrow=c(1,1))  # Reset plot layout

# 7. Real-world example: Quality control
# Probability that in a batch of 20 items, at most 2 are defective
# if defect rate is 5%
p_defective &lt;- 0.05
batch_size &lt;- 20
prob_at_most_2_defective &lt;- pbinom(2, size=batch_size, prob=p_defective)

# 8. Binomial confidence interval
successes &lt;- 8
total &lt;- 20
binom.test(successes, total)$conf.int</code></pre>
            </div>
            
</section>

            <section class="content-section" id="c-poisson-distribution">
                <h3 class="section-heading"><strong>C. Poisson Distribution</strong></h3>
            
<ul class="content-list"><li><strong>Definition</strong>: Number of events occurring in fixed interval (time/space)</li>
<li><strong>Parameter</strong>: λ = average rate of occurrence</li>
<li><strong>PMF</strong>: P(X=k) = (λ^k * e^{-λ}) / k!</li>
<li><strong>Mean</strong>: μ = λ</li>
<li><strong>Variance</strong>: σ² = λ</li>
<li><strong>Conditions</strong>: Events are independent, occur at constant rate</li></ul>

            <div class="code-block">
                <pre><code class="language-r"># Poisson Distribution in R
lambda &lt;- 3.5  # Average rate

# 1. Random generation
poisson_samples &lt;- rpois(1000, lambda=lambda)

# 2. PMF: Probability of exactly k events
k &lt;- 5
prob_exact &lt;- dpois(k, lambda=lambda)

# 3. CDF: Probability of at most k events
prob_at_most &lt;- ppois(k, lambda=lambda)

# 4. Probability of more than k events
prob_more_than &lt;- ppois(k, lambda=lambda, lower.tail=FALSE)

# 5. Quantile function
qpois(0.95, lambda=lambda)

# 6. Visualization
x &lt;- 0:15  # Range to plot
pmf_values &lt;- dpois(x, lambda=lambda)

par(mfrow=c(1,2))

# PMF plot
plot(x, pmf_values, type=&quot;h&quot;,
     main=paste(&quot;Poisson PMF (λ=&quot;,lambda,&quot;)&quot;,sep=&quot;&quot;),
     xlab=&quot;Number of Events&quot;,
     ylab=&quot;Probability&quot;,
     lwd=3, col=&quot;blue&quot;)
points(x, pmf_values, pch=19, col=&quot;darkblue&quot;)
grid()

# CDF plot
cdf_values &lt;- ppois(x, lambda=lambda)
plot(x, cdf_values, type=&quot;s&quot;,
     main=&quot;Poisson CDF&quot;,
     xlab=&quot;Number of Events&quot;,
     ylab=&quot;Cumulative Probability&quot;,
     pch=19, col=&quot;darkred&quot;)
grid()

par(mfrow=c(1,1))

# 7. Real-world examples

# a. Call center: Calls per hour
calls_per_hour &lt;- 10
# Probability of exactly 15 calls in an hour
dpois(15, lambda=calls_per_hour)

# b. Website hits: Hits per minute
hits_per_minute &lt;- 30
# Probability of more than 40 hits in a minute
ppois(40, lambda=hits_per_minute, lower.tail=FALSE)

# c. Relationship with Binomial
# Poisson approximates Binomial when n is large, p is small
n &lt;- 1000
p &lt;- 0.003
lambda_approx &lt;- n * p  # = 3

# Compare probabilities
x_compare &lt;- 0:10
binom_probs &lt;- dbinom(x_compare, size=n, prob=p)
poisson_probs &lt;- dpois(x_compare, lambda=lambda_approx)

comparison &lt;- data.frame(
  x = x_compare,
  Binomial = round(binom_probs, 6),
  Poisson = round(poisson_probs, 6),
  Difference = round(abs(binom_probs - poisson_probs), 6)
)

# 8. Poisson process simulation
# Simulate arrival times
simulate_poisson_process &lt;- function(lambda, T_max) {
  # Generate inter-arrival times (exponential)
  inter_arrival &lt;- rexp(1000, rate=lambda)
  arrival_times &lt;- cumsum(inter_arrival)
  # Keep only arrivals within T_max
  arrival_times &lt;- arrival_times[arrival_times &lt;= T_max]
  return(arrival_times)
}

arrivals &lt;- simulate_poisson_process(lambda=2, T_max=10)
number_of_arrivals &lt;- length(arrivals)</code></pre>
            </div>
            

            <div class="special-block reference">
                <div class="special-label">Reference: Davies (2016) Chapter 11; Pawgi (2022) Chapter 6</div>
                <div class="special-content"></div>
            </div>
            
<hr class="content-hr">
</section>

            <section class="content-section" id="6-common-probability-density-functions-continuous-distributions">
                <h2 class="section-heading"><strong>6. Common Probability Density Functions (Continuous Distributions)</strong></h2>
            
</section>

            <section class="content-section" id="a-uniform-distribution">
                <h3 class="section-heading"><strong>A. Uniform Distribution</strong></h3>
            
<ul class="content-list"><li><strong>Definition</strong>: All outcomes equally likely over interval [a,b]</li>
<li><strong>Parameters</strong>: a = minimum, b = maximum</li>
<li><strong>PDF</strong>: f(x) = 1/(b-a) for a ≤ x ≤ b, 0 otherwise</li>
<li><strong>Mean</strong>: μ = (a+b)/2</li>
<li><strong>Variance</strong>: σ² = (b-a)²/12</li></ul>

            <div class="code-block">
                <pre><code class="language-r"># Uniform Distribution in R
a &lt;- 2   # Minimum
b &lt;- 8   # Maximum

# 1. Random generation
uniform_samples &lt;- runif(1000, min=a, max=b)

# 2. PDF: Density at point x
x &lt;- 5
density_at_x &lt;- dunif(x, min=a, max=b)

# 3. CDF: Probability X ≤ x
prob_less_than &lt;- punif(x, min=a, max=b)

# 4. Quantile function
qunif(0.75, min=a, max=b)  # 75th percentile

# 5. Visualization
par(mfrow=c(2,2))

# PDF plot
curve(dunif(x, min=a, max=b),
      from=a-1, to=b+1,
      main=paste(&quot;Uniform PDF [&quot;,a,&quot;,&quot;,b,&quot;]&quot;,sep=&quot;&quot;),
      xlab=&quot;x&quot;,
      ylab=&quot;Density&quot;,
      lwd=2, col=&quot;blue&quot;)
abline(v=c(a,b), lty=2, col=&quot;gray&quot;)
polygon(c(a, seq(a,b,0.01), b), 
        c(0, dunif(seq(a,b,0.01), min=a, max=b), 0),
        col=&quot;lightblue&quot;, border=NA)

# CDF plot
curve(punif(x, min=a, max=b),
      from=a-1, to=b+1,
      main=&quot;Uniform CDF&quot;,
      xlab=&quot;x&quot;,
      ylab=&quot;Cumulative Probability&quot;,
      lwd=2, col=&quot;darkred&quot;)

# Histogram of samples
hist(uniform_samples,
     main=&quot;Histogram of Uniform Samples&quot;,
     xlab=&quot;Value&quot;,
     col=&quot;lightgreen&quot;,
     freq=FALSE,  # Show density
     breaks=20)
curve(dunif(x, min=a, max=b), add=TRUE, col=&quot;blue&quot;, lwd=2)

# Q-Q plot
qqplot(runif(1000, min=a, max=b), uniform_samples,
       main=&quot;Q-Q Plot&quot;,
       xlab=&quot;Theoretical Quantiles&quot;,
       ylab=&quot;Sample Quantiles&quot;)
abline(0,1, col=&quot;red&quot;)

par(mfrow=c(1,1))

# 6. Applications

# a. Random number generation for simulations
set.seed(123)  # For reproducibility
random_numbers &lt;- runif(100, min=0, max=1)

# b. Probability of being in interval
# P(3 ≤ X ≤ 5) for X ~ Uniform(2,8)
punif(5, min=a, max=b) - punif(3, min=a, max=b)

# c. Inverse transform sampling
# Generate samples from any distribution using uniform
inverse_transform &lt;- function(n, inverse_cdf) {
  u &lt;- runif(n)  # Uniform samples
  return(inverse_cdf(u))
}

# Example: Generate exponential samples
inverse_exp &lt;- function(u, rate=1) {
  return(-log(1-u)/rate)
}

exp_samples &lt;- inverse_transform(1000, function(u) inverse_exp(u, rate=0.5))</code></pre>
            </div>
            
</section>

            <section class="content-section" id="b-normal-gaussian-distribution">
                <h3 class="section-heading"><strong>B. Normal (Gaussian) Distribution</strong></h3>
            
<ul class="content-list"><li><strong>Definition</strong>: Bell-shaped symmetric distribution</li>
<li><strong>Parameters</strong>: μ = mean, σ = standard deviation</li>
<li><strong>PDF</strong>: f(x) = (1/(σ√(2π))) * exp(-(x-μ)²/(2σ²))</li>
<li><strong>Properties</strong>:</li></ul>
<p class="paragraph">- Symmetric about mean
  - Mean = Median = Mode
  - 68-95-99.7 rule: Within 1,2,3 σ of μ</p>

            <div class="code-block">
                <pre><code class="language-r"># Normal Distribution in R
mu &lt;- 0      # Mean
sigma &lt;- 1   # Standard deviation

# 1. Random generation
normal_samples &lt;- rnorm(1000, mean=mu, sd=sigma)

# 2. PDF: Density at point x
x &lt;- 1.5
density_at_x &lt;- dnorm(x, mean=mu, sd=sigma)

# 3. CDF: Probability X ≤ x
prob_less_than &lt;- pnorm(x, mean=mu, sd=sigma)

# 4. Quantile function (Z-score for given probability)
z_score &lt;- qnorm(0.95, mean=mu, sd=sigma)  # 1.644854

# 5. Comprehensive visualization
par(mfrow=c(2,2))

# PDF with different sigmas
curve(dnorm(x, mean=0, sd=1),
      from=-4, to=4,
      main=&quot;Normal PDFs with Different Variances&quot;,
      xlab=&quot;x&quot;,
      ylab=&quot;Density&quot;,
      lwd=2, col=&quot;black&quot;, ylim=c(0,0.8))
curve(dnorm(x, mean=0, sd=0.5), add=TRUE, col=&quot;red&quot;, lwd=2)
curve(dnorm(x, mean=0, sd=2), add=TRUE, col=&quot;blue&quot;, lwd=2)
legend(&quot;topright&quot;,
       legend=c(&quot;σ=1&quot;, &quot;σ=0.5&quot;, &quot;σ=2&quot;),
       col=c(&quot;black&quot;,&quot;red&quot;,&quot;blue&quot;),
       lwd=2)

# CDF plot
curve(pnorm(x, mean=mu, sd=sigma),
      from=-4, to=4,
      main=&quot;Normal CDF&quot;,
      xlab=&quot;x&quot;,
      ylab=&quot;Cumulative Probability&quot;,
      lwd=2, col=&quot;darkred&quot;)
grid()

# Area under curve visualization
x_seq &lt;- seq(-4, 4, length=1000)
pdf_values &lt;- dnorm(x_seq, mean=mu, sd=sigma)
plot(x_seq, pdf_values, type=&quot;l&quot;,
     main=&quot;Probability Intervals&quot;,
     xlab=&quot;x&quot;,
     ylab=&quot;Density&quot;,
     lwd=2, col=&quot;blue&quot;)

# Shade areas for different standard deviations
# 1σ interval
x_1sigma &lt;- seq(-1, 1, length=100)
polygon(c(-1, x_1sigma, 1),
        c(0, dnorm(x_1sigma), 0),
        col=rgb(0,0,1,0.3), border=NA)

# 2σ interval
x_2sigma &lt;- seq(-2, 2, length=100)
polygon(c(-2, x_2sigma, 2),
        c(0, dnorm(x_2sigma), 0),
        col=rgb(0,1,0,0.3), border=NA)

legend(&quot;topright&quot;,
       legend=c(&quot;Within 1σ (68%)&quot;, &quot;Within 2σ (95%)&quot;),
       fill=c(rgb(0,0,1,0.3), rgb(0,1,0,0.3)))

# Q-Q plot for normality check
qqnorm(normal_samples, main=&quot;Normal Q-Q Plot&quot;)
qqline(normal_samples, col=&quot;red&quot;)

par(mfrow=c(1,1))

# 6. Standard Normal Distribution (Z-distribution)
# Z = (X - μ)/σ
standardize &lt;- function(x, mu, sigma) {
  return((x - mu)/sigma)
}

# 7. Probability calculations

# a. Between two values: P(a &lt; X &lt; b)
a &lt;- -1
b &lt;- 1
prob_between &lt;- pnorm(b, mean=mu, sd=sigma) - pnorm(a, mean=mu, sd=sigma)

# b. Right tail: P(X &gt; c)
c &lt;- 1.96
prob_right_tail &lt;- pnorm(c, mean=mu, sd=sigma, lower.tail=FALSE)

# c. Critical values for confidence intervals
confidence_level &lt;- 0.95
alpha &lt;- 1 - confidence_level
z_critical &lt;- qnorm(1 - alpha/2)  # Two-tailed

# 8. Central Limit Theorem Demonstration
clt_demo &lt;- function(pop_dist, n_samples=1000, sample_size=30) {
  # Generate sampling distribution of means
  sample_means &lt;- replicate(n_samples, {
    sample &lt;- pop_dist(sample_size)
    mean(sample)
  })
  
  # Plot
  par(mfrow=c(1,2))
  
  # Histogram of sample means
  hist(sample_means,
       main=paste(&quot;Sampling Distribution (n=&quot;,sample_size,&quot;)&quot;,sep=&quot;&quot;),
       xlab=&quot;Sample Mean&quot;,
       col=&quot;lightblue&quot;,
       freq=FALSE,
       breaks=30)
  
  # Add normal curve
  x_fit &lt;- seq(min(sample_means), max(sample_means), length=100)
  lines(x_fit, dnorm(x_fit, mean=mean(sample_means), sd=sd(sample_means)),
        col=&quot;red&quot;, lwd=2)
  
  # Q-Q plot
  qqnorm(sample_means, main=&quot;Q-Q Plot of Sample Means&quot;)
  qqline(sample_means, col=&quot;blue&quot;)
  
  par(mfrow=c(1,1))
  
  # Shapiro-Wilk test
  shapiro_test &lt;- shapiro.test(sample_means)
  return(list(
    mean_of_means = mean(sample_means),
    sd_of_means = sd(sample_means),
    shapiro_p = shapiro_test$p.value
  ))
}

# Example with uniform population
clt_uniform &lt;- clt_demo(function(n) runif(n, 0, 1))

# Example with exponential population
clt_exp &lt;- clt_demo(function(n) rexp(n, rate=1))</code></pre>
            </div>
            
</section>

            <section class="content-section" id="c-students-t-distribution">
                <h3 class="section-heading"><strong>C. Student's t-Distribution</strong></h3>
            
<ul class="content-list"><li><strong>Definition</strong>: Distribution of sample mean when population variance is unknown</li>
<li><strong>Parameter</strong>: ν = degrees of freedom (df = n-1 for sample size n)</li>
<li><strong>Properties</strong>:</li></ul>
<ul class="content-list"><li><strong>PDF</strong>: f(t) = Γ((ν+1)/2) / [√(νπ) <em> Γ(ν/2)] </em> (1 + t²/ν)^{-(ν+1)/2}</li></ul>
<p class="paragraph">- Similar to normal but heavier tails
  - Approaches normal as df → ∞ (typically >30)
  - Used for small sample inference</p>

            <div class="code-block">
                <pre><code class="language-r"># t-Distribution in R
df &lt;- 10  # Degrees of freedom

# 1. Random generation
t_samples &lt;- rt(1000, df=df)

# 2. PDF: Density at point t
t_value &lt;- 2.0
density_at_t &lt;- dt(t_value, df=df)

# 3. CDF: Probability T ≤ t
prob_less_than &lt;- pt(t_value, df=df)

# 4. Quantile function (critical t-values)
t_critical &lt;- qt(0.975, df=df)  # Two-tailed 95% CI

# 5. Comparison with Normal
par(mfrow=c(2,2))

# PDF comparison
x_seq &lt;- seq(-4, 4, length=1000)
plot(x_seq, dnorm(x_seq), type=&quot;l&quot;,
     main=&quot;t vs Normal Distribution&quot;,
     xlab=&quot;x&quot;,
     ylab=&quot;Density&quot;,
     lwd=2, col=&quot;black&quot;, ylim=c(0,0.4))
lines(x_seq, dt(x_seq, df=1), col=&quot;red&quot;, lwd=2)    # t with df=1 (Cauchy)
lines(x_seq, dt(x_seq, df=5), col=&quot;blue&quot;, lwd=2)   # t with df=5
lines(x_seq, dt(x_seq, df=30), col=&quot;green&quot;, lwd=2) # t with df=30
legend(&quot;topright&quot;,
       legend=c(&quot;Normal&quot;, &quot;t(df=1)&quot;, &quot;t(df=5)&quot;, &quot;t(df=30)&quot;),
       col=c(&quot;black&quot;,&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;),
       lwd=2)

# Tail comparison
upper_tail &lt;- seq(2, 4, length=100)
plot(upper_tail, 1 - pnorm(upper_tail), type=&quot;l&quot;,
     main=&quot;Tail Probabilities&quot;,
     xlab=&quot;x&quot;,
     ylab=&quot;P(X &gt; x)&quot;,
     lwd=2, col=&quot;black&quot;, log=&quot;y&quot;)
lines(upper_tail, 1 - pt(upper_tail, df=5), col=&quot;blue&quot;, lwd=2)
lines(upper_tail, 1 - pt(upper_tail, df=10), col=&quot;green&quot;, lwd=2)
legend(&quot;topright&quot;,
       legend=c(&quot;Normal&quot;, &quot;t(df=5)&quot;, &quot;t(df=10)&quot;),
       col=c(&quot;black&quot;,&quot;blue&quot;,&quot;green&quot;),
       lwd=2)

# Critical values comparison
df_range &lt;- 1:100
critical_values &lt;- sapply(df_range, function(df) qt(0.975, df=df))
plot(df_range, critical_values,
     main=&quot;Critical t-values vs df&quot;,
     xlab=&quot;Degrees of Freedom&quot;,
     ylab=&quot;t-critical (95%)&quot;,
     type=&quot;l&quot;, lwd=2, col=&quot;darkred&quot;)
abline(h=qnorm(0.975), lty=2, col=&quot;blue&quot;)
legend(&quot;topright&quot;,
       legend=c(&quot;t-critical&quot;, &quot;Z-critical (1.96)&quot;),
       col=c(&quot;darkred&quot;,&quot;blue&quot;),
       lty=c(1,2), lwd=2)

# Q-Q plot comparison
qqplot(rt(1000, df=df), rnorm(1000),
       main=&quot;Q-Q: t(10) vs Normal&quot;,
       xlab=&quot;t(10) Quantiles&quot;,
       ylab=&quot;Normal Quantiles&quot;)
abline(0,1, col=&quot;red&quot;)

par(mfrow=c(1,1))

# 6. Applications in Statistics

# a. Confidence interval for mean (σ unknown)
sample_data &lt;- rnorm(20, mean=50, sd=10)  # Small sample
n &lt;- length(sample_data)
sample_mean &lt;- mean(sample_data)
sample_sd &lt;- sd(sample_data)
df_ci &lt;- n - 1

# 95% Confidence Interval
t_critical_ci &lt;- qt(0.975, df=df_ci)
ci_lower &lt;- sample_mean - t_critical_ci * (sample_sd/sqrt(n))
ci_upper &lt;- sample_mean + t_critical_ci * (sample_sd/sqrt(n))

# Built-in function
t.test(sample_data)$conf.int

# b. t-test for single sample
# H0: μ = 55
t_stat &lt;- (sample_mean - 55) / (sample_sd/sqrt(n))
p_value &lt;- 2 * pt(-abs(t_stat), df=df_ci)

# Using built-in function
t.test(sample_data, mu=55)

# c. Power of t-test
power.t.test(n=20, delta=5, sd=10, sig.level=0.05, type=&quot;one.sample&quot;)

# 7. Relationship with other distributions
# t² ~ F(1, df)  # Square of t with df is F with (1, df) df
# t(df → ∞) → Normal

# 8. Non-central t-distribution (for power calculations)
# Non-centrality parameter δ
ncp &lt;- 2  # Effect size
t_nc_samples &lt;- rt(1000, df=df, ncp=ncp)

# PDF of non-central t
curve(dt(x, df=df, ncp=2), from=-5, to=10,
      main=&quot;Non-central t-distribution&quot;,
      xlab=&quot;t&quot;,
      ylab=&quot;Density&quot;,
      lwd=2, col=&quot;purple&quot;)
curve(dt(x, df=df), add=TRUE, col=&quot;blue&quot;, lwd=2, lty=2)
legend(&quot;topright&quot;,
       legend=c(&quot;Non-central t (δ=2)&quot;, &quot;Central t&quot;),
       col=c(&quot;purple&quot;,&quot;blue&quot;),
       lwd=2, lty=c(1,2))</code></pre>
            </div>
            

            <div class="special-block reference">
                <div class="special-label">Reference: Davies (2016) Chapter 12; Pawgi (2022) Chapter 7</div>
                <div class="special-content"></div>
            </div>
            
<hr class="content-hr">
</section>

            <section class="content-section" id="7-distribution-relationships-and-transformations">
                <h2 class="section-heading"><strong>7. Distribution Relationships and Transformations</strong></h2>
            
</section>

            <section class="content-section" id="a-distribution-family-relationships">
                <h3 class="section-heading"><strong>A. Distribution Family Relationships</strong></h3>
            

            <div class="code-block">
                <pre><code class="language-r"># 1. Binomial → Normal approximation
binomial_to_normal &lt;- function(n, p) {
  # Conditions: np &gt; 5 and n(1-p) &gt; 5
  mu &lt;- n * p
  sigma &lt;- sqrt(n * p * (1-p))
  
  # Continuity correction
  k &lt;- 0:n
  binom_probs &lt;- dbinom(k, size=n, prob=p)
  normal_probs &lt;- pnorm(k+0.5, mean=mu, sd=sigma) - 
                  pnorm(k-0.5, mean=mu, sd=sigma)
  
  # Comparison plot
  plot(k, binom_probs, type=&quot;h&quot;, lwd=2, col=&quot;blue&quot;,
       main=paste(&quot;Binomial(n=&quot;,n,&quot;,p=&quot;,p,&quot;) vs Normal&quot;,sep=&quot;&quot;),
       xlab=&quot;k&quot;, ylab=&quot;Probability&quot;)
  points(k, normal_probs, type=&quot;l&quot;, col=&quot;red&quot;, lwd=2)
  legend(&quot;topright&quot;, legend=c(&quot;Binomial&quot;,&quot;Normal&quot;),
         col=c(&quot;blue&quot;,&quot;red&quot;), lwd=2)
}

binomial_to_normal(50, 0.3)

# 2. Poisson → Normal approximation
poisson_to_normal &lt;- function(lambda) {
  # Condition: λ &gt; 10
  mu &lt;- lambda
  sigma &lt;- sqrt(lambda)
  
  k &lt;- 0:(2*lambda)
  poisson_probs &lt;- dpois(k, lambda=lambda)
  normal_probs &lt;- pnorm(k+0.5, mean=mu, sd=sigma) - 
                  pnorm(k-0.5, mean=mu, sd=sigma)
  
  plot(k, poisson_probs, type=&quot;h&quot;, lwd=1, col=&quot;blue&quot;,
       main=paste(&quot;Poisson(λ=&quot;,lambda,&quot;) vs Normal&quot;,sep=&quot;&quot;),
       xlab=&quot;k&quot;, ylab=&quot;Probability&quot;)
  points(k, normal_probs, type=&quot;l&quot;, col=&quot;red&quot;, lwd=2)
  legend(&quot;topright&quot;, legend=c(&quot;Poisson&quot;,&quot;Normal&quot;),
         col=c(&quot;blue&quot;,&quot;red&quot;), lwd=2)
}

poisson_to_normal(15)</code></pre>
            </div>
            
</section>

            <section class="content-section" id="b-distribution-fitting-and-goodness-of-fit">
                <h3 class="section-heading"><strong>B. Distribution Fitting and Goodness-of-Fit</strong></h3>
            

            <div class="code-block">
                <pre><code class="language-r"># Fit distribution to data
data &lt;- rgamma(100, shape=2, rate=0.5)

# 1. Visual inspection
par(mfrow=c(1,2))
hist(data, freq=FALSE, main=&quot;Histogram with Fitted Distributions&quot;,
     col=&quot;lightgray&quot;, breaks=20)

# Try different distributions
curve(dgamma(x, shape=2, rate=0.5), add=TRUE, col=&quot;blue&quot;, lwd=2)
curve(dnorm(x, mean=mean(data), sd=sd(data)), add=TRUE, col=&quot;red&quot;, lwd=2, lty=2)
legend(&quot;topright&quot;, legend=c(&quot;Gamma&quot;,&quot;Normal&quot;),
       col=c(&quot;blue&quot;,&quot;red&quot;), lwd=2, lty=c(1,2))

# Q-Q plot
qqplot(qgamma(ppoints(100), shape=2, rate=0.5), data,
       main=&quot;Gamma Q-Q Plot&quot;,
       xlab=&quot;Theoretical Quantiles&quot;,
       ylab=&quot;Sample Quantiles&quot;)
abline(0,1, col=&quot;red&quot;)
par(mfrow=c(1,1))

# 2. Kolmogorov-Smirnov test
ks.test(data, &quot;pgamma&quot;, shape=2, rate=0.5)

# 3. Estimate parameters using MLE
library(MASS)
fit_gamma &lt;- fitdistr(data, &quot;gamma&quot;)
fit_gamma$estimate</code></pre>
            </div>
            
<hr class="content-hr">
</section>

            <section class="content-section" id="8-practical-applications-and-problem-solving">
                <h2 class="section-heading"><strong>8. Practical Applications and Problem Solving</strong></h2>
            
</section>

            <section class="content-section" id="a-statistical-problem-template">
                <h3 class="section-heading"><strong>A. Statistical Problem Template</strong></h3>
            

            <div class="code-block">
                <pre><code class="language-r">solve_statistical_problem &lt;- function() {
  # Problem: A factory produces light bulbs with lifetime following
  # exponential distribution with mean 1000 hours.
  # 1. Probability that a bulb lasts more than 1200 hours
  # 2. Probability that at least 2 of 10 bulbs last more than 1200 hours
  
  lambda &lt;- 1/1000  # Rate parameter
  
  # Solution 1: Individual bulb probability
  prob_single &lt;- pexp(1200, rate=lambda, lower.tail=FALSE)
  
  # Solution 2: Binomial problem
  n_bulbs &lt;- 10
  prob_at_least_2 &lt;- 1 - pbinom(1, size=n_bulbs, prob=prob_single)
  
  # Visualization
  par(mfrow=c(1,2))
  
  # Exponential distribution
  curve(dexp(x, rate=lambda), from=0, to=3000,
        main=&quot;Exponential Distribution (μ=1000)&quot;,
        xlab=&quot;Lifetime (hours)&quot;,
        ylab=&quot;Density&quot;,
        lwd=2, col=&quot;blue&quot;)
  polygon(c(1200, seq(1200,3000,10), 3000),
          c(0, dexp(seq(1200,3000,10), rate=lambda), 0),
          col=rgb(0,0,1,0.3), border=NA)
  text(1500, dexp(1200, rate=lambda)/2,
       paste(&quot;P(X&gt;1200) =&quot;, round(prob_single,3)),
       col=&quot;darkred&quot;)
  
  # Binomial distribution
  x_binom &lt;- 0:n_bulbs
  probs_binom &lt;- dbinom(x_binom, size=n_bulbs, prob=prob_single)
  barplot(probs_binom, names.arg=x_binom,
          main=&quot;Binomial: Bulbs lasting &gt;1200h&quot;,
          xlab=&quot;Number of bulbs&quot;,
          ylab=&quot;Probability&quot;,
          col=c(rep(&quot;gray&quot;,2), rep(&quot;lightblue&quot;,9)))
  text(1.5, max(probs_binom)*0.9,
       paste(&quot;P(X≥2) =&quot;, round(prob_at_least_2,3)),
       col=&quot;darkred&quot;, pos=4)
  
  par(mfrow=c(1,1))
  
  return(list(
    single_probability = prob_single,
    binomial_probability = prob_at_least_2
  ))
}

solution &lt;- solve_statistical_problem()</code></pre>
            </div>
            
</section>

            <section class="content-section" id="b-complete-statistical-analysis-example">
                <h3 class="section-heading"><strong>B. Complete Statistical Analysis Example</strong></h3>
            

            <div class="code-block">
                <pre><code class="language-r"># Comprehensive example: Exam score analysis
set.seed(123)
exam_scores &lt;- rnorm(200, mean=65, sd=12)  # Generate scores

# 1. Descriptive statistics
desc_stats &lt;- function(x) {
  list(
    n = length(x),
    mean = mean(x),
    median = median(x),
    sd = sd(x),
    variance = var(x),
    min = min(x),
    max = max(x),
    Q1 = quantile(x, 0.25),
    Q3 = quantile(x, 0.75),
    IQR = IQR(x),
    skewness = moments::skewness(x),
    kurtosis = moments::kurtosis(x)
  )
}

stats &lt;- desc_stats(exam_scores)

# 2. Distribution fitting
# Test for normality
shapiro.test(exam_scores)
ks.test(exam_scores, &quot;pnorm&quot;, mean=65, sd=12)

# 3. Probability calculations
# a. Probability of scoring &gt; 80
prob_gt_80 &lt;- pnorm(80, mean=65, sd=12, lower.tail=FALSE)

# b. Score needed to be in top 10%
top_10_cutoff &lt;- qnorm(0.90, mean=65, sd=12)

# c. Probability between 50 and 70
prob_50_70 &lt;- pnorm(70, mean=65, sd=12) - pnorm(50, mean=65, sd=12)

# 4. Visualization
par(mfrow=c(2,2))

# Histogram with normal curve
hist(exam_scores, freq=FALSE, breaks=20,
     main=&quot;Exam Score Distribution&quot;,
     xlab=&quot;Score&quot;, col=&quot;lightblue&quot;, border=&quot;white&quot;)
curve(dnorm(x, mean=65, sd=12), add=TRUE, col=&quot;red&quot;, lwd=2)

# Boxplot with outliers
boxplot(exam_scores, main=&quot;Boxplot of Scores&quot;,
        ylab=&quot;Score&quot;, col=&quot;lightgreen&quot;)
points(1, mean(exam_scores), pch=19, col=&quot;red&quot;)  # Add mean point

# Q-Q plot
qqnorm(exam_scores, main=&quot;Normal Q-Q Plot&quot;)
qqline(exam_scores, col=&quot;blue&quot;)

# ECDF plot
plot(ecdf(exam_scores), main=&quot;ECDF of Scores&quot;,
     xlab=&quot;Score&quot;, ylab=&quot;Cumulative Probability&quot;,
     verticals=TRUE, col.01line=&quot;gray&quot;)
curve(pnorm(x, mean=65, sd=12), add=TRUE, col=&quot;red&quot;, lwd=2)
legend(&quot;topleft&quot;, legend=c(&quot;Empirical&quot;,&quot;Theoretical&quot;),
       col=c(&quot;black&quot;,&quot;red&quot;), lwd=2)

par(mfrow=c(1,1))

# 5. Confidence interval for mean
# Using t-distribution (σ unknown)
n &lt;- length(exam_scores)
t_critical &lt;- qt(0.975, df=n-1)
ci_mean &lt;- mean(exam_scores) + c(-1,1) * t_critical * sd(exam_scores)/sqrt(n)

# 6. Return comprehensive results
results &lt;- list(
  descriptive_statistics = stats,
  normality_tests = list(
    shapiro_p = shapiro.test(exam_scores)$p.value,
    ks_p = ks.test(exam_scores, &quot;pnorm&quot;, mean=65, sd=12)$p.value
  ),
  probabilities = list(
    p_gt_80 = prob_gt_80,
    top_10_cutoff = top_10_cutoff,
    p_50_70 = prob_50_70
  ),
  confidence_interval = ci_mean
)</code></pre>
            </div>
            
<hr class="content-hr">
</section>

            <section class="content-section" id="9-formulas-and-reference-tables">
                <h2 class="section-heading"><strong>9. Formulas and Reference Tables</strong></h2>
            
</section>

            <section class="content-section" id="probability-distributions-summary-table">
                <h3 class="section-heading"><strong>Probability Distributions Summary Table</strong></h3>
            
<p class="paragraph">| Distribution | Type | Parameters | PMF/PDF | Mean | Variance | R Functions |
|-------------|------|------------|---------|------|----------|-------------|
| <strong>Bernoulli</strong> | Discrete | p | p^x(1-p)^{1-x} | p | p(1-p) | <code>rbinom(n,1,p)</code>, <code>dbinom(x,1,p)</code> |
| <strong>Binomial</strong> | Discrete | n, p | C(n,k)p^k(1-p)^{n-k} | np | np(1-p) | <code>rbinom(n,n,p)</code>, <code>dbinom(k,n,p)</code> |
| <strong>Poisson</strong> | Discrete | λ | (λ^k e^{-λ})/k! | λ | λ | <code>rpois(n,λ)</code>, <code>dpois(k,λ)</code> |
| <strong>Uniform</strong> | Continuous | a, b | 1/(b-a) | (a+b)/2 | (b-a)²/12 | <code>runif(n,a,b)</code>, <code>dunif(x,a,b)</code> |
| <strong>Normal</strong> | Continuous | μ, σ | see above | μ | σ² | <code>rnorm(n,μ,σ)</code>, <code>dnorm(x,μ,σ)</code> |
| <strong>t</strong> | Continuous | ν | see above | 0 (ν>1) | ν/(ν-2) (ν>2) | <code>rt(n,ν)</code>, <code>dt(t,ν)</code> |</p>
</section>

            <section class="content-section" id="important-probability-rules">
                <h3 class="section-heading"><strong>Important Probability Rules</strong></h3>
            
<ol class="content-list"><li><strong>Addition Rule</strong>: P(A∪B) = P(A) + P(B) - P(A∩B)</li>
<li><strong>Multiplication Rule</strong>: P(A∩B) = P(A) × P(B|A)</li>
<li><strong>Bayes Theorem</strong>: P(A|B) = [P(B|A)×P(A)] / P(B)</li>
<li><strong>Law of Total Probability</strong>: P(B) = Σ P(B|Aᵢ)P(Aᵢ)</li></ol>
</section>

            <section class="content-section" id="common-statistical-tests">
                <h3 class="section-heading"><strong>Common Statistical Tests</strong></h3>
            

            <div class="code-block">
                <pre><code class="language-r"># 1. Normality tests
shapiro.test(data)        # Shapiro-Wilk (n &lt; 5000)
ks.test(data, &quot;pnorm&quot;)    # Kolmogorov-Smirnov

# 2. Distribution comparison
ks.test(data1, data2)     # Two-sample KS test

# 3. Parameter estimation
# Method of moments
# Maximum likelihood (use optim() or mle() from stats4)</code></pre>
            </div>
            
<hr class="content-hr">
</section>

            <section class="content-section" id="10-examination-focused-content">
                <h2 class="section-heading"><strong>10. Examination-Focused Content</strong></h2>
            
</section>

            <section class="content-section" id="important-concepts-for-exams">
                <h3 class="section-heading"><strong>Important Concepts for Exams</strong></h3>
            
<ol class="content-list"><li><strong>Distribution Properties</strong>:</li></ol>
<p class="paragraph">- When to use each distribution
   - Conditions for approximations
   - Parameter interpretation</p>
<ol class="content-list"><li><strong>R Functions Mastery</strong>:</li></ol>
<p class="paragraph">- <strong>d</strong>*: Density/PMF
   - <strong>p</strong>*: CDF
   - <strong>q</strong>*: Quantile function
   - <strong>r</strong>*: Random generation</p>
<ol class="content-list"><li><strong>Problem-Solving Framework</strong>:</li></ol>

            <div class="code-block">
                <pre><code class="language-r">   # Step 1: Identify distribution type
   # Step 2: Determine parameters
   # Step 3: Choose appropriate R function
   # Step 4: Calculate probability/statistic
   # Step 5: Interpret results</code></pre>
            </div>
            
</section>

            <section class="content-section" id="common-exam-questions">
                <h3 class="section-heading"><strong>Common Exam Questions</strong></h3>
            
<ol class="content-list"><li><strong>Theoretical</strong>:</li></ol>
<p class="paragraph">- Derive mean/variance of distributions
   - Prove relationships between distributions
   - Explain Central Limit Theorem</p>
<ol class="content-list"><li><strong>Computational</strong>:</li></ol>
<p class="paragraph">- Calculate probabilities using R
   - Generate and visualize distributions
   - Fit distributions to data</p>
<ol class="content-list"><li><strong>Applied</strong>:</li></ol>
<p class="paragraph">- Real-world problem modeling
   - Statistical inference
   - Hypothesis testing setup</p>
</section>

            <section class="content-section" id="practice-problems-with-solutions">
                <h3 class="section-heading"><strong>Practice Problems with Solutions</strong></h3>
            

            <div class="code-block">
                <pre><code class="language-r"># Problem 1: Quality Control
# A machine produces parts with 2% defect rate.
# In a sample of 50 parts, what&#x27;s probability of:
# a) Exactly 3 defective parts?
# b) At least 2 defective parts?

solution_qc &lt;- function() {
  n &lt;- 50
  p &lt;- 0.02
  
  # a) Exactly 3 defective
  prob_exact_3 &lt;- dbinom(3, size=n, prob=p)
  
  # b) At least 2 defective
  prob_at_least_2 &lt;- 1 - pbinom(1, size=n, prob=p)
  
  # Using Poisson approximation (np=1)
  lambda &lt;- n * p
  prob_poisson_3 &lt;- dpois(3, lambda=lambda)
  prob_poisson_at_least_2 &lt;- 1 - ppois(1, lambda=lambda)
  
  return(list(
    binomial = c(exact_3 = prob_exact_3, at_least_2 = prob_at_least_2),
    poisson = c(exact_3 = prob_poisson_3, at_least_2 = prob_poisson_at_least_2)
  ))
}

# Problem 2: Normal Distribution
# Test scores ~ N(μ=70, σ=10)
# a) Probability of scoring &gt;85?
# b) Score needed for top 5%?

solution_normal &lt;- function() {
  mu &lt;- 70
  sigma &lt;- 10
  
  prob_gt_85 &lt;- pnorm(85, mean=mu, sd=sigma, lower.tail=FALSE)
  top_5_cutoff &lt;- qnorm(0.95, mean=mu, sd=sigma)
  
  return(list(
    p_gt_85 = prob_gt_85,
    top_5_score = top_5_cutoff
  ))
}</code></pre>
            </div>
            
<hr class="content-hr">
</section>

            <section class="content-section" id="statistical-computing-r-programming-unit-3-statistical-testing-and-modelling-comprehensive-guide">
                <h1 class="section-heading"><strong>Statistical Computing & R Programming - Unit 3: Statistical Testing and Modelling (Comprehensive Guide)</strong></h1>
            
</section>

            <section class="content-section" id="1-statistical-testing-and-modelling-overview">
                <h2 class="section-heading"><strong>1. Statistical Testing and Modelling - Overview</strong></h2>
            
<ul class="content-list"><li><strong>Meaning</strong>: Statistical testing involves making inferences about populations based on sample data using probability theory. Modelling creates mathematical representations of relationships between variables.</li>
<li><strong>Purpose</strong>: To make data-driven decisions, test theories, predict outcomes, and understand relationships.</li>
<li><strong>Key Components</strong>:</li></ul>
<p class="paragraph">1. <strong>Descriptive Statistics</strong>: Summarize data
  2. <strong>Inferential Statistics</strong>: Draw conclusions about populations
  3. <strong>Predictive Modelling</strong>: Forecast future outcomes
  4. <strong>Explanatory Modelling</strong>: Understand relationships</p>

            <div class="special-block reference">
                <div class="special-label">Reference: Davies (2016) Chapters 13-16; Pawgi (2022) Chapters 8-11</div>
                <div class="special-content"></div>
            </div>
            
<hr class="content-hr">
</section>

            <section class="content-section" id="2-sampling-distributions">
                <h2 class="section-heading"><strong>2. Sampling Distributions</strong></h2>
            
</section>

            <section class="content-section" id="a-fundamental-concepts">
                <h3 class="section-heading"><strong>A. Fundamental Concepts</strong></h3>
            
<ul class="content-list"><li><strong>Definition</strong>: Probability distribution of a statistic obtained from multiple samples of same size from same population</li>
<li><strong>Key Sampling Distributions</strong>:</li></ul>
<ul class="content-list"><li><strong>Central Limit Theorem (CLT)</strong>: For large sample sizes (n ≥ 30), sampling distribution of mean approaches normal distribution regardless of population distribution</li></ul>
<p class="paragraph">1. <strong>Sampling distribution of the mean</strong>
  2. <strong>Sampling distribution of the proportion</strong>
  3. <strong>Sampling distribution of variance</strong></p>
</section>

            <section class="content-section" id="b-sampling-distribution-of-the-mean">
                <h3 class="section-heading"><strong>B. Sampling Distribution of the Mean</strong></h3>
            

            <div class="code-block">
                <pre><code class="language-r"># Demonstration of CLT
demonstrate_clt &lt;- function(pop_distribution, sample_size, n_samples=10000, pop_param=NULL) {
  # Generate sampling distribution
  sample_means &lt;- replicate(n_samples, {
    sample_data &lt;- pop_distribution(sample_size, pop_param)
    mean(sample_data)
  })
  
  # Calculate theoretical values
  if (!is.null(pop_param)) {
    if (is.list(pop_param)) {
      pop_mean &lt;- pop_param$mean
      pop_sd &lt;- pop_param$sd
    } else {
      # For exponential: mean = 1/rate, sd = 1/rate
      pop_mean &lt;- ifelse(is.numeric(pop_param), 1/pop_param, NA)
      pop_sd &lt;- ifelse(is.numeric(pop_param), 1/pop_param, NA)
    }
  }
  
  # Theoretical sampling distribution parameters
  theo_mean &lt;- ifelse(!is.na(pop_mean), pop_mean, mean(sample_means))
  theo_sd &lt;- ifelse(!is.na(pop_sd), pop_sd/sqrt(sample_size), sd(sample_means))
  
  # Visualization
  par(mfrow=c(2,2))
  
  # 1. Histogram of sample means
  hist(sample_means, breaks=50, freq=FALSE,
       main=paste(&quot;Sampling Distribution (n=&quot;, sample_size, &quot;)&quot;, sep=&quot;&quot;),
       xlab=&quot;Sample Means&quot;, col=&quot;lightblue&quot;, border=&quot;white&quot;)
  
  # Add normal curve
  x_seq &lt;- seq(min(sample_means), max(sample_means), length=200)
  lines(x_seq, dnorm(x_seq, mean=theo_mean, sd=theo_sd),
        col=&quot;red&quot;, lwd=2)
  
  # Add population mean line
  abline(v=theo_mean, col=&quot;darkgreen&quot;, lwd=2, lty=2)
  legend(&quot;topright&quot;, legend=c(&quot;Sample Distribution&quot;, &quot;Normal Curve&quot;, &quot;Population Mean&quot;),
         col=c(&quot;lightblue&quot;, &quot;red&quot;, &quot;darkgreen&quot;),
         lwd=c(5,2,2), lty=c(1,1,2))
  
  # 2. Q-Q plot
  qqnorm(sample_means, main=&quot;Normal Q-Q Plot&quot;)
  qqline(sample_means, col=&quot;blue&quot;)
  
  # 3. Compare with population distribution
  pop_sample &lt;- pop_distribution(1000, pop_param)
  hist(pop_sample, breaks=50, freq=FALSE,
       main=&quot;Population Distribution&quot;,
       xlab=&quot;Values&quot;, col=&quot;lightgreen&quot;, border=&quot;white&quot;)
  
  # 4. ECDF comparison
  plot(ecdf(sample_means), main=&quot;ECDF Comparison&quot;,
       xlab=&quot;Value&quot;, ylab=&quot;Cumulative Probability&quot;,
       col=&quot;blue&quot;, lwd=2)
  curve(pnorm(x, mean=theo_mean, sd=theo_sd), add=TRUE,
        col=&quot;red&quot;, lwd=2)
  legend(&quot;topleft&quot;, legend=c(&quot;Sample ECDF&quot;, &quot;Theoretical CDF&quot;),
         col=c(&quot;blue&quot;, &quot;red&quot;), lwd=2)
  
  par(mfrow=c(1,1))
  
  # Statistical tests
  shapiro_test &lt;- shapiro.test(sample_means)
  ks_test &lt;- ks.test(sample_means, &quot;pnorm&quot;, mean=theo_mean, sd=theo_sd)
  
  # Return results
  results &lt;- list(
    sample_mean = mean(sample_means),
    sample_sd = sd(sample_means),
    theoretical_mean = theo_mean,
    theoretical_se = theo_sd,
    shapiro_p = shapiro_test$p.value,
    ks_p = ks_test$p.value,
    empirical_rule = c(
      within_1sd = mean(abs(sample_means - theo_mean) &lt;= theo_sd),
      within_2sd = mean(abs(sample_means - theo_mean) &lt;= 2*theo_sd),
      within_3sd = mean(abs(sample_means - theo_mean) &lt;= 3*theo_sd)
    )
  )
  
  return(results)
}

# Examples with different population distributions

# 1. Normal population
clt_normal &lt;- demonstrate_clt(
  pop_distribution = function(n, param) rnorm(n, mean=param$mean, sd=param$sd),
  sample_size = 30,
  pop_param = list(mean=50, sd=10)
)

# 2. Uniform population
clt_uniform &lt;- demonstrate_clt(
  pop_distribution = function(n, param) runif(n, min=0, max=1),
  sample_size = 40,
  pop_param = list(mean=0.5, sd=sqrt(1/12))
)

# 3. Exponential population
clt_exponential &lt;- demonstrate_clt(
  pop_distribution = function(n, param) rexp(n, rate=param),
  sample_size = 50,
  pop_param = 0.5  # rate parameter
)

# 4. Binomial population (discrete)
clt_binomial &lt;- demonstrate_clt(
  pop_distribution = function(n, param) rbinom(n, size=param$size, prob=param$prob),
  sample_size = 100,
  pop_param = list(size=1, prob=0.3)  # Bernoulli
)</code></pre>
            </div>
            
</section>

            <section class="content-section" id="c-sampling-distribution-of-the-proportion">
                <h3 class="section-heading"><strong>C. Sampling Distribution of the Proportion</strong></h3>
            

            <div class="code-block">
                <pre><code class="language-r"># Sampling distribution of proportion
sampling_dist_proportion &lt;- function(pop_prop, sample_size, n_samples=10000) {
  # Generate samples
  sample_props &lt;- replicate(n_samples, {
    sample_data &lt;- rbinom(sample_size, size=1, prob=pop_prop)
    mean(sample_data)
  })
  
  # Theoretical parameters
  theo_mean &lt;- pop_prop
  theo_se &lt;- sqrt(pop_prop * (1 - pop_prop) / sample_size)
  
  # Check normal approximation conditions
  condition1 &lt;- sample_size * pop_prop &gt;= 10
  condition2 &lt;- sample_size * (1 - pop_prop) &gt;= 10
  
  # Visualization
  par(mfrow=c(2,2))
  
  # Histogram
  hist(sample_props, breaks=50, freq=FALSE,
       main=paste(&quot;Sampling Distribution of Proportion\nn=&quot;, sample_size, &quot;, p=&quot;, pop_prop),
       xlab=&quot;Sample Proportion&quot;, col=&quot;lightblue&quot;, border=&quot;white&quot;)
  
  # Add normal curve if conditions met
  if (condition1 &amp;&amp; condition2) {
    x_seq &lt;- seq(min(sample_props), max(sample_props), length=200)
    lines(x_seq, dnorm(x_seq, mean=theo_mean, sd=theo_se),
          col=&quot;red&quot;, lwd=2)
  }
  
  # Q-Q plot
  qqnorm(sample_props, main=&quot;Q-Q Plot&quot;)
  qqline(sample_props, col=&quot;blue&quot;)
  
  # Compare with binomial
  x_binom &lt;- 0:sample_size / sample_size
  binom_probs &lt;- dbinom(0:sample_size, size=sample_size, prob=pop_prop)
  plot(x_binom, binom_probs, type=&quot;h&quot;, lwd=2,
       main=&quot;Binomial Distribution&quot;,
       xlab=&quot;Proportion&quot;, ylab=&quot;Probability&quot;,
       col=&quot;darkgreen&quot;)
  
  # Normal approximation area
  if (condition1 &amp;&amp; condition2) {
    curve(dnorm(x, mean=theo_mean, sd=theo_se), 
          add=TRUE, col=&quot;red&quot;, lwd=2)
  }
  
  # Error distribution
  errors &lt;- sample_props - pop_prop
  hist(errors, breaks=50, freq=FALSE,
       main=&quot;Distribution of Errors&quot;,
       xlab=&quot;Error (p_hat - p)&quot;, col=&quot;lightgreen&quot;)
  abline(v=0, col=&quot;red&quot;, lwd=2)
  curve(dnorm(x, mean=0, sd=theo_se), add=TRUE,
        col=&quot;blue&quot;, lwd=2)
  
  par(mfrow=c(1,1))
  
  # Return results
  return(list(
    empirical_mean = mean(sample_props),
    empirical_se = sd(sample_props),
    theoretical_mean = theo_mean,
    theoretical_se = theo_se,
    normal_approximation_valid = condition1 &amp;&amp; condition2,
    confidence_interval_95 = theo_mean + c(-1, 1) * 1.96 * theo_se
  ))
}

# Examples
prop_small &lt;- sampling_dist_proportion(pop_prop=0.3, sample_size=10)
prop_large &lt;- sampling_dist_proportion(pop_prop=0.3, sample_size=100)
prop_extreme &lt;- sampling_dist_proportion(pop_prop=0.02, sample_size=200)</code></pre>
            </div>
            
</section>

            <section class="content-section" id="d-t-distribution-vs-normal-distribution">
                <h3 class="section-heading"><strong>D. t-Distribution vs Normal Distribution</strong></h3>
            

            <div class="code-block">
                <pre><code class="language-r"># Comparison of t and normal distributions for small samples
compare_t_normal &lt;- function(pop_sd_known=FALSE) {
  # Generate population
  pop_mean &lt;- 50
  pop_sd &lt;- 10
  
  # Sample sizes to test
  sample_sizes &lt;- c(5, 10, 20, 30, 50, 100)
  n_simulations &lt;- 10000
  
  # Storage for results
  results &lt;- matrix(NA, nrow=length(sample_sizes), ncol=4,
                    dimnames=list(sample_sizes,
                                  c(&quot;Coverage_Normal&quot;, &quot;Coverage_t&quot;,
                                    &quot;Avg_Width_Normal&quot;, &quot;Avg_Width_t&quot;)))
  
  for (i in seq_along(sample_sizes)) {
    n &lt;- sample_sizes[i]
    
    # Generate sampling distributions
    z_intervals &lt;- matrix(NA, nrow=n_simulations, ncol=2)
    t_intervals &lt;- matrix(NA, nrow=n_simulations, ncol=2)
    
    for (j in 1:n_simulations) {
      # Generate sample
      sample_data &lt;- rnorm(n, mean=pop_mean, sd=pop_sd)
      sample_mean &lt;- mean(sample_data)
      sample_sd &lt;- sd(sample_data)
      
      # Normal (Z) interval (if pop_sd known)
      if (pop_sd_known) {
        z_margin &lt;- 1.96 * pop_sd / sqrt(n)
      } else {
        z_margin &lt;- 1.96 * sample_sd / sqrt(n)  # Using sample sd
      }
      z_intervals[j, ] &lt;- sample_mean + c(-1, 1) * z_margin
      
      # t interval
      t_critical &lt;- qt(0.975, df=n-1)
      t_margin &lt;- t_critical * sample_sd / sqrt(n)
      t_intervals[j, ] &lt;- sample_mean + c(-1, 1) * t_margin
    }
    
    # Calculate coverage
    coverage_z &lt;- mean(z_intervals[,1] &lt;= pop_mean &amp; z_intervals[,2] &gt;= pop_mean)
    coverage_t &lt;- mean(t_intervals[,1] &lt;= pop_mean &amp; t_intervals[,2] &gt;= pop_mean)
    
    # Calculate average width
    width_z &lt;- mean(z_intervals[,2] - z_intervals[,1])
    width_t &lt;- mean(t_intervals[,2] - t_intervals[,1])
    
    results[i, ] &lt;- c(coverage_z, coverage_t, width_z, width_t)
  }
  
  # Visualization
  par(mfrow=c(1,2))
  
  # Coverage plot
  plot(sample_sizes, results[,&quot;Coverage_Normal&quot;], type=&quot;b&quot;,
       col=&quot;blue&quot;, pch=19, lwd=2, ylim=c(0.8, 1),
       main=&quot;Confidence Interval Coverage&quot;,
       xlab=&quot;Sample Size&quot;, ylab=&quot;Coverage Probability&quot;)
  lines(sample_sizes, results[,&quot;Coverage_t&quot;], type=&quot;b&quot;,
        col=&quot;red&quot;, pch=17, lwd=2)
  abline(h=0.95, lty=2, col=&quot;gray&quot;)
  legend(&quot;bottomright&quot;, legend=c(&quot;Normal (Z)&quot;, &quot;t-distribution&quot;),
         col=c(&quot;blue&quot;, &quot;red&quot;), pch=c(19,17), lwd=2)
  
  # Width plot
  plot(sample_sizes, results[,&quot;Avg_Width_Normal&quot;], type=&quot;b&quot;,
       col=&quot;blue&quot;, pch=19, lwd=2, ylim=range(results[,3:4]),
       main=&quot;Average Interval Width&quot;,
       xlab=&quot;Sample Size&quot;, ylab=&quot;Width&quot;)
  lines(sample_sizes, results[,&quot;Avg_Width_t&quot;], type=&quot;b&quot;,
        col=&quot;red&quot;, pch=17, lwd=2)
  legend(&quot;topright&quot;, legend=c(&quot;Normal (Z)&quot;, &quot;t-distribution&quot;),
         col=c(&quot;blue&quot;, &quot;red&quot;), pch=c(19,17), lwd=2)
  
  par(mfrow=c(1,1))
  
  return(results)
}

# Run comparison
comparison_results &lt;- compare_t_normal(pop_sd_known=FALSE)</code></pre>
            </div>
            

            <div class="special-block reference">
                <div class="special-label">Reference: Davies (2016) Chapter 13; Pawgi (2022) Chapter 8</div>
                <div class="special-content"></div>
            </div>
            
<hr class="content-hr">
</section>

            <section class="content-section" id="3-hypothesis-testing">
                <h2 class="section-heading"><strong>3. Hypothesis Testing</strong></h2>
            
</section>

            <section class="content-section" id="a-fundamental-concepts">
                <h3 class="section-heading"><strong>A. Fundamental Concepts</strong></h3>
            
<ul class="content-list"><li><strong>Definition</strong>: Statistical method to test claims about population parameters using sample data</li>
<li><strong>Key Components</strong>:</li></ul>
<p class="paragraph">1. <strong>Null Hypothesis (H₀)</strong>: Statement being tested (usually of no effect)
  2. <strong>Alternative Hypothesis (H₁/Hₐ)</strong>: What we want to prove
  3. <strong>Test Statistic</strong>: Calculated from sample data
  4. <strong>Significance Level (α)</strong>: Probability of Type I error
  5. <strong>p-value</strong>: Probability of observing results as extreme as sample if H₀ is true
  6. <strong>Decision Rule</strong>: Reject H₀ if p-value < α</p>
</section>

            <section class="content-section" id="b-types-of-hypothesis-tests">
                <h3 class="section-heading"><strong>B. Types of Hypothesis Tests</strong></h3>
            

            <div class="code-block">
                <pre><code class="language-r"># Hypothesis Testing Framework in R
hypothesis_testing_framework &lt;- function() {
  # Complete framework for hypothesis testing
  
  # Step 1: State hypotheses
  cat(&quot;Step 1: State Hypotheses\n&quot;)
  cat(&quot;  H₀: Null hypothesis (e.g., μ = μ₀)\n&quot;)
  cat(&quot;  H₁: Alternative hypothesis (e.g., μ ≠ μ₀, μ &gt; μ₀, μ &lt; μ₀)\n\n&quot;)
  
  # Step 2: Choose significance level
  cat(&quot;Step 2: Choose Significance Level (α)\n&quot;)
  cat(&quot;  Common values: 0.05, 0.01, 0.10\n&quot;)
  cat(&quot;  α = P(Type I error) = P(Reject H₀ | H₀ is true)\n\n&quot;)
  
  # Step 3: Identify test statistic
  cat(&quot;Step 3: Identify Test Statistic\n&quot;)
  cat(&quot;  For means: Z or t statistic\n&quot;)
  cat(&quot;  For proportions: Z statistic\n&quot;)
  cat(&quot;  For variances: Chi-square or F statistic\n\n&quot;)
  
  # Step 4: Formulate decision rule
  cat(&quot;Step 4: Formulate Decision Rule\n&quot;)
  cat(&quot;  Two-tailed: Reject H₀ if |test statistic| &gt; critical value\n&quot;)
  cat(&quot;  Right-tailed: Reject H₀ if test statistic &gt; critical value\n&quot;)
  cat(&quot;  Left-tailed: Reject H₀ if test statistic &lt; critical value\n\n&quot;)
  
  # Step 5: Calculate test statistic and p-value
  cat(&quot;Step 5: Calculate Test Statistic and p-value\n&quot;)
  cat(&quot;  Test statistic = (sample statistic - hypothesized value) / standard error\n&quot;)
  cat(&quot;  p-value = P(observing result as extreme as sample | H₀ is true)\n\n&quot;)
  
  # Step 6: Make decision
  cat(&quot;Step 6: Make Decision\n&quot;)
  cat(&quot;  If p-value &lt; α: Reject H₀\n&quot;)
  cat(&quot;  If p-value ≥ α: Fail to reject H₀\n\n&quot;)
  
  # Step 7: State conclusion
  cat(&quot;Step 7: State Conclusion\n&quot;)
  cat(&quot;  In context of the problem\n&quot;)
  cat(&quot;  Include effect size and confidence interval when possible\n&quot;)
}

# Run the framework
hypothesis_testing_framework()</code></pre>
            </div>
            
</section>

            <section class="content-section" id="c-components-of-hypothesis-test">
                <h3 class="section-heading"><strong>C. Components of Hypothesis Test</strong></h3>
            

            <div class="code-block">
                <pre><code class="language-r"># Detailed implementation of hypothesis test components
hypothesis_test_components &lt;- function(sample_data, mu0, alpha=0.05, 
                                       alternative=&quot;two.sided&quot;, sigma_known=FALSE) {
  # Complete hypothesis test with all components
  
  # 1. Sample statistics
  n &lt;- length(sample_data)
  x_bar &lt;- mean(sample_data)
  s &lt;- sd(sample_data)
  
  # 2. Test statistic
  if (sigma_known) {
    # Z-test (population SD known)
    test_stat &lt;- (x_bar - mu0) / (s / sqrt(n))
    distribution &lt;- &quot;Standard Normal&quot;
    critical_func &lt;- qnorm
  } else {
    # t-test (population SD unknown)
    test_stat &lt;- (x_bar - mu0) / (s / sqrt(n))
    distribution &lt;- paste(&quot;t with&quot;, n-1, &quot;df&quot;)
    critical_func &lt;- function(p) qt(p, df=n-1)
  }
  
  # 3. p-value calculation based on alternative hypothesis
  if (alternative == &quot;two.sided&quot;) {
    if (sigma_known) {
      p_value &lt;- 2 * pnorm(-abs(test_stat))
      critical_value &lt;- qnorm(1 - alpha/2)
    } else {
      p_value &lt;- 2 * pt(-abs(test_stat), df=n-1)
      critical_value &lt;- qt(1 - alpha/2, df=n-1)
    }
    rejection_region &lt;- paste(&quot;|Test Statistic| &gt;&quot;, round(critical_value, 3))
  } else if (alternative == &quot;greater&quot;) {
    if (sigma_known) {
      p_value &lt;- pnorm(test_stat, lower.tail=FALSE)
      critical_value &lt;- qnorm(1 - alpha)
    } else {
      p_value &lt;- pt(test_stat, df=n-1, lower.tail=FALSE)
      critical_value &lt;- qt(1 - alpha, df=n-1)
    }
    rejection_region &lt;- paste(&quot;Test Statistic &gt;&quot;, round(critical_value, 3))
  } else if (alternative == &quot;less&quot;) {
    if (sigma_known) {
      p_value &lt;- pnorm(test_stat)
      critical_value &lt;- qnorm(alpha)
    } else {
      p_value &lt;- pt(test_stat, df=n-1)
      critical_value &lt;- qt(alpha, df=n-1)
    }
    rejection_region &lt;- paste(&quot;Test Statistic &lt;&quot;, round(critical_value, 3))
  }
  
  # 4. Decision
  reject_h0 &lt;- p_value &lt; alpha
  decision &lt;- ifelse(reject_h0, &quot;Reject H₀&quot;, &quot;Fail to reject H₀&quot;)
  
  # 5. Confidence interval
  if (sigma_known) {
    margin_error &lt;- qnorm(1 - alpha/2) * (s / sqrt(n))
  } else {
    margin_error &lt;- qt(1 - alpha/2, df=n-1) * (s / sqrt(n))
  }
  ci_lower &lt;- x_bar - margin_error
  ci_upper &lt;- x_bar + margin_error
  
  # 6. Effect size (Cohen&#x27;s d)
  cohens_d &lt;- (x_bar - mu0) / s
  
  # 7. Visualization
  par(mfrow=c(1,2))
  
  # Distribution plot with test statistic and critical region
  x_seq &lt;- seq(-4, 4, length=1000)
  if (sigma_known) {
    pdf_values &lt;- dnorm(x_seq)
    dist_label &lt;- &quot;Standard Normal Distribution&quot;
  } else {
    pdf_values &lt;- dt(x_seq, df=n-1)
    dist_label &lt;- paste(&quot;t-Distribution (df =&quot;, n-1, &quot;)&quot;)
  }
  
  plot(x_seq, pdf_values, type=&quot;l&quot;, lwd=2,
       main=dist_label,
       xlab=&quot;Test Statistic&quot;, ylab=&quot;Density&quot;,
       col=&quot;black&quot;)
  
  # Shade critical region
  if (alternative == &quot;two.sided&quot;) {
    # Left tail
    x_left &lt;- seq(min(x_seq), -critical_value, length=100)
    polygon(c(min(x_seq), x_left, -critical_value),
            c(0, dt(x_left, df=ifelse(sigma_known, Inf, n-1)), 0),
            col=&quot;red&quot;, border=NA, density=30)
    # Right tail
    x_right &lt;- seq(critical_value, max(x_seq), length=100)
    polygon(c(critical_value, x_right, max(x_seq)),
            c(0, dt(x_right, df=ifelse(sigma_known, Inf, n-1)), 0),
            col=&quot;red&quot;, border=NA, density=30)
  } else if (alternative == &quot;greater&quot;) {
    x_right &lt;- seq(critical_value, max(x_seq), length=100)
    polygon(c(critical_value, x_right, max(x_seq)),
            c(0, dt(x_right, df=ifelse(sigma_known, Inf, n-1)), 0),
            col=&quot;red&quot;, border=NA, density=30)
  } else if (alternative == &quot;less&quot;) {
    x_left &lt;- seq(min(x_seq), critical_value, length=100)
    polygon(c(min(x_seq), x_left, critical_value),
            c(0, dt(x_left, df=ifelse(sigma_known, Inf, n-1)), 0),
            col=&quot;red&quot;, border=NA, density=30)
  }
  
  # Add test statistic line
  abline(v=test_stat, col=&quot;blue&quot;, lwd=2, lty=2)
  text(test_stat, max(pdf_values)*0.8,
       paste(&quot;Test Stat =&quot;, round(test_stat, 3)),
       pos=ifelse(test_stat&gt;0, 4, 2), col=&quot;blue&quot;)
  
  # Add critical value lines
  if (alternative == &quot;two.sided&quot;) {
    abline(v=c(-critical_value, critical_value),
           col=&quot;darkred&quot;, lwd=1, lty=3)
    text(critical_value, max(pdf_values)*0.9,
         paste(&quot;CV =&quot;, round(critical_value, 3)),
         pos=4, col=&quot;darkred&quot;)
  } else {
    abline(v=critical_value, col=&quot;darkred&quot;, lwd=1, lty=3)
    text(critical_value, max(pdf_values)*0.9,
         paste(&quot;CV =&quot;, round(critical_value, 3)),
         pos=4, col=&quot;darkred&quot;)
  }
  
  legend(&quot;topright&quot;,
         legend=c(&quot;Distribution&quot;, &quot;Test Statistic&quot;, &quot;Critical Region&quot;),
         col=c(&quot;black&quot;, &quot;blue&quot;, &quot;red&quot;),
         lwd=c(2,2,5), lty=c(1,2,1))
  
  # Sample data histogram with hypothesized mean
  hist(sample_data, breaks=20, freq=FALSE,
       main=&quot;Sample Distribution&quot;,
       xlab=&quot;Data Values&quot;, col=&quot;lightblue&quot;, border=&quot;white&quot;)
  abline(v=mu0, col=&quot;red&quot;, lwd=2, lty=2)
  abline(v=x_bar, col=&quot;blue&quot;, lwd=2, lty=2)
  legend(&quot;topright&quot;,
         legend=c(paste(&quot;Hypothesized (μ₀=&quot;, mu0, &quot;)&quot;, sep=&quot;&quot;),
                  paste(&quot;Sample Mean (x̄=&quot;, round(x_bar,2), &quot;)&quot;, sep=&quot;&quot;)),
         col=c(&quot;red&quot;, &quot;blue&quot;), lwd=2, lty=2)
  
  par(mfrow=c(1,1))
  
  # Return comprehensive results
  results &lt;- list(
    hypotheses = list(
      null = paste(&quot;H₀: μ =&quot;, mu0),
      alternative = paste(&quot;H₁: μ&quot;, 
                         ifelse(alternative==&quot;two.sided&quot;, &quot;≠&quot;,
                                ifelse(alternative==&quot;greater&quot;, &quot;&gt;&quot;, &quot;&lt;&quot;)),
                         mu0)
    ),
    sample_statistics = c(
      n = n,
      mean = x_bar,
      sd = s,
      se = s/sqrt(n)
    ),
    test_statistics = c(
      test_statistic = test_stat,
      distribution = distribution,
      critical_value = critical_value,
      rejection_region = rejection_region
    ),
    p_value = p_value,
    significance_level = alpha,
    decision = c(
      reject_h0 = reject_h0,
      conclusion = decision
    ),
    confidence_interval = c(
      level = 1-alpha,
      lower = ci_lower,
      upper = ci_upper,
      contains_mu0 = ci_lower &lt;= mu0 &amp; ci_upper &gt;= mu0
    ),
    effect_size = c(
      cohens_d = cohens_d,
      interpretation = ifelse(abs(cohens_d)&lt;0.2, &quot;Negligible&quot;,
                              ifelse(abs(cohens_d)&lt;0.5, &quot;Small&quot;,
                                     ifelse(abs(cohens_d)&lt;0.8, &quot;Medium&quot;, &quot;Large&quot;)))
    )
  )
  
  return(results)
}

# Example usage
set.seed(123)
sample_data_example &lt;- rnorm(30, mean=52, sd=10)  # True mean is 52
test_results &lt;- hypothesis_test_components(
  sample_data = sample_data_example,
  mu0 = 50,  # Test if mean = 50
  alpha = 0.05,
  alternative = &quot;two.sided&quot;,
  sigma_known = FALSE
)

# Print formatted results
print_hypothesis_results &lt;- function(results) {
  cat(&quot;HYPOTHESIS TEST RESULTS\n&quot;)
  cat(&quot;======================\n\n&quot;)
  
  cat(&quot;1. HYPOTHESES:\n&quot;)
  cat(&quot;   &quot;, results$hypotheses$null, &quot;\n&quot;)
  cat(&quot;   &quot;, results$hypotheses$alternative, &quot;\n\n&quot;)
  
  cat(&quot;2. SAMPLE STATISTICS:\n&quot;)
  cat(&quot;   Sample size (n):&quot;, results$sample_statistics[&quot;n&quot;], &quot;\n&quot;)
  cat(&quot;   Sample mean (x̄):&quot;, round(results$sample_statistics[&quot;mean&quot;], 3), &quot;\n&quot;)
  cat(&quot;   Sample SD (s):&quot;, round(results$sample_statistics[&quot;sd&quot;], 3), &quot;\n&quot;)
  cat(&quot;   Standard Error (SE):&quot;, round(results$sample_statistics[&quot;se&quot;], 3), &quot;\n\n&quot;)
  
  cat(&quot;3. TEST STATISTIC:\n&quot;)
  cat(&quot;   Test statistic:&quot;, round(results$test_statistics[&quot;test_statistic&quot;], 3), &quot;\n&quot;)
  cat(&quot;   Distribution:&quot;, results$test_statistics[&quot;distribution&quot;], &quot;\n&quot;)
  cat(&quot;   Critical value:&quot;, round(results$test_statistics[&quot;critical_value&quot;], 3), &quot;\n&quot;)
  cat(&quot;   Rejection region:&quot;, results$test_statistics[&quot;rejection_region&quot;], &quot;\n\n&quot;)
  
  cat(&quot;4. p-VALUE AND DECISION:\n&quot;)
  cat(&quot;   p-value:&quot;, format.pval(results$p_value, digits=3), &quot;\n&quot;)
  cat(&quot;   Significance level (α):&quot;, results$significance_level, &quot;\n&quot;)
  cat(&quot;   Decision:&quot;, results$decision[&quot;conclusion&quot;], &quot;\n&quot;)
  cat(&quot;   Reason:&quot;, ifelse(results$decision[&quot;reject_h0&quot;], 
                          paste(&quot;p-value &lt;&quot;, results$significance_level),
                          paste(&quot;p-value ≥&quot;, results$significance_level)), &quot;\n\n&quot;)
  
  cat(&quot;5. CONFIDENCE INTERVAL:\n&quot;)
  cat(&quot;   &quot;, round(100*results$confidence_interval[&quot;level&quot;], 1), 
      &quot;% CI: [&quot;, round(results$confidence_interval[&quot;lower&quot;], 3), &quot;, &quot;,
      round(results$confidence_interval[&quot;upper&quot;], 3), &quot;]\n&quot;, sep=&quot;&quot;)
  cat(&quot;   Contains μ₀?&quot;, ifelse(results$confidence_interval[&quot;contains_mu0&quot;], &quot;Yes&quot;, &quot;No&quot;), &quot;\n\n&quot;)
  
  cat(&quot;6. EFFECT SIZE:\n&quot;)
  cat(&quot;   Cohen&#x27;s d:&quot;, round(results$effect_size[&quot;cohens_d&quot;], 3), &quot;\n&quot;)
  cat(&quot;   Interpretation:&quot;, results$effect_size[&quot;interpretation&quot;], &quot;effect\n&quot;)
}

print_hypothesis_results(test_results)</code></pre>
            </div>
            

            <div class="special-block reference">
                <div class="special-label">Reference: Davies (2016) Chapter 14; Pawgi (2022) Chapter 9</div>
                <div class="special-content"></div>
            </div>
            
<hr class="content-hr">
</section>

            <section class="content-section" id="4-testing-means">
                <h2 class="section-heading"><strong>4. Testing Means</strong></h2>
            
</section>

            <section class="content-section" id="a-one-sample-tests">
                <h3 class="section-heading"><strong>A. One-Sample Tests</strong></h3>
            

            <div class="code-block">
                <pre><code class="language-r"># Comprehensive one-sample mean testing
one_sample_mean_tests &lt;- function() {
  # 1. One-sample Z-test (σ known)
  one_sample_z_test &lt;- function(x, mu0, sigma, alternative=&quot;two.sided&quot;, alpha=0.05) {
    n &lt;- length(x)
    x_bar &lt;- mean(x)
    
    # Test statistic
    z_stat &lt;- (x_bar - mu0) / (sigma / sqrt(n))
    
    # p-value
    if (alternative == &quot;two.sided&quot;) {
      p_value &lt;- 2 * pnorm(-abs(z_stat))
      critical_value &lt;- qnorm(1 - alpha/2)
      ci_margin &lt;- qnorm(1 - alpha/2) * sigma / sqrt(n)
    } else if (alternative == &quot;greater&quot;) {
      p_value &lt;- pnorm(z_stat, lower.tail=FALSE)
      critical_value &lt;- qnorm(1 - alpha)
      ci_margin &lt;- qnorm(1 - alpha) * sigma / sqrt(n)
    } else {
      p_value &lt;- pnorm(z_stat)
      critical_value &lt;- qnorm(alpha)
      ci_margin &lt;- qnorm(1 - alpha) * sigma / sqrt(n)
    }
    
    # Confidence interval
    if (alternative == &quot;two.sided&quot;) {
      ci &lt;- x_bar + c(-1, 1) * ci_margin
    } else if (alternative == &quot;greater&quot;) {
      ci &lt;- c(x_bar - ci_margin, Inf)
    } else {
      ci &lt;- c(-Inf, x_bar + ci_margin)
    }
    
    return(list(
      method = &quot;One-sample Z-test&quot;,
      statistic = z_stat,
      p_value = p_value,
      alternative = alternative,
      null_value = mu0,
      confidence_interval = ci,
      estimate = x_bar,
      stderr = sigma / sqrt(n)
    ))
  }
  
  # 2. One-sample t-test (σ unknown)
  one_sample_t_test &lt;- function(x, mu0, alternative=&quot;two.sided&quot;, alpha=0.05) {
    n &lt;- length(x)
    x_bar &lt;- mean(x)
    s &lt;- sd(x)
    df &lt;- n - 1
    
    # Test statistic
    t_stat &lt;- (x_bar - mu0) / (s / sqrt(n))
    
    # p-value
    if (alternative == &quot;two.sided&quot;) {
      p_value &lt;- 2 * pt(-abs(t_stat), df=df)
      critical_value &lt;- qt(1 - alpha/2, df=df)
      ci_margin &lt;- critical_value * s / sqrt(n)
    } else if (alternative == &quot;greater&quot;) {
      p_value &lt;- pt(t_stat, df=df, lower.tail=FALSE)
      critical_value &lt;- qt(1 - alpha, df=df)
      ci_margin &lt;- critical_value * s / sqrt(n)
    } else {
      p_value &lt;- pt(t_stat, df=df)
      critical_value &lt;- qt(alpha, df=df)
      ci_margin &lt;- abs(critical_value) * s / sqrt(n)
    }
    
    # Confidence interval
    if (alternative == &quot;two.sided&quot;) {
      ci &lt;- x_bar + c(-1, 1) * ci_margin
    } else if (alternative == &quot;greater&quot;) {
      ci &lt;- c(x_bar - ci_margin, Inf)
    } else {
      ci &lt;- c(-Inf, x_bar + ci_margin)
    }
    
    return(list(
      method = &quot;One-sample t-test&quot;,
      statistic = t_stat,
      parameter = df,
      p_value = p_value,
      alternative = alternative,
      null_value = mu0,
      confidence_interval = ci,
      estimate = x_bar,
      stderr = s / sqrt(n)
    ))
  }
  
  # 3. Built-in t.test function (for comparison)
  use_builtin_t_test &lt;- function(x, mu0, alternative=&quot;two.sided&quot;, conf.level=0.95) {
    test_result &lt;- t.test(x, mu=mu0, alternative=alternative, conf.level=conf.level)
    return(test_result)
  }
  
  # 4. Example demonstration
  demonstrate_mean_tests &lt;- function() {
    set.seed(123)
    
    # Generate sample data
    true_mean &lt;- 52
    true_sd &lt;- 10
    sample_size &lt;- 30
    sample_data &lt;- rnorm(sample_size, mean=true_mean, sd=true_sd)
    
    # Test different hypotheses
    hypotheses &lt;- list(
      list(name=&quot;Equal to 50&quot;, mu0=50, alternative=&quot;two.sided&quot;),
      list(name=&quot;Greater than 50&quot;, mu0=50, alternative=&quot;greater&quot;),
      list(name=&quot;Less than 54&quot;, mu0=54, alternative=&quot;less&quot;)
    )
    
    # Run tests
    results &lt;- list()
    for (i in seq_along(hypotheses)) {
      h &lt;- hypotheses[[i]]
      
      # Z-test (assuming we know population SD)
      z_result &lt;- one_sample_z_test(sample_data, mu0=h$mu0, 
                                    sigma=true_sd, alternative=h$alternative)
      
      # t-test (using sample SD)
      t_result &lt;- one_sample_t_test(sample_data, mu0=h$mu0, 
                                    alternative=h$alternative)
      
      # Built-in t-test
      builtin_result &lt;- use_builtin_t_test(sample_data, mu0=h$mu0,
                                           alternative=h$alternative)
      
      results[[i]] &lt;- list(
        hypothesis = h$name,
        z_test = z_result,
        t_test = t_result,
        builtin = builtin_result
      )
    }
    
    # Visualization
    par(mfrow=c(2,2))
    
    # Sample distribution
    hist(sample_data, breaks=15, freq=FALSE,
         main=&quot;Sample Distribution&quot;,
         xlab=&quot;Values&quot;, col=&quot;lightblue&quot;, border=&quot;white&quot;)
    abline(v=true_mean, col=&quot;green&quot;, lwd=2, lty=2)
    abline(v=mean(sample_data), col=&quot;blue&quot;, lwd=2)
    curve(dnorm(x, mean=true_mean, sd=true_sd), add=TRUE, col=&quot;red&quot;, lwd=2)
    legend(&quot;topright&quot;,
           legend=c(&quot;Sample&quot;, &quot;True Mean&quot;, &quot;Sample Mean&quot;, &quot;Population&quot;),
           col=c(&quot;lightblue&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;red&quot;),
           lwd=c(5,2,2,2), lty=c(1,2,1,1))
    
    # Test statistics comparison
    test_stats &lt;- sapply(results, function(r) c(
      Z = r$z_test$statistic,
      t = r$t_test$statistic
    ))
    
    barplot(test_stats, beside=TRUE,
            main=&quot;Test Statistics Comparison&quot;,
            xlab=&quot;Hypothesis&quot;, ylab=&quot;Test Statistic&quot;,
            col=c(&quot;lightblue&quot;, &quot;lightgreen&quot;),
            names.arg=sapply(results, function(r) r$hypothesis))
    abline(h=0, col=&quot;gray&quot;)
    legend(&quot;topright&quot;, legend=c(&quot;Z-statistic&quot;, &quot;t-statistic&quot;),
           fill=c(&quot;lightblue&quot;, &quot;lightgreen&quot;))
    
    # p-values comparison
    p_values &lt;- sapply(results, function(r) c(
      Z = r$z_test$p_value,
      t = r$t_test$p_value
    ))
    
    barplot(-log10(p_values), beside=TRUE,
            main=&quot;-log10(p-values) Comparison&quot;,
            xlab=&quot;Hypothesis&quot;, ylab=&quot;-log10(p-value)&quot;,
            col=c(&quot;lightblue&quot;, &quot;lightgreen&quot;),
            names.arg=sapply(results, function(r) r$hypothesis))
    abline(h=-log10(0.05), col=&quot;red&quot;, lty=2)
    legend(&quot;topright&quot;, legend=c(&quot;Z-test&quot;, &quot;t-test&quot;, &quot;α=0.05&quot;),
           fill=c(&quot;lightblue&quot;, &quot;lightgreen&quot;, NA),
           lty=c(0,0,2), col=c(NA,NA,&quot;red&quot;))
    
    # Confidence intervals
    plot(1, type=&quot;n&quot;, xlim=c(48, 56), ylim=c(0.5, 3.5),
         main=&quot;Confidence Intervals&quot;,
         xlab=&quot;Mean&quot;, ylab=&quot;Test&quot;, yaxt=&quot;n&quot;)
    axis(2, at=1:3, labels=sapply(results, function(r) r$hypothesis))
    
    colors &lt;- c(&quot;blue&quot;, &quot;green&quot;, &quot;red&quot;)
    for (i in 1:3) {
      # Z-test CI
      z_ci &lt;- results[[i]]$z_test$confidence_interval
      lines(z_ci, rep(i-0.1, 2), col=colors[i], lwd=3)
      points(mean(z_ci), i-0.1, pch=19, col=colors[i])
      
      # t-test CI
      t_ci &lt;- results[[i]]$t_test$confidence_interval
      lines(t_ci, rep(i+0.1, 2), col=colors[i], lwd=3, lty=2)
      points(mean(t_ci), i+0.1, pch=17, col=colors[i])
      
      # Null value
      abline(v=hypotheses[[i]]$mu0, col=&quot;gray&quot;, lty=3)
    }
    
    legend(&quot;bottomright&quot;,
           legend=c(&quot;Z-test CI&quot;, &quot;t-test CI&quot;, &quot;Null value&quot;),
           lty=c(1,2,3), lwd=c(3,3,1),
           col=c(&quot;black&quot;, &quot;black&quot;, &quot;gray&quot;))
    
    par(mfrow=c(1,1))
    
    return(results)
  }
  
  # Run demonstration
  test_results &lt;- demonstrate_mean_tests()
  
  return(list(
    z_test_function = one_sample_z_test,
    t_test_function = one_sample_t_test,
    builtin_function = use_builtin_t_test,
    demonstration = test_results
  ))
}

# Create and run the mean testing functions
mean_testing_system &lt;- one_sample_mean_tests()</code></pre>
            </div>
            
</section>

            <section class="content-section" id="b-two-sample-tests">
                <h3 class="section-heading"><strong>B. Two-Sample Tests</strong></h3>
            

            <div class="code-block">
                <pre><code class="language-r"># Two-sample mean tests
two_sample_mean_tests &lt;- function() {
  # 1. Independent samples t-test (equal variances assumed)
  independent_t_test &lt;- function(x, y, alternative=&quot;two.sided&quot;, 
                                 var.equal=TRUE, alpha=0.05) {
    n1 &lt;- length(x)
    n2 &lt;- length(y)
    x_bar &lt;- mean(x)
    y_bar &lt;- mean(y)
    s1 &lt;- sd(x)
    s2 &lt;- sd(y)
    
    if (var.equal) {
      # Pooled variance
      s_pooled &lt;- sqrt(((n1-1)*s1^2 + (n2-1)*s2^2) / (n1 + n2 - 2))
      se &lt;- s_pooled * sqrt(1/n1 + 1/n2)
      df &lt;- n1 + n2 - 2
    } else {
      # Welch&#x27;s t-test (unequal variances)
      se &lt;- sqrt(s1^2/n1 + s2^2/n2)
      # Welch-Satterthwaite equation for degrees of freedom
      df_num &lt;- (s1^2/n1 + s2^2/n2)^2
      df_den &lt;- (s1^2/n1)^2/(n1-1) + (s2^2/n2)^2/(n2-1)
      df &lt;- df_num / df_den
    }
    
    # Test statistic
    t_stat &lt;- (x_bar - y_bar) / se
    
    # p-value
    if (alternative == &quot;two.sided&quot;) {
      p_value &lt;- 2 * pt(-abs(t_stat), df=df)
      critical_value &lt;- qt(1 - alpha/2, df=df)
      ci_margin &lt;- critical_value * se
    } else if (alternative == &quot;greater&quot;) {
      p_value &lt;- pt(t_stat, df=df, lower.tail=FALSE)
      critical_value &lt;- qt(1 - alpha, df=df)
      ci_margin &lt;- critical_value * se
    } else {
      p_value &lt;- pt(t_stat, df=df)
      critical_value &lt;- qt(alpha, df=df)
      ci_margin &lt;- abs(critical_value) * se
    }
    
    # Confidence interval for difference
    diff_mean &lt;- x_bar - y_bar
    if (alternative == &quot;two.sided&quot;) {
      ci &lt;- diff_mean + c(-1, 1) * ci_margin
    } else if (alternative == &quot;greater&quot;) {
      ci &lt;- c(diff_mean - ci_margin, Inf)
    } else {
      ci &lt;- c(-Inf, diff_mean + ci_margin)
    }
    
    # Effect size (Cohen&#x27;s d)
    if (var.equal) {
      pooled_sd &lt;- s_pooled
    } else {
      pooled_sd &lt;- sqrt(((n1-1)*s1^2 + (n2-1)*s2^2) / (n1 + n2 - 2))
    }
    cohens_d &lt;- (x_bar - y_bar) / pooled_sd
    
    return(list(
      method = ifelse(var.equal, 
                      &quot;Two-sample t-test (equal variances)&quot;,
                      &quot;Welch&#x27;s t-test (unequal variances)&quot;),
      statistic = t_stat,
      parameter = df,
      p_value = p_value,
      alternative = alternative,
      difference = diff_mean,
      confidence_interval = ci,
      effect_size = cohens_d,
      sample_stats = list(
        group1 = c(n=n1, mean=x_bar, sd=s1),
        group2 = c(n=n2, mean=y_bar, sd=s2)
      )
    ))
  }
  
  # 2. Paired t-test
  paired_t_test &lt;- function(x, y, alternative=&quot;two.sided&quot;, alpha=0.05) {
    # Check equal lengths
    if (length(x) != length(y)) {
      stop(&quot;Paired test requires equal sample sizes&quot;)
    }
    
    # Calculate differences
    d &lt;- x - y
    n &lt;- length(d)
    d_bar &lt;- mean(d)
    s_d &lt;- sd(d)
    se_d &lt;- s_d / sqrt(n)
    df &lt;- n - 1
    
    # Test statistic
    t_stat &lt;- d_bar / se_d
    
    # p-value
    if (alternative == &quot;two.sided&quot;) {
      p_value &lt;- 2 * pt(-abs(t_stat), df=df)
      critical_value &lt;- qt(1 - alpha/2, df=df)
      ci_margin &lt;- critical_value * se_d
    } else if (alternative == &quot;greater&quot;) {
      p_value &lt;- pt(t_stat, df=df, lower.tail=FALSE)
      critical_value &lt;- qt(1 - alpha, df=df)
      ci_margin &lt;- critical_value * se_d
    } else {
      p_value &lt;- pt(t_stat, df=df)
      critical_value &lt;- qt(alpha, df=df)
      ci_margin &lt;- abs(critical_value) * se_d
    }
    
    # Confidence interval
    if (alternative == &quot;two.sided&quot;) {
      ci &lt;- d_bar + c(-1, 1) * ci_margin
    } else if (alternative == &quot;greater&quot;) {
      ci &lt;- c(d_bar - ci_margin, Inf)
    } else {
      ci &lt;- c(-Inf, d_bar + ci_margin)
    }
    
    # Effect size
    cohens_d &lt;- d_bar / s_d
    
    return(list(
      method = &quot;Paired t-test&quot;,
      statistic = t_stat,
      parameter = df,
      p_value = p_value,
      alternative = alternative,
      mean_difference = d_bar,
      confidence_interval = ci,
      effect_size = cohens_d,
      correlation = cor(x, y),
      sample_stats = list(
        n_pairs = n,
        mean1 = mean(x), mean2 = mean(y),
        sd1 = sd(x), sd2 = sd(y)
      )
    ))
  }
  
  # 3. F-test for equality of variances
  variance_f_test &lt;- function(x, y, alternative=&quot;two.sided&quot;, alpha=0.05) {
    s1_sq &lt;- var(x)
    s2_sq &lt;- var(y)
    n1 &lt;- length(x)
    n2 &lt;- length(y)
    
    # F-statistic (larger variance in numerator)
    if (s1_sq &gt;= s2_sq) {
      f_stat &lt;- s1_sq / s2_sq
      df1 &lt;- n1 - 1
      df2 &lt;- n2 - 1
    } else {
      f_stat &lt;- s2_sq / s1_sq
      df1 &lt;- n2 - 1
      df2 &lt;- n1 - 1
    }
    
    # p-value
    if (alternative == &quot;two.sided&quot;) {
      p_value &lt;- 2 * min(pf(f_stat, df1, df2, lower.tail=FALSE),
                         pf(f_stat, df1, df2))
    } else if (alternative == &quot;greater&quot;) {
      p_value &lt;- pf(f_stat, df1, df2, lower.tail=FALSE)
    } else {
      p_value &lt;- pf(f_stat, df1, df2)
    }
    
    # Critical value
    if (alternative == &quot;two.sided&quot;) {
      critical_value &lt;- qf(1 - alpha/2, df1, df2)
    } else if (alternative == &quot;greater&quot;) {
      critical_value &lt;- qf(1 - alpha, df1, df2)
    } else {
      critical_value &lt;- qf(alpha, df1, df2)
    }
    
    return(list(
      method = &quot;F-test for equality of variances&quot;,
      statistic = f_stat,
      parameter = c(df1=df1, df2=df2),
      p_value = p_value,
      alternative = alternative,
      variances = c(var1=s1_sq, var2=s2_sq),
      ratio = f_stat,
      critical_value = critical_value
    ))
  }
  
  # 4. Demonstration
  demonstrate_two_sample_tests &lt;- function() {
    set.seed(123)
    
    # Generate example data
    # Group 1: Treatment group
    group1 &lt;- rnorm(30, mean=55, sd=8)
    # Group 2: Control group
    group2 &lt;- rnorm(30, mean=50, sd=10)
    # Paired data (before/after)
    before &lt;- rnorm(25, mean=45, sd=7)
    after &lt;- before + rnorm(25, mean=5, sd=3)  # Improvement of about 5
    
    # Run tests
    tests &lt;- list()
    
    # Independent t-test (equal variances assumed)
    tests$independent_equal &lt;- independent_t_test(group1, group2, 
                                                  var.equal=TRUE)
    
    # Welch&#x27;s t-test (unequal variances)
    tests$independent_unequal &lt;- independent_t_test(group1, group2,
                                                    var.equal=FALSE)
    
    # Paired t-test
    tests$paired &lt;- paired_t_test(before, after)
    
    # F-test for variances
    tests$variance &lt;- variance_f_test(group1, group2)
    
    # Visualization
    par(mfrow=c(2,3))
    
    # Boxplot comparison
    boxplot(list(Group1=group1, Group2=group2),
            main=&quot;Independent Samples&quot;,
            ylab=&quot;Values&quot;, col=c(&quot;lightblue&quot;, &quot;lightgreen&quot;))
    
    # Histogram comparison
    hist(group1, breaks=15, col=rgb(0,0,1,0.5), 
         main=&quot;Distribution Comparison&quot;,
         xlab=&quot;Values&quot;, xlim=range(c(group1, group2)), freq=FALSE)
    hist(group2, breaks=15, col=rgb(0,1,0,0.5), add=TRUE, freq=FALSE)
    legend(&quot;topright&quot;, legend=c(&quot;Group 1&quot;, &quot;Group 2&quot;),
           fill=c(rgb(0,0,1,0.5), rgb(0,1,0,0.5)))
    
    # Q-Q plot for normality check
    qqnorm(c(group1, group2), main=&quot;Q-Q Plot (Pooled)&quot;)
    qqline(c(group1, group2), col=&quot;red&quot;)
    
    # Paired data plot
    plot(before, after, pch=19, col=&quot;blue&quot;,
         main=&quot;Paired Data (Before vs After)&quot;,
         xlab=&quot;Before&quot;, ylab=&quot;After&quot;,
         xlim=range(c(before, after)),
         ylim=range(c(before, after)))
    abline(0, 1, col=&quot;gray&quot;, lty=2)  # Line of equality
    segments(before, before, before, after, col=&quot;red&quot;, lty=3)
    
    # Differences histogram
    differences &lt;- after - before
    hist(differences, breaks=15, col=&quot;lightgreen&quot;,
         main=&quot;Differences Distribution&quot;,
         xlab=&quot;After - Before&quot;, freq=FALSE)
    abline(v=mean(differences), col=&quot;red&quot;, lwd=2)
    curve(dnorm(x, mean=mean(differences), sd=sd(differences)),
          add=TRUE, col=&quot;blue&quot;, lwd=2)
    
    # Test statistics comparison
    test_stats &lt;- c(
      Independent_equal = tests$independent_equal$statistic,
      Independent_unequal = tests$independent_unequal$statistic,
      Paired = tests$paired$statistic
    )
    
    barplot(test_stats,
            main=&quot;Test Statistics Comparison&quot;,
            ylab=&quot;t-statistic&quot;,
            col=c(&quot;lightblue&quot;, &quot;lightgreen&quot;, &quot;lightpink&quot;),
            ylim=c(0, max(test_stats)*1.2))
    abline(h=c(-2, 2), col=&quot;red&quot;, lty=2)
    
    par(mfrow=c(1,1))
    
    # Return comprehensive results
    return(list(
      tests = tests,
      data = list(
        group1 = group1,
        group2 = group2,
        before = before,
        after = after
      )
    ))
  }
  
  # Run demonstration
  demo_results &lt;- demonstrate_two_sample_tests()
  
  # Summary table function
  create_summary_table &lt;- function(results) {
    tests &lt;- results$tests
    
    summary_df &lt;- data.frame(
      Test = c(&quot;Independent (equal var)&quot;, &quot;Independent (unequal var)&quot;, 
               &quot;Paired&quot;, &quot;Variance F-test&quot;),
      Statistic = c(
        round(tests$independent_equal$statistic, 3),
        round(tests$independent_unequal$statistic, 3),
        round(tests$paired$statistic, 3),
        round(tests$variance$statistic, 3)
      ),
      DF = c(
        tests$independent_equal$parameter,
        round(tests$independent_unequal$parameter, 1),
        tests$paired$parameter,
        paste(tests$variance$parameter[&quot;df1&quot;], &quot;,&quot;, 
              tests$variance$parameter[&quot;df2&quot;])
      ),
      P_Value = c(
        format.pval(tests$independent_equal$p_value, digits=3),
        format.pval(tests$independent_unequal$p_value, digits=3),
        format.pval(tests$paired$p_value, digits=3),
        format.pval(tests$variance$p_value, digits=3)
      ),
      Effect_Size = c(
        round(tests$independent_equal$effect_size, 3),
        round(tests$independent_unequal$effect_size, 3),
        round(tests$paired$effect_size, 3),
        NA
      ),
      CI_Lower = c(
        round(tests$independent_equal$confidence_interval[1], 2),
        round(tests$independent_unequal$confidence_interval[1], 2),
        round(tests$paired$confidence_interval[1], 2),
        NA
      ),
      CI_Upper = c(
        round(tests$independent_equal$confidence_interval[2], 2),
        round(tests$independent_unequal$confidence_interval[2], 2),
        round(tests$paired$confidence_interval[2], 2),
        NA
      )
    )
    
    return(summary_df)
  }
  
  summary_table &lt;- create_summary_table(demo_results)
  
  return(list(
    independent_test = independent_t_test,
    paired_test = paired_t_test,
    variance_test = variance_f_test,
    demonstration = demo_results,
    summary = summary_table
  ))
}

# Create and run two-sample testing system
two_sample_system &lt;- two_sample_mean_tests()
print(two_sample_system$summary)</code></pre>
            </div>
            
</section>

            <section class="content-section" id="c-non-parametric-alternatives">
                <h3 class="section-heading"><strong>C. Non-parametric Alternatives</strong></h3>
            

            <div class="code-block">
                <pre><code class="language-r"># Non-parametric tests for means
nonparametric_mean_tests &lt;- function() {
  # 1. Wilcoxon Signed-Rank Test (non-parametric alternative to one-sample/paired t-test)
  wilcoxon_signed_rank_test_custom &lt;- function(x, y=NULL, mu=0, 
                                               alternative=&quot;two.sided&quot;, 
                                               conf.int=FALSE, conf.level=0.95) {
    if (is.null(y)) {
      # One-sample test
      d &lt;- x - mu
    } else {
      # Paired test
      if (length(x) != length(y)) {
        stop(&quot;Paired test requires equal sample sizes&quot;)
      }
      d &lt;- x - y
    }
    
    # Remove zeros
    d &lt;- d[d != 0]
    n &lt;- length(d)
    
    if (n == 0) {
      stop(&quot;No non-zero differences&quot;)
    }
    
    # Absolute differences and ranks
    abs_d &lt;- abs(d)
    ranks &lt;- rank(abs_d)
    
    # Signed ranks
    signed_ranks &lt;- sign(d) * ranks
    
    # Test statistic (sum of positive ranks)
    V &lt;- sum(ranks[d &gt; 0])
    
    # Expected value and variance under H0
    EV &lt;- n * (n + 1) / 4
    VarV &lt;- n * (n + 1) * (2 * n + 1) / 24
    
    # Normal approximation (for n &gt;= 10)
    if (n &gt;= 10) {
      z_stat &lt;- (V - EV) / sqrt(VarV)
      
      if (alternative == &quot;two.sided&quot;) {
        p_value &lt;- 2 * pnorm(-abs(z_stat))
      } else if (alternative == &quot;greater&quot;) {
        p_value &lt;- pnorm(z_stat, lower.tail=FALSE)
      } else {
        p_value &lt;- pnorm(z_stat)
      }
    } else {
      # Exact p-value (simplified)
      p_value &lt;- NA  # In practice, use wilcox.test() for exact
      z_stat &lt;- NA
    }
    
    # Built-in function for comparison
    if (is.null(y)) {
      builtin_result &lt;- wilcox.test(x, mu=mu, alternative=alternative,
                                    conf.int=conf.int, conf.level=conf.level,
                                    exact=TRUE)
    } else {
      builtin_result &lt;- wilcox.test(x, y, paired=TRUE, alternative=alternative,
                                    conf.int=conf.int, conf.level=conf.level,
                                    exact=TRUE)
    }
    
    return(list(
      method = ifelse(is.null(y), 
                      &quot;One-sample Wilcoxon signed rank test&quot;,
                      &quot;Paired Wilcoxon signed rank test&quot;),
      statistic = V,
      parameter = n,
      p_value = p_value,
      normal_approximation = ifelse(n &gt;= 10, 
                                    list(z=z_stat, ev=EV, var=VarV),
                                    &quot;Use exact test&quot;),
      builtin_result = builtin_result,
      differences = d,
      ranks = ranks,
      signed_ranks = signed_ranks
    ))
  }
  
  # 2. Mann-Whitney U Test / Wilcoxon Rank Sum Test (non-parametric alternative to independent t-test)
  mann_whitney_test_custom &lt;- function(x, y, alternative=&quot;two.sided&quot;, 
                                       exact=TRUE, correct=TRUE) {
    n1 &lt;- length(x)
    n2 &lt;- length(y)
    
    # Combine and rank all observations
    combined &lt;- c(x, y)
    ranks &lt;- rank(combined)
    
    # Sum of ranks for each group
    R1 &lt;- sum(ranks[1:n1])
    R2 &lt;- sum(ranks[(n1+1):(n1+n2)])
    
    # U statistics
    U1 &lt;- R1 - n1 * (n1 + 1) / 2
    U2 &lt;- R2 - n2 * (n2 + 1) / 2
    
    # Test statistic (smaller U)
    U_stat &lt;- min(U1, U2)
    
    # Expected value and variance under H0
    EU &lt;- n1 * n2 / 2
    VarU &lt;- n1 * n2 * (n1 + n2 + 1) / 12
    
    # Continuity correction
    if (correct) {
      correction &lt;- 0.5
    } else {
      correction &lt;- 0
    }
    
    # Normal approximation
    if (n1 &gt;= 10 &amp;&amp; n2 &gt;= 10) {
      if (alternative == &quot;two.sided&quot;) {
        z_stat &lt;- (abs(U_stat - EU) - correction) / sqrt(VarU)
        p_value_normal &lt;- 2 * pnorm(-z_stat)
      } else if (alternative == &quot;greater&quot;) {
        z_stat &lt;- (U_stat - EU - correction) / sqrt(VarU)
        p_value_normal &lt;- pnorm(z_stat)
      } else {
        z_stat &lt;- (U_stat - EU + correction) / sqrt(VarU)
        p_value_normal &lt;- pnorm(z_stat, lower.tail=FALSE)
      }
    } else {
      z_stat &lt;- NA
      p_value_normal &lt;- NA
    }
    
    # Built-in function for comparison
    builtin_result &lt;- wilcox.test(x, y, alternative=alternative,
                                  exact=exact, correct=correct)
    
    return(list(
      method = &quot;Mann-Whitney U test / Wilcoxon rank sum test&quot;,
      statistic = U_stat,
      parameter = c(n1=n1, n2=n2),
      rank_sums = c(R1=R1, R2=R2),
      U_values = c(U1=U1, U2=U2),
      normal_approximation = if (n1 &gt;= 10 &amp;&amp; n2 &gt;= 10) {
        list(z=z_stat, p_value=p_value_normal, ev=EU, var=VarU)
      } else {
        &quot;Use exact test&quot;
      },
      builtin_result = builtin_result,
      combined_ranks = ranks
    ))
  }
  
  # 3. Kruskal-Wallis Test (non-parametric alternative to one-way ANOVA)
  kruskal_wallis_test_custom &lt;- function(x, g) {
    # x: response variable
    # g: grouping variable (factor)
    
    if (!is.factor(g)) {
      g &lt;- factor(g)
    }
    
    k &lt;- nlevels(g)
    n &lt;- length(x)
    
    # Overall ranks
    ranks &lt;- rank(x)
    
    # Sum of ranks for each group
    R_i &lt;- tapply(ranks, g, sum)
    n_i &lt;- table(g)
    
    # Test statistic
    H &lt;- (12 / (n * (n + 1))) * sum(R_i^2 / n_i) - 3 * (n + 1)
    
    # Correction for ties
    tie_correction &lt;- 1 - sum(table(ranks)^3 - table(ranks)) / (n^3 - n)
    H_corrected &lt;- H / tie_correction
    
    # Degrees of freedom
    df &lt;- k - 1
    
    # p-value (chi-square approximation)
    p_value &lt;- pchisq(H_corrected, df=df, lower.tail=FALSE)
    
    # Built-in function for comparison
    builtin_result &lt;- kruskal.test(x, g)
    
    return(list(
      method = &quot;Kruskal-Wallis rank sum test&quot;,
      statistic = H_corrected,
      parameter = df,
      p_value = p_value,
      group_stats = data.frame(
        Group = levels(g),
        n = as.numeric(n_i),
        Rank_Sum = as.numeric(R_i),
        Mean_Rank = as.numeric(R_i / n_i)
      ),
      builtin_result = builtin_result
    ))
  }
  
  # 4. Demonstration
  demonstrate_nonparametric_tests &lt;- function() {
    set.seed(123)
    
    # Generate non-normal data
    # Group 1: Exponential distribution
    group1 &lt;- rexp(20, rate=0.1)
    # Group 2: Exponential with different rate
    group2 &lt;- rexp(25, rate=0.15)
    # Group 3: Another exponential
    group3 &lt;- rexp(22, rate=0.12)
    
    # Paired data (non-normal differences)
    before &lt;- rlnorm(15, meanlog=2, sdlog=0.5)
    after &lt;- before * runif(15, min=0.8, max=1.2)
    
    # Run tests
    tests &lt;- list()
    
    # One-sample Wilcoxon
    tests$one_sample_wilcoxon &lt;- wilcoxon_signed_rank_test_custom(
      group1, mu=10)
    
    # Paired Wilcoxon
    tests$paired_wilcoxon &lt;- wilcoxon_signed_rank_test_custom(
      before, after)
    
    # Mann-Whitney U
    tests$mann_whitney &lt;- mann_whitney_test_custom(group1, group2)
    
    # Kruskal-Wallis
    all_groups &lt;- c(group1, group2, group3)
    group_labels &lt;- factor(rep(1:3, times=c(20, 25, 22)))
    tests$kruskal_wallis &lt;- kruskal_wallis_test_custom(all_groups, group_labels)
    
    # Visualization
    par(mfrow=c(2,3))
    
    # Q-Q plots for normality check
    qqnorm(group1, main=&quot;Q-Q Plot: Group 1&quot;)
    qqline(group1, col=&quot;red&quot;)
    
    qqnorm(group2, main=&quot;Q-Q Plot: Group 2&quot;)
    qqline(group2, col=&quot;red&quot;)
    
    qqnorm(group3, main=&quot;Q-Q Plot: Group 3&quot;)
    qqline(group3, col=&quot;red&quot;)
    
    # Boxplot of all groups
    boxplot(list(Group1=group1, Group2=group2, Group3=group3),
            main=&quot;Non-normal Distributions&quot;,
            ylab=&quot;Values&quot;, col=c(&quot;lightblue&quot;, &quot;lightgreen&quot;, &quot;lightpink&quot;),
            notch=TRUE)
    
    # ECDF comparison
    plot(ecdf(group1), main=&quot;ECDF Comparison&quot;,
         xlab=&quot;Values&quot;, ylab=&quot;Cumulative Probability&quot;,
         col=&quot;blue&quot;, lwd=2, xlim=range(c(group1, group2, group3)))
    lines(ecdf(group2), col=&quot;green&quot;, lwd=2)
    lines(ecdf(group3), col=&quot;red&quot;, lwd=2)
    legend(&quot;bottomright&quot;, legend=c(&quot;Group 1&quot;, &quot;Group 2&quot;, &quot;Group 3&quot;),
           col=c(&quot;blue&quot;, &quot;green&quot;, &quot;red&quot;), lwd=2)
    
    # Paired data plot
    plot(before, after, pch=19, col=&quot;purple&quot;,
         main=&quot;Paired Non-normal Data&quot;,
         xlab=&quot;Before&quot;, ylab=&quot;After&quot;)
    abline(0, 1, col=&quot;gray&quot;, lty=2)
    
    par(mfrow=c(1,1))
    
    # Test comparison table
    create_comparison_table &lt;- function(tests) {
      comparison_df &lt;- data.frame(
        Test = c(&quot;One-sample Wilcoxon&quot;, &quot;Paired Wilcoxon&quot;, 
                 &quot;Mann-Whitney U&quot;, &quot;Kruskal-Wallis&quot;),
        Statistic = c(
          round(tests$one_sample_wilcoxon$statistic, 2),
          round(tests$paired_wilcoxon$statistic, 2),
          round(tests$mann_whitney$statistic, 2),
          round(tests$kruskal_wallis$statistic, 2)
        ),
        P_Value = c(
          format.pval(tests$one_sample_wilcoxon$builtin_result$p.value, digits=3),
          format.pval(tests$paired_wilcoxon$builtin_result$p.value, digits=3),
          format.pval(tests$mann_whitney$builtin_result$p.value, digits=3),
          format.pval(tests$kruskal_wallis$builtin_result$p.value, digits=3)
        ),
        Alternative = c(
          tests$one_sample_wilcoxon$builtin_result$alternative,
          tests$paired_wilcoxon$builtin_result$alternative,
          tests$mann_whitney$builtin_result$alternative,
          &quot;Not all distributions equal&quot;
        ),
        Sample_Size = c(
          length(tests$one_sample_wilcoxon$differences),
          length(tests$paired_wilcoxon$differences),
          paste(length(group1), &quot;, &quot;, length(group2), sep=&quot;&quot;),
          paste(&quot;20, 25, 22&quot;, sep=&quot;&quot;)
        )
      )
      
      return(comparison_df)
    }
    
    comparison_table &lt;- create_comparison_table(tests)
    
    return(list(
      tests = tests,
      data = list(
        group1 = group1,
        group2 = group2,
        group3 = group3,
        before = before,
        after = after
      ),
      comparison = comparison_table
    ))
  }
  
  # Run demonstration
  demo_results &lt;- demonstrate_nonparametric_tests()
  
  return(list(
    wilcoxon_signed_rank = wilcoxon_signed_rank_test_custom,
    mann_whitney = mann_whitney_test_custom,
    kruskal_wallis = kruskal_wallis_test_custom,
    demonstration = demo_results
  ))
}

# Create and run non-parametric testing system
nonparametric_system &lt;- nonparametric_mean_tests()
print(nonparametric_system$demonstration$comparison)</code></pre>
            </div>
            

            <div class="special-block reference">
                <div class="special-label">Reference: Davies (2016) Chapter 14; Pawgi (2022) Chapter 9</div>
                <div class="special-content"></div>
            </div>
            
<hr class="content-hr">
</section>

            <section class="content-section" id="5-testing-proportions">
                <h2 class="section-heading"><strong>5. Testing Proportions</strong></h2>
            
</section>

            <section class="content-section" id="a-one-sample-proportion-test">
                <h3 class="section-heading"><strong>A. One-Sample Proportion Test</strong></h3>
            

            <div class="code-block">
                <pre><code class="language-r"># One-sample proportion tests
one_sample_proportion_tests &lt;- function() {
  # 1. Exact binomial test
  exact_binomial_test &lt;- function(x, n, p0, alternative=&quot;two.sided&quot;, 
                                  conf.level=0.95) {
    # x: number of successes
    # n: number of trials
    # p0: hypothesized proportion
    
    # Test statistic (number of successes)
    test_stat &lt;- x
    
    # p-value calculation
    if (alternative == &quot;two.sided&quot;) {
      # Probability of observing x or more extreme
      p_obs &lt;- dbinom(x, size=n, prob=p0)
      # Sum probabilities of all outcomes with probability &lt;= p_obs
      all_probs &lt;- dbinom(0:n, size=n, prob=p0)
      p_value &lt;- sum(all_probs[all_probs &lt;= p_obs])
    } else if (alternative == &quot;less&quot;) {
      p_value &lt;- pbinom(x, size=n, prob=p0)
    } else { # greater
      p_value &lt;- pbinom(x-1, size=n, prob=p0, lower.tail=FALSE)
    }
    
    # Confidence interval (Clopper-Pearson exact)
    alpha &lt;- 1 - conf.level
    if (alternative == &quot;two.sided&quot;) {
      ci_lower &lt;- qbeta(alpha/2, x, n - x + 1)
      ci_upper &lt;- qbeta(1 - alpha/2, x + 1, n - x)
    } else if (alternative == &quot;greater&quot;) {
      ci_lower &lt;- qbeta(alpha, x, n - x + 1)
      ci_upper &lt;- 1
    } else {
      ci_lower &lt;- 0
      ci_upper &lt;- qbeta(1 - alpha, x + 1, n - x)
    }
    
    # Handle edge cases
    if (x == 0) {
      ci_lower &lt;- 0
    }
    if (x == n) {
      ci_upper &lt;- 1
    }
    
    # Sample proportion
    p_hat &lt;- x / n
    
    return(list(
      method = &quot;Exact binomial test&quot;,
      statistic = test_stat,
      parameter = c(n=n, p0=p0),
      p_hat = p_hat,
      p_value = p_value,
      alternative = alternative,
      confidence_interval = c(ci_lower, ci_upper),
      conf_level = conf.level
    ))
  }
  
  # 2. Normal approximation (Z-test for proportion)
  proportion_z_test &lt;- function(x, n, p0, alternative=&quot;two.sided&quot;,
                                conf.level=0.95, correct=TRUE) {
    # Check normal approximation conditions
    condition1 &lt;- n * p0 &gt;= 10
    condition2 &lt;- n * (1 - p0) &gt;= 10
    
    if (!condition1 || !condition2) {
      warning(&quot;Normal approximation may not be accurate. Consider exact test.&quot;)
    }
    
    # Sample proportion
    p_hat &lt;- x / n
    
    # Standard error
    se &lt;- sqrt(p0 * (1 - p0) / n)
    
    # Test statistic (with continuity correction if requested)
    if (correct) {
      correction &lt;- 1 / (2 * n)
      if (alternative == &quot;greater&quot;) {
        z_stat &lt;- (p_hat - p0 - correction) / se
      } else if (alternative == &quot;less&quot;) {
        z_stat &lt;- (p_hat - p0 + correction) / se
      } else {
        z_stat &lt;- (abs(p_hat - p0) - correction) / se
      }
    } else {
      z_stat &lt;- (p_hat - p0) / se
    }
    
    # p-value
    if (alternative == &quot;two.sided&quot;) {
      p_value &lt;- 2 * pnorm(-abs(z_stat))
      z_critical &lt;- qnorm(1 - (1 - conf.level)/2)
    } else if (alternative == &quot;greater&quot;) {
      p_value &lt;- pnorm(z_stat, lower.tail=FALSE)
      z_critical &lt;- qnorm(conf.level)
    } else {
      p_value &lt;- pnorm(z_stat)
      z_critical &lt;- qnorm(1 - conf.level)
    }
    
    # Confidence interval (Wilson score interval)
    z &lt;- qnorm(1 - (1 - conf.level)/2)
    denominator &lt;- 1 + z^2 / n
    center &lt;- (p_hat + z^2/(2*n)) / denominator
    margin &lt;- (z * sqrt(p_hat*(1-p_hat)/n + z^2/(4*n^2))) / denominator
    
    ci &lt;- c(center - margin, center + margin)
    
    return(list(
      method = &quot;One-sample proportion test (normal approximation)&quot;,
      statistic = z_stat,
      p_hat = p_hat,
      p_value = p_value,
      alternative = alternative,
      confidence_interval = ci,
      conf_level = conf.level,
      normal_approximation_valid = condition1 &amp;&amp; condition2,
      standard_error = se
    ))
  }
  
  # 3. Built-in prop.test function (for comparison)
  use_prop_test &lt;- function(x, n, p0, alternative=&quot;two.sided&quot;, 
                            conf.level=0.95, correct=TRUE) {
    test_result &lt;- prop.test(x, n, p=p0, alternative=alternative,
                             conf.level=conf.level, correct=correct)
    return(test_result)
  }
  
  # 4. Demonstration
  demonstrate_proportion_tests &lt;- function() {
    # Example scenarios
    scenarios &lt;- list(
      list(name=&quot;Coin fairness&quot;, x=17, n=30, p0=0.5),
      list(name=&quot;Defect rate&quot;, x=3, n=100, p0=0.05),
      list(name=&quot;Success rate&quot;, x=45, n=50, p0=0.8),
      list(name=&quot;Rare event&quot;, x=1, n=200, p0=0.01)
    )
    
    results &lt;- list()
    
    for (i in seq_along(scenarios)) {
      scen &lt;- scenarios[[i]]
      
      # Exact test
      exact &lt;- exact_binomial_test(scen$x, scen$n, scen$p0)
      
      # Z-test without correction
      z_uncorrected &lt;- proportion_z_test(scen$x, scen$n, scen$p0, correct=FALSE)
      
      # Z-test with correction
      z_corrected &lt;- proportion_z_test(scen$x, scen$n, scen$p0, correct=TRUE)
      
      # Built-in test
      builtin &lt;- use_prop_test(scen$x, scen$n, scen$p0)
      
      results[[i]] &lt;- list(
        scenario = scen$name,
        parameters = c(x=scen$x, n=scen$n, p0=scen$p0, p_hat=scen$x/scen$n),
        exact_test = exact,
        z_uncorrected = z_uncorrected,
        z_corrected = z_corrected,
        builtin_test = builtin
      )
    }
    
    # Visualization
    par(mfrow=c(2,2))
    
    for (i in 1:4) {
      res &lt;- results[[i]]
      n &lt;- res$parameters[&quot;n&quot;]
      p0 &lt;- res$parameters[&quot;p0&quot;]
      x &lt;- res$parameters[&quot;x&quot;]
      p_hat &lt;- res$parameters[&quot;p_hat&quot;]
      
      # Binomial distribution under H0
      x_vals &lt;- 0:n
      probs &lt;- dbinom(x_vals, size=n, prob=p0)
      
      plot(x_vals, probs, type=&quot;h&quot;, lwd=2,
           main=paste(res$scenario, &quot;\np0=&quot;, p0, &quot;, p̂=&quot;, round(p_hat,3)),
           xlab=&quot;Number of Successes&quot;, ylab=&quot;Probability&quot;,
           col=ifelse(x_vals == x, &quot;red&quot;, &quot;gray&quot;),
           ylim=c(0, max(probs)*1.1))
      
      # Add observed value
      points(x, dbinom(x, n, p0), pch=19, col=&quot;red&quot;, cex=1.5)
      
      # Add normal approximation
      if (n*p0 &gt;= 10 &amp;&amp; n*(1-p0) &gt;= 10) {
        mu &lt;- n * p0
        sigma &lt;- sqrt(n * p0 * (1-p0))
        curve(dnorm(x, mean=mu, sd=sigma), add=TRUE, 
              col=&quot;blue&quot;, lwd=2, lty=2)
        legend(&quot;topright&quot;, legend=c(&quot;Binomial&quot;, &quot;Normal approx&quot;),
               col=c(&quot;gray&quot;, &quot;blue&quot;), lwd=2, lty=c(1,2))
      }
      
      # Add lines for p-value calculation
      if (i == 1) {  # Two-sided test
        # Find symmetric region
        lower_tail &lt;- qbinom(pbinom(x, n, p0)/2, n, p0)
        upper_tail &lt;- qbinom(1 - pbinom(x-1, n, p0)/2, n, p0)
        segments(lower_tail, 0, lower_tail, dbinom(lower_tail, n, p0),
                 col=&quot;red&quot;, lwd=2)
        segments(upper_tail, 0, upper_tail, dbinom(upper_tail, n, p0),
                 col=&quot;red&quot;, lwd=2)
      }
    }
    
    par(mfrow=c(1,1))
    
    # Create comparison table
    create_proportion_comparison &lt;- function(results) {
      comp_df &lt;- data.frame(
        Scenario = sapply(results, function(r) r$scenario),
        n = sapply(results, function(r) r$parameters[&quot;n&quot;]),
        p0 = sapply(results, function(r) r$parameters[&quot;p0&quot;]),
        p_hat = round(sapply(results, function(r) r$parameters[&quot;p_hat&quot;]), 3),
        Exact_P = sapply(results, function(r) 
          format.pval(r$exact_test$p_value, digits=3)),
        Z_Uncorrected_P = sapply(results, function(r) 
          format.pval(r$z_uncorrected$p_value, digits=3)),
        Z_Corrected_P = sapply(results, function(r) 
          format.pval(r$z_corrected$p_value, digits=3)),
        Builtin_P = sapply(results, function(r) 
          format.pval(r$builtin_test$p.value, digits=3)),
        Normal_Valid = sapply(results, function(r) 
          ifelse(r$z_uncorrected$normal_approximation_valid, &quot;Yes&quot;, &quot;No&quot;))
      )
      
      return(comp_df)
    }
    
    comparison_table &lt;- create_proportion_comparison(results)
    
    return(list(
      exact_test = exact_binomial_test,
      proportion_z_test = proportion_z_test,
      builtin_test = use_prop_test,
      results = results,
      comparison = comparison_table
    ))
  }
  
  # Run demonstration
  demo_results &lt;- demonstrate_proportion_tests()
  
  return(demo_results)
}

# Create and run proportion testing system
proportion_system &lt;- one_sample_proportion_tests()
print(proportion_system$comparison)</code></pre>
            </div>
            
</section>

            <section class="content-section" id="b-two-sample-proportion-test">
                <h3 class="section-heading"><strong>B. Two-Sample Proportion Test</strong></h3>
            

            <div class="code-block">
                <pre><code class="language-r"># Two-sample proportion tests
two_sample_proportion_tests &lt;- function() {
  # 1. Two-sample proportion test (normal approximation)
  two_sample_prop_test &lt;- function(x1, n1, x2, n2, 
                                   alternative=&quot;two.sided&quot;,
                                   conf.level=0.95, 
                                   pooled=TRUE, correct=TRUE) {
    
    # Sample proportions
    p1_hat &lt;- x1 / n1
    p2_hat &lt;- x2 / n2
    p_diff &lt;- p1_hat - p2_hat
    
    # Pooled proportion (if requested)
    if (pooled) {
      p_pooled &lt;- (x1 + x2) / (n1 + n2)
      se &lt;- sqrt(p_pooled * (1 - p_pooled) * (1/n1 + 1/n2))
    } else {
      se &lt;- sqrt(p1_hat * (1 - p1_hat) / n1 + p2_hat * (1 - p2_hat) / n2)
    }
    
    # Check normal approximation conditions
    conditions_met &lt;- all(c(n1*p1_hat, n1*(1-p1_hat), 
                            n2*p2_hat, n2*(1-p2_hat)) &gt;= 10)
    
    if (!conditions_met) {
      warning(&quot;Normal approximation may not be accurate&quot;)
    }
    
    # Test statistic (with continuity correction if requested)
    if (correct) {
      correction &lt;- 0.5 * (1/n1 + 1/n2)
      if (alternative == &quot;greater&quot;) {
        z_stat &lt;- (p_diff - correction) / se
      } else if (alternative == &quot;less&quot;) {
        z_stat &lt;- (p_diff + correction) / se
      } else {
        z_stat &lt;- (abs(p_diff) - correction) / se
      }
    } else {
      z_stat &lt;- p_diff / se
    }
    
    # p-value
    if (alternative == &quot;two.sided&quot;) {
      p_value &lt;- 2 * pnorm(-abs(z_stat))
      z_critical &lt;- qnorm(1 - (1 - conf.level)/2)
    } else if (alternative == &quot;greater&quot;) {
      p_value &lt;- pnorm(z_stat, lower.tail=FALSE)
      z_critical &lt;- qnorm(conf.level)
    } else {
      p_value &lt;- pnorm(z_stat)
      z_critical &lt;- qnorm(1 - conf.level)
    }
    
    # Confidence interval for difference
    if (!pooled) {
      se_ci &lt;- sqrt(p1_hat*(1-p1_hat)/n1 + p2_hat*(1-p2_hat)/n2)
    } else {
      se_ci &lt;- se
    }
    
    margin &lt;- z_critical * se_ci
    
    if (alternative == &quot;two.sided&quot;) {
      ci &lt;- p_diff + c(-1, 1) * margin
    } else if (alternative == &quot;greater&quot;) {
      ci &lt;- c(p_diff - margin, Inf)
    } else {
      ci &lt;- c(-Inf, p_diff + margin)
    }
    
    # Relative risk and odds ratio
    if (x1 &gt; 0 &amp;&amp; x2 &gt; 0) {
      rr &lt;- p1_hat / p2_hat
      or &lt;- (x1 * (n2 - x2)) / (x2 * (n1 - x1))
    } else {
      rr &lt;- NA
      or &lt;- NA
    }
    
    return(list(
      method = ifelse(pooled, 
                      &quot;Two-sample proportion test (pooled)&quot;,
                      &quot;Two-sample proportion test (unpooled)&quot;),
      statistic = z_stat,
      p1_hat = p1_hat,
      p2_hat = p2_hat,
      difference = p_diff,
      p_value = p_value,
      alternative = alternative,
      confidence_interval = ci,
      conf_level = conf.level,
      normal_approximation_valid = conditions_met,
      relative_risk = rr,
      odds_ratio = or,
      sample_sizes = c(n1=n1, n2=n2),
      successes = c(x1=x1, x2=x2)
    ))
  }
  
  # 2. Fisher&#x27;s exact test (for small samples or extreme proportions)
  fishers_exact_test_custom &lt;- function(x1, n1, x2, n2, 
                                        alternative=&quot;two.sided&quot;) {
    
    # Create contingency table
    table &lt;- matrix(c(x1, n1 - x1, x2, n2 - x2), nrow=2, byrow=TRUE)
    
    # Hypergeometric probability of observed table
    hypergeom_prob &lt;- function(a, b, c, d) {
      choose(a+b, a) * choose(c+d, c) / choose(a+b+c+d, a+c)
    }
    
    prob_observed &lt;- hypergeom_prob(x1, n1-x1, x2, n2-x2)
    
    # All possible tables with same margins
    row1_sum &lt;- x1 + (n1 - x1)
    row2_sum &lt;- x2 + (n2 - x2)
    col1_sum &lt;- x1 + x2
    col2_sum &lt;- (n1 - x1) + (n2 - x2)
    
    min_a &lt;- max(0, col1_sum - row2_sum)
    max_a &lt;- min(row1_sum, col1_sum)
    
    # Calculate probabilities for all tables
    all_probs &lt;- sapply(min_a:max_a, function(a) {
      b &lt;- row1_sum - a
      c &lt;- col1_sum - a
      d &lt;- row2_sum - c
      hypergeom_prob(a, b, c, d)
    })
    
    # p-value calculation
    if (alternative == &quot;two.sided&quot;) {
      p_value &lt;- sum(all_probs[all_probs &lt;= prob_observed])
    } else if (alternative == &quot;less&quot;) {
      # Probability of table as or more extreme in left tail
      extreme_tables &lt;- which((min_a:max_a) &lt;= x1)
      p_value &lt;- sum(all_probs[extreme_tables])
    } else { # greater
      # Probability of table as or more extreme in right tail
      extreme_tables &lt;- which((min_a:max_a) &gt;= x1)
      p_value &lt;- sum(all_probs[extreme_tables])
    }
    
    # Odds ratio
    or &lt;- (x1 * (n2 - x2)) / (x2 * (n1 - x1))
    
    # Built-in function for comparison
    builtin_result &lt;- fisher.test(table, alternative=alternative)
    
    return(list(
      method = &quot;Fisher&#x27;s exact test&quot;,
      contingency_table = table,
      observed_probability = prob_observed,
      p_value = p_value,
      alternative = alternative,
      odds_ratio = or,
      builtin_result = builtin_result
    ))
  }
  
  # 3. Chi-square test for independence
  chi2_independence_test &lt;- function(x1, n1, x2, n2, correct=TRUE) {
    # Create contingency table
    table &lt;- matrix(c(x1, n1 - x1, x2, n2 - x2), nrow=2, byrow=TRUE)
    
    # Expected frequencies
    row_sums &lt;- rowSums(table)
    col_sums &lt;- colSums(table)
    total &lt;- sum(table)
    
    expected &lt;- outer(row_sums, col_sums) / total
    
    # Chi-square statistic (with Yates correction if requested)
    if (correct) {
      chi2_stat &lt;- sum((abs(table - expected) - 0.5)^2 / expected)
    } else {
      chi2_stat &lt;- sum((table - expected)^2 / expected)
    }
    
    # Degrees of freedom
    df &lt;- (nrow(table) - 1) * (ncol(table) - 1)
    
    # p-value
    p_value &lt;- pchisq(chi2_stat, df=df, lower.tail=FALSE)
    
    # Built-in function for comparison
    builtin_result &lt;- chisq.test(table, correct=correct)
    
    return(list(
      method = ifelse(correct, 
                      &quot;Chi-square test with Yates correction&quot;,
                      &quot;Chi-square test without correction&quot;),
      statistic = chi2_stat,
      parameter = df,
      p_value = p_value,
      contingency_table = table,
      expected_frequencies = expected,
      residuals = (table - expected) / sqrt(expected),
      builtin_result = builtin_result
    ))
  }
  
  # 4. Demonstration
  demonstrate_two_sample_prop_tests &lt;- function() {
    # Example scenarios
    scenarios &lt;- list(
      list(name=&quot;Drug A vs Drug B&quot;, 
           x1=45, n1=50, x2=35, n2=50),
      list(name=&quot;New vs Old process&quot;, 
           x1=8, n1=100, x2=15, n2=100),
      list(name=&quot;Small sample test&quot;, 
           x1=2, n1=10, x2=7, n2=10),
      list(name=&quot;Large sample, small difference&quot;, 
           x1=105, n1=200, x2=95, n2=200)
    )
    
    results &lt;- list()
    
    for (i in seq_along(scenarios)) {
      scen &lt;- scenarios[[i]]
      
      # Pooled Z-test
      pooled_z &lt;- two_sample_prop_test(scen$x1, scen$n1, scen$x2, scen$n2,
                                       pooled=TRUE, correct=TRUE)
      
      # Unpooled Z-test
      unpooled_z &lt;- two_sample_prop_test(scen$x1, scen$n1, scen$x2, scen$n2,
                                         pooled=FALSE, correct=TRUE)
      
      # Fisher&#x27;s exact test
      fisher_exact &lt;- fishers_exact_test_custom(scen$x1, scen$n1, 
                                                scen$x2, scen$n2)
      
      # Chi-square test
      chi2_test &lt;- chi2_independence_test(scen$x1, scen$n1, scen$x2, scen$n2)
      
      results[[i]] &lt;- list(
        scenario = scen$name,
        parameters = c(x1=scen$x1, n1=scen$n1, p1=scen$x1/scen$n1,
                       x2=scen$x2, n2=scen$n2, p2=scen$x2/scen$n2),
        pooled_z_test = pooled_z,
        unpooled_z_test = unpooled_z,
        fisher_test = fisher_exact,
        chi2_test = chi2_test
      )
    }
    
    # Visualization
    par(mfrow=c(2,2))
    
    for (i in 1:4) {
      res &lt;- results[[i]]
      p1 &lt;- res$parameters[&quot;p1&quot;]
      p2 &lt;- res$parameters[&quot;p2&quot;]
      n1 &lt;- res$parameters[&quot;n1&quot;]
      n2 &lt;- res$parameters[&quot;n2&quot;]
      
      # Create bar plot
      proportions &lt;- c(p1, p2)
      groups &lt;- c(&quot;Group 1&quot;, &quot;Group 2&quot;)
      
      # Calculate confidence intervals
      ci1 &lt;- binom.test(res$parameters[&quot;x1&quot;], n1)$conf.int
      ci2 &lt;- binom.test(res$parameters[&quot;x2&quot;], n2)$conf.int
      
      bp &lt;- barplot(proportions, names.arg=groups,
                    main=paste(res$scenario, &quot;\n&quot;, 
                               &quot;p1=&quot;, round(p1,3), &quot;, p2=&quot;, round(p2,3)),
                    ylab=&quot;Proportion&quot;, ylim=c(0, max(proportions)*1.3),
                    col=c(&quot;lightblue&quot;, &quot;lightgreen&quot;))
      
      # Add confidence intervals
      arrows(bp[1], ci1[1], bp[1], ci1[2], 
             angle=90, code=3, length=0.1, lwd=2)
      arrows(bp[2], ci2[1], bp[2], ci2[2],
             angle=90, code=3, length=0.1, lwd=2)
      
      # Add sample sizes
      text(bp, max(proportions)*1.1,
           paste(&quot;n=&quot;, c(n1, n2), sep=&quot;&quot;),
           cex=0.8)
      
      # Add difference line if significant
      p_val &lt;- res$pooled_z_test$p_value
      if (p_val &lt; 0.05) {
        text(mean(bp), max(proportions)*1.2,
             paste(&quot;p =&quot;, format.pval(p_val, digits=3)),
             col=&quot;red&quot;, font=2)
      }
    }
    
    par(mfrow=c(1,1))
    
    # Create comparison table
    create_two_sample_comparison &lt;- function(results) {
      comp_df &lt;- data.frame(
        Scenario = sapply(results, function(r) r$scenario),
        p1 = round(sapply(results, function(r) r$parameters[&quot;p1&quot;]), 3),
        p2 = round(sapply(results, function(r) r$parameters[&quot;p2&quot;]), 3),
        Pooled_Z_P = sapply(results, function(r) 
          format.pval(r$pooled_z_test$p_value, digits=3)),
        Unpooled_Z_P = sapply(results, function(r) 
          format.pval(r$unpooled_z_test$p_value, digits=3)),
        Fisher_P = sapply(results, function(r) 
          format.pval(r$fisher_test$p_value, digits=3)),
        Chi2_P = sapply(results, function(r) 
          format.pval(r$chi2_test$p_value, digits=3)),
        Normal_Valid = sapply(results, function(r) 
          ifelse(r$pooled_z_test$normal_approximation_valid, &quot;Yes&quot;, &quot;No&quot;))
      )
      
      return(comp_df)
    }
    
    comparison_table &lt;- create_two_sample_comparison(results)
    
    return(list(
      pooled_test = two_sample_prop_test,
      fisher_test = fishers_exact_test_custom,
      chi2_test = chi2_independence_test,
      results = results,
      comparison = comparison_table
    ))
  }
  
  # Run demonstration
  demo_results &lt;- demonstrate_two_sample_prop_tests()
  
  return(demo_results)
}

# Create and run two-sample proportion testing system
two_sample_prop_system &lt;- two_sample_proportion_tests()
print(two_sample_prop_system$comparison)</code></pre>
            </div>
            

            <div class="special-block reference">
                <div class="special-label">Reference: Davies (2016) Chapter 14; Pawgi (2022) Chapter 10</div>
                <div class="special-content"></div>
            </div>
            
<hr class="content-hr">
</section>

            <section class="content-section" id="6-testing-categorical-variables">
                <h2 class="section-heading"><strong>6. Testing Categorical Variables</strong></h2>
            
</section>

            <section class="content-section" id="a-chi-square-goodness-of-fit-test">
                <h3 class="section-heading"><strong>A. Chi-square Goodness-of-Fit Test</strong></h3>
            

            <div class="code-block">
                <pre><code class="language-r"># Chi-square goodness-of-fit test
chi2_goodness_of_fit &lt;- function() {
  # 1. Chi-square goodness-of-fit test
  chi2_gof_test &lt;- function(observed, expected=NULL, p=NULL) {
    # observed: vector of observed frequencies
    # expected: vector of expected frequencies (if provided)
    # p: vector of probabilities (if expected not provided)
    
    n &lt;- sum(observed)
    k &lt;- length(observed)
    
    # Calculate expected frequencies
    if (is.null(expected)) {
      if (is.null(p)) {
        # Assume equal probabilities
        p &lt;- rep(1/k, k)
      }
      expected &lt;- n * p
    } else {
      if (length(expected) != length(observed)) {
        stop(&quot;Observed and expected must have same length&quot;)
      }
      p &lt;- expected / sum(expected)
    }
    
    # Check assumptions
    min_expected &lt;- min(expected)
    if (min_expected &lt; 5) {
      warning(&quot;Some expected frequencies are less than 5. Consider combining categories.&quot;)
    }
    
    # Calculate chi-square statistic
    chi2_stat &lt;- sum((observed - expected)^2 / expected)
    
    # Degrees of freedom
    df &lt;- k - 1 - (ifelse(is.null(p), 0, 
                          sum(p == 1/k)))  # Adjust if p estimated
    
    # p-value
    p_value &lt;- pchisq(chi2_stat, df=df, lower.tail=FALSE)
    
    # Contributions to chi-square
    contributions &lt;- (observed - expected)^2 / expected
    
    # Standardized residuals
    residuals &lt;- (observed - expected) / sqrt(expected)
    
    # Built-in function for comparison
    if (is.null(p)) {
      builtin_result &lt;- chisq.test(observed, p=p)
    } else {
      builtin_result &lt;- chisq.test(observed, p=p)
    }
    
    return(list(
      method = &quot;Chi-square goodness-of-fit test&quot;,
      statistic = chi2_stat,
      parameter = df,
      p_value = p_value,
      observed = observed,
      expected = expected,
      probabilities = p,
      contributions = contributions,
      residuals = residuals,
      assumptions = list(
        total_observations = n,
        categories = k,
        min_expected = min_expected,
        assumption_met = min_expected &gt;= 5
      ),
      builtin_result = builtin_result
    ))
  }
  
  # 2. Power analysis for chi-square test
  chi2_power_analysis &lt;- function(effect_size, n, df, alpha=0.05) {
    # effect_size: Cohen&#x27;s w
    # n: sample size
    # df: degrees of freedom
    
    # Non-centrality parameter
    lambda &lt;- n * effect_size^2
    
    # Critical value
    critical_value &lt;- qchisq(1 - alpha, df=df)
    
    # Power
    power &lt;- pchisq(critical_value, df=df, ncp=lambda, lower.tail=FALSE)
    
    return(list(
      effect_size = effect_size,
      sample_size = n,
      df = df,
      alpha = alpha,
      noncentrality = lambda,
      critical_value = critical_value,
      power = power
    ))
  }
  
  # 3. Demonstration
  demonstrate_gof_tests &lt;- function() {
    # Example 1: Dice fairness test
    dice_rolls &lt;- c(22, 19, 18, 21, 24, 16)  # Observed frequencies
    dice_test &lt;- chi2_gof_test(dice_rolls, p=rep(1/6, 6))
    
    # Example 2: Mendel&#x27;s pea experiment
    mendel_observed &lt;- c(315, 108, 101, 32)  # Round yellow, round green, wrinkled yellow, wrinkled green
    mendel_expected &lt;- c(9/16, 3/16, 3/16, 1/16) * sum(mendel_observed)
    mendel_test &lt;- chi2_gof_test(mendel_observed, p=c(9/16, 3/16, 3/16, 1/16))
    
    # Example 3: Birth month distribution
    births &lt;- c(78, 65, 83, 91, 88, 102, 97, 85, 90, 76, 68, 77)
    birth_test &lt;- chi2_gof_test(births)  # Test for uniform distribution
    
    # Visualization
    par(mfrow=c(2,2))
    
    # Dice test visualization
    categories &lt;- 1:6
    barplot(rbind(dice_test$observed, dice_test$expected),
            beside=TRUE,
            names.arg=categories,
            main=&quot;Dice Fairness Test\n(Observed vs Expected)&quot;,
            xlab=&quot;Dice Face&quot;,
            ylab=&quot;Frequency&quot;,
            col=c(&quot;lightblue&quot;, &quot;lightgreen&quot;),
            legend=c(&quot;Observed&quot;, &quot;Expected&quot;))
    abline(h=sum(dice_rolls)/6, lty=2, col=&quot;red&quot;)
    
    # Contributions to chi-square (dice)
    barplot(dice_test$contributions,
            names.arg=categories,
            main=&quot;Contributions to χ²&quot;,
            xlab=&quot;Dice Face&quot;,
            ylab=&quot;(O-E)²/E&quot;,
            col=ifelse(dice_test$contributions &gt; qchisq(0.95, 5)/6, 
                       &quot;red&quot;, &quot;lightblue&quot;))
    abline(h=qchisq(0.95, 5)/6, lty=2, col=&quot;red&quot;)
    
    # Residuals plot
    plot(categories, dice_test$residuals,
         type=&quot;h&quot;, lwd=3,
         main=&quot;Standardized Residuals&quot;,
         xlab=&quot;Category&quot;,
         ylab=&quot;(O-E)/√E&quot;,
         ylim=c(-max(abs(dice_test$residuals))*1.2, 
                max(abs(dice_test$residuals))*1.2))
    points(categories, dice_test$residuals, pch=19, col=&quot;blue&quot;)
    abline(h=0, col=&quot;gray&quot;)
    abline(h=c(-2, 2), col=&quot;red&quot;, lty=2)
    
    # Power analysis for different effect sizes
    effect_sizes &lt;- seq(0.1, 0.5, by=0.05)
    powers &lt;- sapply(effect_sizes, function(w) 
      chi2_power_analysis(w, n=100, df=5)$power)
    
    plot(effect_sizes, powers, type=&quot;b&quot;,
         main=&quot;Power Analysis for χ² Test\n(n=100, df=5, α=0.05)&quot;,
         xlab=&quot;Effect Size (Cohen&#x27;s w)&quot;,
         ylab=&quot;Power&quot;,
         pch=19, col=&quot;darkgreen&quot;, lwd=2)
    abline(h=0.8, lty=2, col=&quot;red&quot;)
    abline(v=0.3, lty=2, col=&quot;blue&quot;)
    
    par(mfrow=c(1,1))
    
    # Create results table
    create_gof_results_table &lt;- function() {
      results_df &lt;- data.frame(
        Test = c(&quot;Dice Fairness&quot;, &quot;Mendel&#x27;s Peas&quot;, &quot;Birth Months&quot;),
        χ² = c(round(dice_test$statistic, 3),
               round(mendel_test$statistic, 3),
               round(birth_test$statistic, 3)),
        df = c(dice_test$parameter,
               mendel_test$parameter,
               birth_test$parameter),
        p_value = c(format.pval(dice_test$p_value, digits=3),
                    format.pval(mendel_test$p_value, digits=3),
                    format.pval(birth_test$p_value, digits=3)),
        Min_Expected = c(round(min(dice_test$expected), 2),
                         round(min(mendel_test$expected), 2),
                         round(min(birth_test$expected), 2)),
        Assumption_Met = c(ifelse(dice_test$assumptions$assumption_met, 
                                  &quot;Yes&quot;, &quot;No&quot;),
                           ifelse(mendel_test$assumptions$assumption_met,
                                  &quot;Yes&quot;, &quot;No&quot;),
                           ifelse(birth_test$assumptions$assumption_met,
                                  &quot;Yes&quot;, &quot;No&quot;))
      )
      
      return(results_df)
    }
    
    results_table &lt;- create_gof_results_table()
    
    return(list(
      dice_test = dice_test,
      mendel_test = mendel_test,
      birth_test = birth_test,
      power_function = chi2_power_analysis,
      results_table = results_table
    ))
  }
  
  # Run demonstration
  demo_results &lt;- demonstrate_gof_tests()
  
  return(demo_results)
}

# Create and run GOF testing system
gof_system &lt;- chi2_goodness_of_fit()
print(gof_system$results_table)</code></pre>
            </div>
            
</section>

            <section class="content-section" id="b-chi-square-test-of-independence">
                <h3 class="section-heading"><strong>B. Chi-square Test of Independence</strong></h3>
            

            <div class="code-block">
                <pre><code class="language-r"># Chi-square test of independence
chi2_independence_analysis &lt;- function() {
  # 1. Comprehensive chi-square test of independence
  chi2_independence_test_comprehensive &lt;- function(contingency_table) {
    # contingency_table: matrix of observed frequencies
    
    # Check input
    if (!is.matrix(contingency_table)) {
      stop(&quot;Input must be a matrix&quot;)
    }
    
    n &lt;- sum(contingency_table)
    n_rows &lt;- nrow(contingency_table)
    n_cols &lt;- ncol(contingency_table)
    
    # Expected frequencies
    row_sums &lt;- rowSums(contingency_table)
    col_sums &lt;- colSums(contingency_table)
    expected &lt;- outer(row_sums, col_sums) / n
    
    # Check assumptions
    min_expected &lt;- min(expected)
    assumption_warning &lt;- &quot;&quot;
    if (min_expected &lt; 5) {
      assumption_warning &lt;- &quot;Some expected frequencies &lt; 5. Consider Fisher&#x27;s exact test.&quot;
      warning(assumption_warning)
    }
    
    if (any(expected &lt; 1)) {
      assumption_warning &lt;- paste(assumption_warning, 
                                  &quot;Some expected frequencies &lt; 1.&quot;, sep=&quot; &quot;)
      warning(&quot;Some expected frequencies &lt; 1.&quot;)
    }
    
    # Chi-square statistic (with Yates correction for 2x2 tables)
    if (n_rows == 2 &amp;&amp; n_cols == 2) {
      # Yates continuity correction
      chi2_stat &lt;- sum((abs(contingency_table - expected) - 0.5)^2 / expected)
      method_name &lt;- &quot;Chi-square test of independence with Yates continuity correction&quot;
    } else {
      chi2_stat &lt;- sum((contingency_table - expected)^2 / expected)
      method_name &lt;- &quot;Chi-square test of independence&quot;
    }
    
    # Degrees of freedom
    df &lt;- (n_rows - 1) * (n_cols - 1)
    
    # p-value
    p_value &lt;- pchisq(chi2_stat, df=df, lower.tail=FALSE)
    
    # Contributions to chi-square
    contributions &lt;- (contingency_table - expected)^2 / expected
    
    # Standardized residuals
    residuals &lt;- (contingency_table - expected) / sqrt(expected)
    
    # Adjusted residuals (for post-hoc analysis)
    row_props &lt;- row_sums / n
    col_props &lt;- col_sums / n
    adj_residuals &lt;- matrix(0, n_rows, n_cols)
    
    for (i in 1:n_rows) {
      for (j in 1:n_cols) {
        adj_residuals[i, j] &lt;- (contingency_table[i, j] - expected[i, j]) /
          sqrt(expected[i, j] * (1 - row_props[i]) * (1 - col_props[j]))
      }
    }
    
    # Cramer&#x27;s V (effect size)
    cramers_v &lt;- sqrt(chi2_stat / (n * min(n_rows - 1, n_cols - 1)))
    
    # Phi coefficient (for 2x2 tables)
    if (n_rows == 2 &amp;&amp; n_cols == 2) {
      phi &lt;- sqrt(chi2_stat / n)
      if ((contingency_table[1,1] * contingency_table[2,2]) &lt; 
          (contingency_table[1,2] * contingency_table[2,1])) {
        phi &lt;- -phi
      }
    } else {
      phi &lt;- NA
    }
    
    # Odds ratios (for 2x2 tables)
    if (n_rows == 2 &amp;&amp; n_cols == 2) {
      odds_ratio &lt;- (contingency_table[1,1] * contingency_table[2,2]) /
        (contingency_table[1,2] * contingency_table[2,1])
      
      # Confidence interval for odds ratio
      log_or &lt;- log(odds_ratio)
      se_log_or &lt;- sqrt(sum(1/contingency_table))
      z &lt;- qnorm(0.975)
      ci_log_or &lt;- log_or + c(-1, 1) * z * se_log_or
      ci_or &lt;- exp(ci_log_or)
    } else {
      odds_ratio &lt;- NA
      ci_or &lt;- c(NA, NA)
    }
    
    # Built-in function for comparison
    builtin_result &lt;- chisq.test(contingency_table, correct=(n_rows==2 &amp;&amp; n_cols==2))
    
    return(list(
      method = method_name,
      statistic = chi2_stat,
      parameter = df,
      p_value = p_value,
      contingency_table = contingency_table,
      expected = expected,
      row_sums = row_sums,
      col_sums = col_sums,
      contributions = contributions,
      residuals = residuals,
      adjusted_residuals = adj_residuals,
      effect_sizes = list(
        cramers_v = cramers_v,
        phi = phi,
        interpretation = ifelse(is.na(cramers_v), NA,
                               ifelse(cramers_v &lt; 0.1, &quot;Very small&quot;,
                                      ifelse(cramers_v &lt; 0.3, &quot;Small&quot;,
                                             ifelse(cramers_v &lt; 0.5, &quot;Medium&quot;, &quot;Large&quot;))))
      ),
      odds_ratio = odds_ratio,
      odds_ratio_ci = ci_or,
      assumptions = list(
        total_observations = n,
        min_expected = min_expected,
        assumption_met = min_expected &gt;= 5,
        warning = assumption_warning
      ),
      builtin_result = builtin_result
    ))
  }
  
  # 2. Demonstration with various contingency tables
  demonstrate_independence_tests &lt;- function() {
    # Example 1: Smoking and lung cancer (2x2)
    smoking_table &lt;- matrix(c(688, 650, 21, 59),
                           nrow=2, byrow=TRUE,
                           dimnames=list(Smoking=c(&quot;Yes&quot;, &quot;No&quot;),
                                         Cancer=c(&quot;Yes&quot;, &quot;No&quot;)))
    
    # Example 2: Education and income (3x3)
    education_table &lt;- matrix(c(25, 40, 15,
                                30, 60, 30,
                                45, 50, 55),
                             nrow=3, byrow=TRUE,
                             dimnames=list(Education=c(&quot;High&quot;, &quot;Medium&quot;, &quot;Low&quot;),
                                           Income=c(&quot;High&quot;, &quot;Medium&quot;, &quot;Low&quot;)))
    
    # Example 3: Small sample (2x2) - for Fisher&#x27;s exact test comparison
    small_table &lt;- matrix(c(3, 1, 1, 5),
                         nrow=2, byrow=TRUE,
                         dimnames=list(Treatment=c(&quot;A&quot;, &quot;B&quot;),
                                       Outcome=c(&quot;Success&quot;, &quot;Failure&quot;)))
    
    # Run tests
    tests &lt;- list(
      smoking = chi2_independence_test_comprehensive(smoking_table),
      education = chi2_independence_test_comprehensive(education_table),
      small = chi2_independence_test_comprehensive(small_table)
    )
    
    # Visualization
    par(mfrow=c(3,3))
    
    # Plot 1: Smoking data - observed vs expected
    barplot(tests$smoking$contingency_table,
            beside=TRUE,
            main=&quot;Smoking vs Cancer\n(Observed)&quot;,
            xlab=&quot;Cancer&quot;, ylab=&quot;Count&quot;,
            col=c(&quot;red&quot;, &quot;blue&quot;),
            legend=rownames(smoking_table))
    
    barplot(tests$smoking$expected,
            beside=TRUE,
            main=&quot;Smoking vs Cancer\n(Expected under independence)&quot;,
            xlab=&quot;Cancer&quot;, ylab=&quot;Count&quot;,
            col=c(&quot;red&quot;, &quot;blue&quot;))
    
    # Plot 2: Contributions to chi-square (smoking)
    contrib_matrix &lt;- tests$smoking$contributions
    image(1:ncol(contrib_matrix), 1:nrow(contrib_matrix),
          t(contrib_matrix[nrow(contrib_matrix):1, ]),
          col=heat.colors(12),
          main=&quot;Contributions to χ²\n(Smoking vs Cancer)&quot;,
          xlab=&quot;Cancer&quot;, ylab=&quot;Smoking&quot;,
          axes=FALSE)
    axis(1, at=1:ncol(contrib_matrix), labels=colnames(contrib_matrix))
    axis(2, at=1:nrow(contrib_matrix), 
         labels=rev(rownames(contrib_matrix)))
    
    # Plot 3: Education data mosaic plot
    # install.packages(&quot;vcd&quot;)
    library(vcd)
    mosaic(education_table,
           main=&quot;Education vs Income&quot;,
           labeling_args=list(set_varnames=list(Education=&quot;Education Level&quot;,
                                                Income=&quot;Income Level&quot;)),
           shade=TRUE, legend=TRUE)
    
    # Plot 4: Adjusted residuals (education)
    adj_res &lt;- tests$education$adjusted_residuals
    image(1:ncol(adj_res), 1:nrow(adj_res),
          t(adj_res[nrow(adj_res):1, ]),
          col=colorRampPalette(c(&quot;blue&quot;, &quot;white&quot;, &quot;red&quot;))(12),
          main=&quot;Adjusted Residuals\n(Education vs Income)&quot;,
          xlab=&quot;Income&quot;, ylab=&quot;Education&quot;,
          axes=FALSE, zlim=c(-3, 3))
    axis(1, at=1:ncol(adj_res), labels=colnames(adj_res))
    axis(2, at=1:nrow(adj_res), labels=rev(rownames(adj_res)))
    contour(1:ncol(adj_res), 1:nrow(adj_res),
            t(adj_res[nrow(adj_res):1, ]),
            add=TRUE, levels=c(-1.96, 1.96),
            drawlabels=FALSE, col=&quot;black&quot;, lwd=2)
    
    # Plot 5: Small sample data
    barplot(tests$small$contingency_table,
            beside=TRUE,
            main=&quot;Small Sample (2x2)\nObserved Frequencies&quot;,
            xlab=&quot;Outcome&quot;, ylab=&quot;Count&quot;,
            col=c(&quot;lightblue&quot;, &quot;lightgreen&quot;),
            legend=rownames(small_table))
    
    # Plot 6: Power analysis for different table sizes
    effect_sizes &lt;- seq(0.1, 0.5, by=0.05)
    powers_2x2 &lt;- sapply(effect_sizes, function(w) 
      pwr.chisq.test(w=w, N=100, df=1, sig.level=0.05)$power)
    powers_3x3 &lt;- sapply(effect_sizes, function(w) 
      pwr.chisq.test(w=w, N=100, df=4, sig.level=0.05)$power)
    
    plot(effect_sizes, powers_2x2, type=&quot;b&quot;,
         col=&quot;blue&quot;, pch=19, lwd=2,
         main=&quot;Power Analysis\n(α=0.05, N=100)&quot;,
         xlab=&quot;Effect Size (Cohen&#x27;s w)&quot;,
         ylab=&quot;Power&quot;, ylim=c(0, 1))
    lines(effect_sizes, powers_3x3, type=&quot;b&quot;,
          col=&quot;red&quot;, pch=17, lwd=2)
    abline(h=0.8, lty=2, col=&quot;gray&quot;)
    legend(&quot;bottomright&quot;,
           legend=c(&quot;2x2 table (df=1)&quot;, &quot;3x3 table (df=4)&quot;),
           col=c(&quot;blue&quot;, &quot;red&quot;), pch=c(19,17), lwd=2)
    
    # Plot 7: Cramer&#x27;s V interpretation
    v_values &lt;- seq(0, 1, length=100)
    interpretations &lt;- cut(v_values,
                          breaks=c(0, 0.1, 0.3, 0.5, 1),
                          labels=c(&quot;Very small&quot;, &quot;Small&quot;, &quot;Medium&quot;, &quot;Large&quot;))
    
    plot(v_values, as.numeric(interpretations), type=&quot;n&quot;,
         main=&quot;Cramer&#x27;s V Interpretation&quot;,
         xlab=&quot;Cramer&#x27;s V&quot;, ylab=&quot;Effect Size&quot;,
         yaxt=&quot;n&quot;)
    rect(0, 0.5, 0.1, 1.5, col=&quot;lightblue&quot;, border=NA)
    rect(0.1, 1.5, 0.3, 2.5, col=&quot;lightgreen&quot;, border=NA)
    rect(0.3, 2.5, 0.5, 3.5, col=&quot;yellow&quot;, border=NA)
    rect(0.5, 3.5, 1, 4.5, col=&quot;orange&quot;, border=NA)
    axis(2, at=1:4, labels=c(&quot;Very small&quot;, &quot;Small&quot;, &quot;Medium&quot;, &quot;Large&quot;))
    abline(v=tests$smoking$effect_sizes$cramers_v, 
           col=&quot;red&quot;, lwd=2, lty=2)
    text(tests$smoking$effect_sizes$cramers_v, 4,
         paste(&quot;Smoking study\nV=&quot;, 
               round(tests$smoking$effect_sizes$cramers_v, 3)),
         pos=4, col=&quot;red&quot;)
    
    par(mfrow=c(1,1))
    
    # Create results summary
    create_independence_results_table &lt;- function(tests) {
      results_df &lt;- data.frame(
        Study = c(&quot;Smoking vs Cancer&quot;, &quot;Education vs Income&quot;, &quot;Small Sample&quot;),
        Table_Size = c(&quot;2x2&quot;, &quot;3x3&quot;, &quot;2x2&quot;),
        χ² = c(round(tests$smoking$statistic, 3),
               round(tests$education$statistic, 3),
               round(tests$small$statistic, 3)),
        df = c(tests$smoking$parameter,
               tests$education$parameter,
               tests$small$parameter),
        p_value = c(format.pval(tests$smoking$p_value, digits=3),
                    format.pval(tests$education$p_value, digits=3),
                    format.pval(tests$small$p_value, digits=3)),
        Cramers_V = c(round(tests$smoking$effect_sizes$cramers_v, 3),
                      round(tests$education$effect_sizes$cramers_v, 3),
                      round(tests$small$effect_sizes$cramers_v, 3)),
        Effect_Size = c(tests$smoking$effect_sizes$interpretation,
                        tests$education$effect_sizes$interpretation,
                        tests$small$effect_sizes$interpretation),
        Min_Expected = c(round(tests$smoking$assumptions$min_expected, 2),
                         round(tests$education$assumptions$min_expected, 2),
                         round(tests$small$assumptions$min_expected, 2)),
        Assumption_Met = c(ifelse(tests$smoking$assumptions$assumption_met, 
                                  &quot;Yes&quot;, &quot;No&quot;),
                           ifelse(tests$education$assumptions$assumption_met,
                                  &quot;Yes&quot;, &quot;No&quot;),
                           ifelse(tests$small$assumptions$assumption_met,
                                  &quot;Yes&quot;, &quot;No&quot;))
      )
      
      return(results_df)
    }
    
    results_table &lt;- create_independence_results_table(tests)
    
    return(list(
      chi2_test = chi2_independence_test_comprehensive,
      tests = tests,
      results_table = results_table
    ))
  }
  
  # Run demonstration
  demo_results &lt;- demonstrate_independence_tests()
  
  return(demo_results)
}

# Create and run independence testing system
independence_system &lt;- chi2_independence_analysis()
print(independence_system$results_table)</code></pre>
            </div>
            

            <div class="special-block reference">
                <div class="special-label">Reference: Davies (2016) Chapter 15; Pawgi (2022) Chapter 10</div>
                <div class="special-content"></div>
            </div>
            
<hr class="content-hr">
</section>

            <section class="content-section" id="7-errors-and-power">
                <h2 class="section-heading"><strong>7. Errors and Power</strong></h2>
            
</section>

            <section class="content-section" id="a-type-i-and-type-ii-errors">
                <h3 class="section-heading"><strong>A. Type I and Type II Errors</strong></h3>
            

            <div class="code-block">
                <pre><code class="language-r"># Error analysis and power calculations
error_power_analysis &lt;- function() {
  # 1. Error probability visualization
  visualize_errors &lt;- function(mu0, mu1, sigma, n, alpha=0.05, 
                               alternative=&quot;two.sided&quot;) {
    # mu0: null hypothesis mean
    # mu1: alternative hypothesis mean (true mean)
    # sigma: population standard deviation
    # n: sample size
    # alpha: significance level
    
    # Calculate standard error
    se &lt;- sigma / sqrt(n)
    
    # Critical values
    if (alternative == &quot;two.sided&quot;) {
      critical_lower &lt;- mu0 - qnorm(1 - alpha/2) * se
      critical_upper &lt;- mu0 + qnorm(1 - alpha/2) * se
      rejection_region &lt;- paste(&quot;X̄ &lt;&quot;, round(critical_lower, 3), 
                                &quot;or X̄ &gt;&quot;, round(critical_upper, 3))
    } else if (alternative == &quot;greater&quot;) {
      critical &lt;- mu0 + qnorm(1 - alpha) * se
      rejection_region &lt;- paste(&quot;X̄ &gt;&quot;, round(critical, 3))
      critical_lower &lt;- -Inf
      critical_upper &lt;- critical
    } else {
      critical &lt;- mu0 - qnorm(1 - alpha) * se
      rejection_region &lt;- paste(&quot;X̄ &lt;&quot;, round(critical, 3))
      critical_lower &lt;- critical
      critical_upper &lt;- Inf
    }
    
    # Calculate probabilities
    # Type I error (α) = P(reject H0 | H0 true)
    if (alternative == &quot;two.sided&quot;) {
      alpha_prob &lt;- 2 * pnorm(-abs(critical_upper - mu0)/se)
    } else if (alternative == &quot;greater&quot;) {
      alpha_prob &lt;- pnorm(critical_upper, mean=mu0, sd=se, lower.tail=FALSE)
    } else {
      alpha_prob &lt;- pnorm(critical_lower, mean=mu0, sd=se)
    }
    
    # Type II error (β) = P(fail to reject H0 | H1 true)
    if (alternative == &quot;two.sided&quot;) {
      beta_prob &lt;- pnorm(critical_upper, mean=mu1, sd=se) - 
        pnorm(critical_lower, mean=mu1, sd=se)
    } else if (alternative == &quot;greater&quot;) {
      beta_prob &lt;- pnorm(critical_upper, mean=mu1, sd=se)
    } else {
      beta_prob &lt;- pnorm(critical_lower, mean=mu1, sd=se, lower.tail=FALSE)
    }
    
    # Power = 1 - β
    power &lt;- 1 - beta_prob
    
    # Visualization
    x_min &lt;- min(mu0 - 4*se, mu1 - 4*se)
    x_max &lt;- max(mu0 + 4*se, mu1 + 4*se)
    x_seq &lt;- seq(x_min, x_max, length=1000)
    
    # Plot both distributions
    plot(x_seq, dnorm(x_seq, mean=mu0, sd=se), type=&quot;l&quot;,
         lwd=2, col=&quot;blue&quot;,
         main=paste(&quot;Error Analysis\nμ₀=&quot;, mu0, &quot;, μ₁=&quot;, mu1, 
                   &quot;, n=&quot;, n, &quot;, α=&quot;, alpha, sep=&quot;&quot;),
         xlab=&quot;Sample Mean (X̄)&quot;, ylab=&quot;Density&quot;,
         ylim=c(0, max(dnorm(mu0, mu0, se), dnorm(mu1, mu1, se))*1.2))
    
    # Add H1 distribution
    lines(x_seq, dnorm(x_seq, mean=mu1, sd=se), 
          lwd=2, col=&quot;red&quot;, lty=2)
    
    # Shade Type I error region (α)
    if (alternative == &quot;two.sided&quot;) {
      # Left tail
      x_left &lt;- seq(x_min, critical_lower, length=100)
      polygon(c(x_min, x_left, critical_lower),
              c(0, dnorm(x_left, mu0, se), 0),
              col=rgb(0,0,1,0.3), border=NA)
      # Right tail
      x_right &lt;- seq(critical_upper, x_max, length=100)
      polygon(c(critical_upper, x_right, x_max),
              c(0, dnorm(x_right, mu0, se), 0),
              col=rgb(0,0,1,0.3), border=NA)
    } else if (alternative == &quot;greater&quot;) {
      x_right &lt;- seq(critical_upper, x_max, length=100)
      polygon(c(critical_upper, x_right, x_max),
              c(0, dnorm(x_right, mu0, se), 0),
              col=rgb(0,0,1,0.3), border=NA)
    } else {
      x_left &lt;- seq(x_min, critical_lower, length=100)
      polygon(c(x_min, x_left, critical_lower),
              c(0, dnorm(x_left, mu0, se), 0),
              col=rgb(0,0,1,0.3), border=NA)
    }
    
    # Shade Type II error region (β)
    if (alternative == &quot;two.sided&quot;) {
      x_beta &lt;- seq(critical_lower, critical_upper, length=100)
      polygon(c(critical_lower, x_beta, critical_upper),
              c(0, dnorm(x_beta, mu1, se), 0),
              col=rgb(1,0,0,0.3), border=NA)
    } else if (alternative == &quot;greater&quot;) {
      x_beta &lt;- seq(x_min, critical_upper, length=100)
      polygon(c(x_min, x_beta, critical_upper),
              c(0, dnorm(x_beta, mu1, se), 0),
              col=rgb(1,0,0,0.3), border=NA)
    } else {
      x_beta &lt;- seq(critical_lower, x_max, length=100)
      polygon(c(critical_lower, x_beta, x_max),
              c(0, dnorm(x_beta, mu1, se), 0),
              col=rgb(1,0,0,0.3), border=NA)
    }
    
    # Add critical lines
    if (alternative == &quot;two.sided&quot;) {
      abline(v=c(critical_lower, critical_upper), 
             col=&quot;blue&quot;, lwd=1, lty=2)
    } else {
      abline(v=ifelse(alternative==&quot;greater&quot;, critical_upper, critical_lower),
             col=&quot;blue&quot;, lwd=1, lty=2)
    }
    
    # Add means
    abline(v=mu0, col=&quot;blue&quot;, lwd=2)
    abline(v=mu1, col=&quot;red&quot;, lwd=2, lty=2)
    
    # Add legend
    legend(&quot;topright&quot;,
           legend=c(
             paste(&quot;H₀: μ =&quot;, mu0),
             paste(&quot;H₁: μ =&quot;, mu1),
             paste(&quot;α =&quot;, round(alpha_prob, 4), &quot;(Type I)&quot;),
             paste(&quot;β =&quot;, round(beta_prob, 4), &quot;(Type II)&quot;),
             paste(&quot;Power =&quot;, round(power, 4))
           ),
           col=c(&quot;blue&quot;, &quot;red&quot;, &quot;blue&quot;, &quot;red&quot;, &quot;green&quot;),
           lwd=c(2,2,5,5,2), lty=c(1,2,1,1,1),
           bg=&quot;white&quot;)
    
    # Return results
    return(list(
      mu0 = mu0,
      mu1 = mu1,
      sigma = sigma,
      n = n,
      alpha = alpha,
      alternative = alternative,
      critical_values = c(lower=critical_lower, upper=critical_upper),
      rejection_region = rejection_region,
      type_I_error = alpha_prob,
      type_II_error = beta_prob,
      power = power
    ))
  }
  
  # 2. Power analysis for different parameters
  power_analysis_systematic &lt;- function() {
    # Systematic power analysis
    
    # a. Power vs Sample Size
    sample_sizes &lt;- seq(10, 200, by=10)
    effect_sizes &lt;- c(0.2, 0.5, 0.8)  # Cohen&#x27;s d: small, medium, large
    
    power_matrix &lt;- matrix(NA, nrow=length(sample_sizes), 
                          ncol=length(effect_sizes))
    
    for (i in seq_along(sample_sizes)) {
      for (j in seq_along(effect_sizes)) {
        # Using pwr package if available
        # install.packages(&quot;pwr&quot;)
        if (requireNamespace(&quot;pwr&quot;, quietly = TRUE)) {
          power_test &lt;- pwr::pwr.t.test(n=sample_sizes[i], 
                                       d=effect_sizes[j],
                                       sig.level=0.05,
                                       type=&quot;two.sample&quot;,
                                       alternative=&quot;two.sided&quot;)
          power_matrix[i, j] &lt;- power_test$power
        } else {
          # Manual calculation
          n &lt;- sample_sizes[i]
          d &lt;- effect_sizes[j]
          # Simplified calculation
          power_matrix[i, j] &lt;- pnorm(sqrt(n/2) * d - qnorm(0.975))
        }
      }
    }
    
    # b. Power vs Effect Size
    effect_seq &lt;- seq(0.1, 1.5, by=0.05)
    n_values &lt;- c(20, 50, 100)
    
    power_vs_effect &lt;- matrix(NA, nrow=length(effect_seq), 
                             ncol=length(n_values))
    
    for (i in seq_along(effect_seq)) {
      for (j in seq_along(n_values)) {
        if (requireNamespace(&quot;pwr&quot;, quietly = TRUE)) {
          power_test &lt;- pwr::pwr.t.test(n=n_values[j],
                                       d=effect_seq[i],
                                       sig.level=0.05,
                                       type=&quot;two.sample&quot;)
          power_vs_effect[i, j] &lt;- power_test$power
        }
      }
    }
    
    # c. Power vs Significance Level
    alpha_seq &lt;- seq(0.01, 0.2, by=0.01)
    power_vs_alpha &lt;- sapply(alpha_seq, function(alpha) {
      if (requireNamespace(&quot;pwr&quot;, quietly = TRUE)) {
        power_test &lt;- pwr::pwr.t.test(n=50, d=0.5,
                                     sig.level=alpha,
                                     type=&quot;two.sample&quot;)
        return(power_test$power)
      } else {
        return(NA)
      }
    })
    
    # Visualization
    par(mfrow=c(2,2))
    
    # Plot 1: Power vs Sample Size
    matplot(sample_sizes, power_matrix, type=&quot;l&quot;, lwd=2,
            main=&quot;Power vs Sample Size\n(α=0.05, two-tailed)&quot;,
            xlab=&quot;Sample Size per Group&quot;, ylab=&quot;Power&quot;,
            ylim=c(0, 1))
    abline(h=0.8, lty=2, col=&quot;gray&quot;)
    legend(&quot;bottomright&quot;,
           legend=paste(&quot;d =&quot;, effect_sizes),
           col=1:length(effect_sizes), lwd=2)
    
    # Plot 2: Power vs Effect Size
    matplot(effect_seq, power_vs_effect, type=&quot;l&quot;, lwd=2,
            main=&quot;Power vs Effect Size\n(α=0.05, two-tailed)&quot;,
            xlab=&quot;Effect Size (Cohen&#x27;s d)&quot;, ylab=&quot;Power&quot;,
            ylim=c(0, 1))
    abline(h=0.8, lty=2, col=&quot;gray&quot;)
    legend(&quot;bottomright&quot;,
           legend=paste(&quot;n =&quot;, n_values),
           col=1:length(n_values), lwd=2)
    
    # Plot 3: Power vs Alpha
    plot(alpha_seq, power_vs_alpha, type=&quot;l&quot;, lwd=2,
         main=&quot;Power vs Significance Level\n(n=50, d=0.5)&quot;,
         xlab=&quot;Significance Level (α)&quot;, ylab=&quot;Power&quot;,
         ylim=c(0, 1))
    abline(h=0.8, lty=2, col=&quot;gray&quot;)
    points(0.05, power_vs_alpha[alpha_seq == 0.05],
           pch=19, col=&quot;red&quot;, cex=1.5)
    
    # Plot 4: Sample Size needed for 80% power
    if (requireNamespace(&quot;pwr&quot;, quietly = TRUE)) {
      d_seq &lt;- seq(0.2, 1.2, by=0.1)
      n_needed &lt;- sapply(d_seq, function(d) {
        power_test &lt;- pwr::pwr.t.test(d=d, power=0.8,
                                     sig.level=0.05,
                                     type=&quot;two.sample&quot;)
        return(ceiling(power_test$n))
      })
      
      plot(d_seq, n_needed, type=&quot;b&quot;, lwd=2, pch=19,
           main=&quot;Sample Size Needed for 80% Power\n(α=0.05, two-tailed)&quot;,
           xlab=&quot;Effect Size (Cohen&#x27;s d)&quot;,
           ylab=&quot;Sample Size per Group&quot;,
           log=&quot;y&quot;)
      grid()
    }
    
    par(mfrow=c(1,1))
    
    return(list(
      power_vs_n = data.frame(
        sample_size = sample_sizes,
        power_small = power_matrix[,1],
        power_medium = power_matrix[,2],
        power_large = power_matrix[,3]
      ),
      power_vs_d = data.frame(
        effect_size = effect_seq,
        power_n20 = power_vs_effect[,1],
        power_n50 = power_vs_effect[,2],
        power_n100 = power_vs_effect[,3]
      ),
      power_vs_alpha = data.frame(
        alpha = alpha_seq,
        power = power_vs_alpha
      )
    ))
  }
  
  # 3. Operating Characteristic (OC) Curves
  operating_characteristic_curves &lt;- function() {
    # Create OC curves for different sample sizes
    
    n_values &lt;- c(10, 30, 50, 100)
    mu0 &lt;- 50
    sigma &lt;- 10
    alpha &lt;- 0.05
    
    # Range of true means to consider
    mu_range &lt;- seq(45, 55, by=0.1)
    
    # Calculate power for each combination
    power_matrix &lt;- matrix(NA, nrow=length(mu_range), ncol=length(n_values))
    
    for (i in seq_along(mu_range)) {
      for (j in seq_along(n_values)) {
        se &lt;- sigma / sqrt(n_values[j])
        critical &lt;- mu0 + qnorm(1 - alpha/2) * se
        power_matrix[i, j] &lt;- pnorm(mu0 - critical, mean=mu_range[i], sd=se, 
                                   lower.tail=TRUE) +
          pnorm(critical, mean=mu_range[i], sd=se, lower.tail=FALSE)
      }
    }
    
    # Plot OC curves
    plot(mu_range, power_matrix[,1], type=&quot;l&quot;, lwd=2,
         main=&quot;Operating Characteristic Curves\n(α=0.05, σ=10)&quot;,
         xlab=&quot;True Mean (μ)&quot;, ylab=&quot;Power&quot;,
         ylim=c(0, 1), col=1)
    
    for (j in 2:length(n_values)) {
      lines(mu_range, power_matrix[,j], lwd=2, col=j)
    }
    
    abline(v=mu0, lty=2, col=&quot;gray&quot;)
    abline(h=0.8, lty=2, col=&quot;gray&quot;)
    abline(h=alpha, lty=3, col=&quot;red&quot;)
    
    legend(&quot;left&quot;,
           legend=paste(&quot;n =&quot;, n_values),
           col=1:length(n_values), lwd=2)
    
    # Add Type II error curve (β = 1 - power)
    par(new=TRUE)
    plot(mu_range, 1 - power_matrix[,1], type=&quot;l&quot;, lwd=2, lty=2,
         axes=FALSE, xlab=&quot;&quot;, ylab=&quot;&quot;, ylim=c(0, 1), col=1)
    
    for (j in 2:length(n_values)) {
      lines(mu_range, 1 - power_matrix[,j], lwd=2, lty=2, col=j)
    }
    
    axis(4)
    mtext(&quot;Type II Error (β)&quot;, side=4, line=3)
    
    return(list(
      mu_range = mu_range,
      power_values = power_matrix,
      sample_sizes = n_values
    ))
  }
  
  # 4. Demonstration
  demonstrate_error_power &lt;- function() {
    # Run all demonstrations
    
    # a. Visualize errors for specific scenario
    error_vis &lt;- visualize_errors(
      mu0 = 50,
      mu1 = 52,
      sigma = 10,
      n = 30,
      alpha = 0.05,
      alternative = &quot;two.sided&quot;
    )
    
    # b. Systematic power analysis
    power_analysis &lt;- power_analysis_systematic()
    
    # c. OC curves
    oc_curves &lt;- operating_characteristic_curves()
    
    # Create summary table
    create_power_summary &lt;- function() {
      summary_df &lt;- data.frame(
        Parameter = c(&quot;Significance Level (α)&quot;, 
                     &quot;Type II Error (β)&quot;,
                     &quot;Power (1-β)&quot;,
                     &quot;Effect Size (Cohen&#x27;s d)&quot;,
                     &quot;Sample Size (n)&quot;,
                     &quot;Standard Deviation (σ)&quot;),
        Description = c(
          &quot;Probability of rejecting H₀ when it is true&quot;,
          &quot;Probability of failing to reject H₀ when H₁ is true&quot;,
          &quot;Probability of correctly rejecting H₀ when H₁ is true&quot;,
          &quot;Standardized difference between means (μ₁-μ₀)/σ&quot;,
          &quot;Number of observations in each group&quot;,
          &quot;Population standard deviation (measure of variability)&quot;
        ),
        Typical_Values = c(
          &quot;0.05, 0.01, 0.10&quot;,
          &quot;Desired: &lt; 0.20&quot;,
          &quot;Desired: &gt; 0.80&quot;,
          &quot;Small: 0.2, Medium: 0.5, Large: 0.8&quot;,
          &quot;Depends on effect size and desired power&quot;,
          &quot;Estimated from pilot data or literature&quot;
        ),
        Factors_Affecting = c(
          &quot;Chosen by researcher&quot;,
          &quot;Sample size, effect size, variability, α&quot;,
          &quot;Sample size, effect size, variability, α&quot;,
          &quot;Inherent difference between groups&quot;,
          &quot;Larger n increases power&quot;,
          &quot;Smaller σ increases power&quot;
        )
      )
      
      return(summary_df)
    }
    
    power_summary &lt;- create_power_summary()
    
    return(list(
      error_visualization = error_vis,
      power_analysis = power_analysis,
      oc_curves = oc_curves,
      summary = power_summary
    ))
  }
  
  # Run demonstration
  demo_results &lt;- demonstrate_error_power()
  
  return(demo_results)
}

# Create and run error/power analysis system
error_power_system &lt;- error_power_analysis()</code></pre>
            </div>
            

            <div class="special-block reference">
                <div class="special-label">Reference: Davies (2016) Chapter 16; Pawgi (2022) Chapter 11</div>
                <div class="special-content"></div>
            </div>
            
<hr class="content-hr">
</section>

            <section class="content-section" id="8-analysis-of-variance-anova">
                <h2 class="section-heading"><strong>8. Analysis of Variance (ANOVA)</strong></h2>
            
</section>

            <section class="content-section" id="a-one-way-anova">
                <h3 class="section-heading"><strong>A. One-Way ANOVA</strong></h3>
            

            <div class="code-block">
                <pre><code class="language-r"># One-way ANOVA analysis
one_way_anova_analysis &lt;- function() {
  # 1. Manual one-way ANOVA calculation
  manual_one_way_anova &lt;- function(data_list) {
    # data_list: list of vectors, each representing a group
    
    k &lt;- length(data_list)  # number of groups
    n_i &lt;- sapply(data_list, length)  # sample sizes per group
    n_total &lt;- sum(n_i)  # total sample size
    
    # Group means
    group_means &lt;- sapply(data_list, mean)
    overall_mean &lt;- mean(unlist(data_list))
    
    # Sum of Squares calculations
    # SSB: Sum of Squares Between groups
    SSB &lt;- sum(n_i * (group_means - overall_mean)^2)
    
    # SSW: Sum of Squares Within groups
    SSW &lt;- sum(sapply(1:k, function(i) {
      sum((data_list[[i]] - group_means[i])^2)
    }))
    
    # SST: Total Sum of Squares
    SST &lt;- SSB + SSW
    
    # Degrees of freedom
    df_between &lt;- k - 1
    df_within &lt;- n_total - k
    df_total &lt;- n_total - 1
    
    # Mean Squares
    MSB &lt;- SSB / df_between
    MSW &lt;- SSW / df_within
    
    # F-statistic
    F_stat &lt;- MSB / MSW
    
    # p-value
    p_value &lt;- pf(F_stat, df1=df_between, df2=df_within, lower.tail=FALSE)
    
    # Effect sizes
    eta_squared &lt;- SSB / SST  # Proportion of variance explained
    omega_squared &lt;- (SSB - (df_between * MSW)) / (SST + MSW)  # Adjusted
    
    # Assumption checking
    # Normality test for each group
    normality_tests &lt;- lapply(data_list, shapiro.test)
    normality_p &lt;- sapply(normality_tests, function(x) x$p.value)
    
    # Homogeneity of variance (Levene&#x27;s test)
    levene_test &lt;- function(data_list) {
      # Simplified Levene&#x27;s test
      group_medians &lt;- sapply(data_list, median)
      deviations &lt;- lapply(1:k, function(i) {
        abs(data_list[[i]] - group_medians[i])
      })
      
      # Perform ANOVA on deviations
      levene_anova &lt;- manual_one_way_anova(deviations)
      return(levene_anova$p_value)
    }
    
    levene_p &lt;- levene_test(data_list)
    
    # Post-hoc tests (Tukey HSD)
    # Standard error for pairwise comparisons
    se_pairwise &lt;- sqrt(MSW * (1/n_i[1] + 1/n_i[2]))  # For equal sample sizes
    
    # Critical value for Tukey HSD
    tukey_critical &lt;- qtukey(0.95, nmeans=k, df=df_within) / sqrt(2)
    
    # Pairwise differences
    pairwise_diffs &lt;- matrix(0, k, k)
    for (i in 1:k) {
      for (j in 1:k) {
        if (i != j) {
          pairwise_diffs[i, j] &lt;- group_means[i] - group_means[j]
        }
      }
    }
    
    # Significant pairs (simplified)
    significant_pairs &lt;- abs(pairwise_diffs) &gt; (tukey_critical * se_pairwise)
    
    # Built-in ANOVA for comparison
    anova_data &lt;- data.frame(
      value = unlist(data_list),
      group = factor(rep(1:k, times=n_i))
    )
    
    builtin_anova &lt;- aov(value ~ group, data=anova_data)
    builtin_summary &lt;- summary(builtin_anova)
    
    return(list(
      method = &quot;One-way Analysis of Variance&quot;,
      groups = k,
      sample_sizes = n_i,
      total_n = n_total,
      means = group_means,
      overall_mean = overall_mean,
      sum_of_squares = c(SSB=SSB, SSW=SSW, SST=SST),
      degrees_of_freedom = c(between=df_between, within=df_within, total=df_total),
      mean_squares = c(MSB=MSB, MSW=MSW),
      f_statistic = F_stat,
      p_value = p_value,
      effect_sizes = c(eta_squared=eta_squared, omega_squared=omega_squared),
      assumptions = list(
        normality_p = normality_p,
        homogeneity_p = levene_p,
        normality_assumption = all(normality_p &gt; 0.05),
        homogeneity_assumption = levene_p &gt; 0.05
      ),
      post_hoc = list(
        pairwise_differences = pairwise_diffs,
        standard_error = se_pairwise,
        tukey_critical = tukey_critical,
        significant_pairs = significant_pairs
      ),
      anova_table = data.frame(
        Source = c(&quot;Between Groups&quot;, &quot;Within Groups&quot;, &quot;Total&quot;),
        SS = c(SSB, SSW, SST),
        df = c(df_between, df_within, df_total),
        MS = c(MSB, MSW, NA),
        F = c(F_stat, NA, NA),
        p = c(p_value, NA, NA)
      ),
      builtin_result = builtin_summary
    ))
  }
  
  # 2. Demonstration with simulated data
  demonstrate_one_way_anova &lt;- function() {
    set.seed(123)
    
    # Create three groups with different means
    group1 &lt;- rnorm(30, mean=50, sd=10)
    group2 &lt;- rnorm(30, mean=55, sd=10)
    group3 &lt;- rnorm(30, mean=60, sd=10)
    group4 &lt;- rnorm(30, mean=52, sd=10)  # Control group
    
    data_list &lt;- list(
      Treatment1 = group1,
      Treatment2 = group2,
      Treatment3 = group3,
      Control = group4
    )
    
    # Run manual ANOVA
    anova_results &lt;- manual_one_way_anova(data_list)
    
    # Run built-in ANOVA
    anova_data &lt;- data.frame(
      value = unlist(data_list),
      group = factor(rep(names(data_list), each=30))
    )
    
    # Visualization
    par(mfrow=c(2,3))
    
    # Boxplot of groups
    boxplot(data_list,
            main=&quot;Group Distributions&quot;,
            xlab=&quot;Group&quot;, ylab=&quot;Value&quot;,
            col=c(&quot;lightblue&quot;, &quot;lightgreen&quot;, &quot;lightpink&quot;, &quot;lightyellow&quot;),
            notch=TRUE)
    
    # Add means
    points(1:4, anova_results$means, pch=19, col=&quot;red&quot;, cex=1.2)
    
    # Individual group distributions
    for (i in 1:4) {
      hist(data_list[[i]], breaks=15, freq=FALSE,
           main=paste(&quot;Group:&quot;, names(data_list)[i]),
           xlab=&quot;Value&quot;, col=&quot;lightblue&quot;, border=&quot;white&quot;,
           xlim=range(unlist(data_list)))
      curve(dnorm(x, mean=mean(data_list[[i]]), sd=sd(data_list[[i]])),
            add=TRUE, col=&quot;red&quot;, lwd=2)
      abline(v=anova_results$means[i], col=&quot;blue&quot;, lwd=2, lty=2)
      abline(v=anova_results$overall_mean, col=&quot;green&quot;, lwd=2, lty=2)
    }
    
    # Q-Q plots for normality check
    qqnorm(unlist(data_list), main=&quot;Overall Q-Q Plot&quot;)
    qqline(unlist(data_list), col=&quot;red&quot;)
    
    # Residuals plot (from built-in ANOVA)
    builtin_aov &lt;- aov(value ~ group, data=anova_data)
    plot(fitted(builtin_aov), residuals(builtin_aov),
         main=&quot;Residuals vs Fitted&quot;,
         xlab=&quot;Fitted Values&quot;, ylab=&quot;Residuals&quot;,
         pch=19, col=&quot;blue&quot;)
    abline(h=0, col=&quot;red&quot;, lty=2)
    
    # F-distribution with test statistic
    x_seq &lt;- seq(0, 10, length=1000)
    plot(x_seq, df(x_seq, df1=anova_results$degrees_of_freedom[&quot;between&quot;],
                   df2=anova_results$degrees_of_freedom[&quot;within&quot;]),
         type=&quot;l&quot;, lwd=2, col=&quot;black&quot;,
         main=&quot;F-Distribution with Test Statistic&quot;,
         xlab=&quot;F-value&quot;, ylab=&quot;Density&quot;)
    
    # Critical region
    f_critical &lt;- qf(0.95, 
                     df1=anova_results$degrees_of_freedom[&quot;between&quot;],
                     df2=anova_results$degrees_of_freedom[&quot;within&quot;])
    x_critical &lt;- seq(f_critical, 10, length=100)
    polygon(c(f_critical, x_critical, 10),
            c(0, df(x_critical,
                    df1=anova_results$degrees_of_freedom[&quot;between&quot;],
                    df2=anova_results$degrees_of_freedom[&quot;within&quot;]), 0),
            col=&quot;red&quot;, border=NA, density=30)
    
    # Test statistic
    abline(v=anova_results$f_statistic, col=&quot;blue&quot;, lwd=2, lty=2)
    text(anova_results$f_statistic, 0.2,
         paste(&quot;F =&quot;, round(anova_results$f_statistic, 3)),
         pos=4, col=&quot;blue&quot;)
    
    text(f_critical, 0.1,
         paste(&quot;Critical F =&quot;, round(f_critical, 3)),
         pos=2, col=&quot;red&quot;)
    
    par(mfrow=c(1,1))
    
    # Post-hoc tests using Tukey HSD
    if (requireNamespace(&quot;multcomp&quot;, quietly = TRUE)) {
      tukey_results &lt;- TukeyHSD(builtin_aov)
      
      # Plot Tukey results
      par(mfrow=c(1,2))
      
      plot(tukey_results, las=1)
      
      # Mean plot with confidence intervals
      group_means &lt;- anova_results$means
      group_ses &lt;- sapply(data_list, function(x) sd(x)/sqrt(length(x)))
      
      plot(1:4, group_means, pch=19, cex=1.5,
           main=&quot;Group Means with 95% CIs&quot;,
           xlab=&quot;Group&quot;, ylab=&quot;Mean&quot;,
           ylim=range(c(group_means - 1.96*group_ses,
                        group_means + 1.96*group_ses)),
           xaxt=&quot;n&quot;)
      axis(1, at=1:4, labels=names(data_list))
      
      arrows(1:4, group_means - 1.96*group_ses,
             1:4, group_means + 1.96*group_ses,
             angle=90, code=3, length=0.1, lwd=2)
      
      abline(h=anova_results$overall_mean, col=&quot;red&quot;, lty=2)
      
      par(mfrow=c(1,1))
    }
    
    # Create comprehensive results table
    create_anova_results_table &lt;- function(results) {
      # ANOVA table
      anova_table &lt;- results$anova_table
      
      # Assumptions table
      assumptions_table &lt;- data.frame(
        Assumption = c(&quot;Normality (Shapiro-Wilk)&quot;, 
                      &quot;Homogeneity of Variance (Levene&#x27;s)&quot;),
        Test_Statistic = c(NA, NA),
        p_value = c(min(results$assumptions$normality_p),
                   results$assumptions$homogeneity_p),
        Assumption_Met = c(ifelse(results$assumptions$normality_assumption,
                                  &quot;Yes&quot;, &quot;No&quot;),
                          ifelse(results$assumptions$homogeneity_assumption,
                                 &quot;Yes&quot;, &quot;No&quot;))
      )
      
      # Effect sizes table
      effects_table &lt;- data.frame(
        Measure = c(&quot;Eta-squared (η²)&quot;, &quot;Omega-squared (ω²)&quot;),
        Value = round(c(results$effect_sizes[&quot;eta_squared&quot;],
                       results$effect_sizes[&quot;omega_squared&quot;]), 4),
        Interpretation = c(
          ifelse(results$effect_sizes[&quot;eta_squared&quot;] &lt; 0.01, &quot;Negligible&quot;,
                ifelse(results$effect_sizes[&quot;eta_squared&quot;] &lt; 0.06, &quot;Small&quot;,
                      ifelse(results$effect_sizes[&quot;eta_squared&quot;] &lt; 0.14, 
                            &quot;Medium&quot;, &quot;Large&quot;))),
          &quot;Adjusted effect size&quot;
        )
      )
      
      return(list(
        anova_table = anova_table,
        assumptions = assumptions_table,
        effect_sizes = effects_table
      ))
    }
    
    results_tables &lt;- create_anova_results_table(anova_results)
    
    return(list(
      manual_anova = anova_results,
      data = data_list,
      results_tables = results_tables,
      builtin_anova = builtin_aov
    ))
  }
  
  # 3. Power analysis for ANOVA
  anova_power_analysis &lt;- function() {
    # Using pwr package for ANOVA power analysis
    
    if (requireNamespace(&quot;pwr&quot;, quietly = TRUE)) {
      # Example power calculations
      
      # a. Power for given parameters
      power_example &lt;- pwr::pwr.anova.test(
        k = 4,           # number of groups
        n = 30,          # sample size per group
        f = 0.25,        # effect size (Cohen&#x27;s f)
        sig.level = 0.05
      )
      
      # b. Sample size needed for desired power
      sample_size_example &lt;- pwr::pwr.anova.test(
        k = 4,
        f = 0.25,
        sig.level = 0.05,
        power = 0.80
      )
      
      # c. Effect size detectable with given power
      effect_size_example &lt;- pwr::pwr.anova.test(
        k = 4,
        n = 30,
        sig.level = 0.05,
        power = 0.80
      )
      
      # Visualization
      par(mfrow=c(1,2))
      
      # Power vs Sample Size
      n_seq &lt;- seq(10, 100, by=5)
      power_seq &lt;- sapply(n_seq, function(n) {
        pwr::pwr.anova.test(k=4, n=n, f=0.25, sig.level=0.05)$power
      })
      
      plot(n_seq, power_seq, type=&quot;b&quot;, lwd=2,
           main=&quot;Power vs Sample Size per Group\n(k=4, f=0.25, α=0.05)&quot;,
           xlab=&quot;Sample Size per Group&quot;, ylab=&quot;Power&quot;,
           pch=19, col=&quot;blue&quot;)
      abline(h=0.8, lty=2, col=&quot;red&quot;)
      grid()
      
      # Power vs Effect Size
      f_seq &lt;- seq(0.1, 0.5, by=0.02)
      power_f &lt;- sapply(f_seq, function(f) {
        pwr::pwr.anova.test(k=4, n=30, f=f, sig.level=0.05)$power
      })
      
      plot(f_seq, power_f, type=&quot;b&quot;, lwd=2,
           main=&quot;Power vs Effect Size\n(k=4, n=30, α=0.05)&quot;,
           xlab=&quot;Effect Size (Cohen&#x27;s f)&quot;, ylab=&quot;Power&quot;,
           pch=19, col=&quot;darkgreen&quot;)
      abline(h=0.8, lty=2, col=&quot;red&quot;)
      grid()
      
      par(mfrow=c(1,1))
      
      return(list(
        power_example = power_example,
        sample_size_example = sample_size_example,
        effect_size_example = effect_size_example,
        power_vs_n = data.frame(n=n_seq, power=power_seq),
        power_vs_f = data.frame(f=f_seq, power=power_f)
      ))
    } else {
      warning(&quot;Install &#x27;pwr&#x27; package for power analysis&quot;)
      return(NULL)
    }
  }
  
  # 4. Non-parametric alternative: Kruskal-Wallis test
  kruskal_wallis_demo &lt;- function(data_list) {
    # Already implemented in nonparametric section
    # Just showing integration here
    
    kw_test &lt;- kruskal.test(unlist(data_list), 
                           factor(rep(1:length(data_list), 
                                     sapply(data_list, length))))
    
    return(kw_test)
  }
  
  # Run comprehensive demonstration
  demo_results &lt;- demonstrate_one_way_anova()
  power_results &lt;- anova_power_analysis()
  
  return(list(
    manual_anova_function = manual_one_way_anova,
    demonstration = demo_results,
    power_analysis = power_results,
    nonparametric_alternative = kruskal_wallis_demo
  ))
}

# Create and run ANOVA analysis system
anova_system &lt;- one_way_anova_analysis()</code></pre>
            </div>
            
</section>

            <section class="content-section" id="b-two-way-anova">
                <h3 class="section-heading"><strong>B. Two-Way ANOVA</strong></h3>
            

            <div class="code-block">
                <pre><code class="language-r"># Two-way ANOVA analysis
two_way_anova_analysis &lt;- function() {
  # Note: Two-way ANOVA is more complex and typically uses built-in functions
  # We&#x27;ll focus on demonstrating concepts and interpretation
  
  # 1. Create simulated data for two-way ANOVA
  create_two_way_data &lt;- function() {
    set.seed(123)
    
    # Factors
    factor_A &lt;- factor(rep(c(&quot;A1&quot;, &quot;A2&quot;), each=60))  # 2 levels
    factor_B &lt;- factor(rep(rep(c(&quot;B1&quot;, &quot;B2&quot;, &quot;B3&quot;), each=20), times=2))  # 3 levels
    
    # Create means for each combination (with interaction)
    means &lt;- matrix(c(
      50, 55, 60,  # A1: B1, B2, B3
      55, 65, 70   # A2: B1, B2, B3
    ), nrow=2, byrow=TRUE)
    
    # Generate data with interaction effect
    n_per_cell &lt;- 20
    data_values &lt;- numeric(120)
    
    for (i in 1:2) {  # Factor A levels
      for (j in 1:3) {  # Factor B levels
        cell_idx &lt;- ((i-1)*60 + (j-1)*20 + 1):((i-1)*60 + j*20)
        data_values[cell_idx] &lt;- rnorm(n_per_cell, 
                                       mean=means[i, j], 
                                       sd=10)
      }
    }
    
    # Create data frame
    data_df &lt;- data.frame(
      value = data_values,
      factor_A = factor_A,
      factor_B = factor_B
    )
    
    return(data_df)
  }
  
  # 2. Perform two-way ANOVA
  perform_two_way_anova &lt;- function(data_df) {
    # Full model with interaction
    full_model &lt;- aov(value ~ factor_A * factor_B, data=data_df)
    full_summary &lt;- summary(full_model)
    
    # Model without interaction (additive model)
    additive_model &lt;- aov(value ~ factor_A + factor_B, data=data_df)
    additive_summary &lt;- summary(additive_model)
    
    # Test for interaction (compare models)
    interaction_test &lt;- anova(additive_model, full_model)
    
    # Effect sizes
    # Calculate eta-squared for each effect
    ss_total &lt;- sum((data_df$value - mean(data_df$value))^2)
    
    # From full model
    ss_A &lt;- sum((tapply(data_df$value, data_df$factor_A, mean) - 
                 mean(data_df$value))^2 * 
                table(data_df$factor_A))
    ss_B &lt;- sum((tapply(data_df$value, data_df$factor_B, mean) - 
                 mean(data_df$value))^2 * 
                table(data_df$factor_B))
    
    # Interaction SS (from residuals)
    cell_means &lt;- tapply(data_df$value, 
                        list(data_df$factor_A, data_df$factor_B), 
                        mean)
    main_effect_pred &lt;- outer(tapply(data_df$value, data_df$factor_A, mean),
                             tapply(data_df$value, data_df$factor_B, mean),
                             &quot;+&quot;) - mean(data_df$value)
    interaction_effect &lt;- cell_means - main_effect_pred
    ss_AB &lt;- sum(interaction_effect^2) * 20  # 20 observations per cell
    
    eta_squared &lt;- c(
      A = ss_A / ss_total,
      B = ss_B / ss_total,
      AB = ss_AB / ss_total,
      Error = 1 - (ss_A + ss_B + ss_AB)/ss_total
    )
    
    return(list(
      full_model = full_model,
      full_summary = full_summary,
      additive_model = additive_model,
      additive_summary = additive_summary,
      interaction_test = interaction_test,
      effect_sizes = eta_squared,
      cell_means = cell_means,
      main_effects = list(
        A = tapply(data_df$value, data_df$factor_A, mean),
        B = tapply(data_df$value, data_df$factor_B, mean)
      ),
      interaction_effects = interaction_effect
    ))
  }
  
  # 3. Visualization
  visualize_two_way_anova &lt;- function(data_df, anova_results) {
    par(mfrow=c(2,3))
    
    # Interaction plot
    interaction.plot(data_df$factor_A, data_df$factor_B, data_df$value,
                    main=&quot;Interaction Plot&quot;,
                    xlab=&quot;Factor A&quot;, ylab=&quot;Mean Value&quot;,
                    trace.label=&quot;Factor B&quot;,
                    col=c(&quot;blue&quot;, &quot;red&quot;, &quot;green&quot;),
                    lwd=2, type=&quot;b&quot;, pch=19)
    
    # Cell means bar plot
    barplot(anova_results$cell_means, beside=TRUE,
            main=&quot;Cell Means&quot;,
            xlab=&quot;Factor A&quot;, ylab=&quot;Mean Value&quot;,
            col=c(&quot;lightblue&quot;, &quot;lightgreen&quot;, &quot;lightpink&quot;),
            legend.text=rownames(anova_results$cell_means),
            args.legend=list(x=&quot;topleft&quot;))
    
    # Main effects plot for Factor A
    plot(anova_results$main_effects$A, type=&quot;b&quot;,
         main=&quot;Main Effect of Factor A&quot;,
         xlab=&quot;Factor A Level&quot;, ylab=&quot;Mean Value&quot;,
         pch=19, lwd=2, col=&quot;blue&quot;,
         ylim=range(unlist(anova_results$main_effects)))
    
    # Main effects plot for Factor B
    plot(anova_results$main_effects$B, type=&quot;b&quot;,
         main=&quot;Main Effect of Factor B&quot;,
         xlab=&quot;Factor B Level&quot;, ylab=&quot;Mean Value&quot;,
         pch=19, lwd=2, col=&quot;red&quot;,
         ylim=range(unlist(anova_results$main_effects)))
    
    # Residuals vs Fitted
    plot(fitted(anova_results$full_model), 
         residuals(anova_results$full_model),
         main=&quot;Residuals vs Fitted Values&quot;,
         xlab=&quot;Fitted Values&quot;, ylab=&quot;Residuals&quot;,
         pch=19, col=&quot;blue&quot;)
    abline(h=0, col=&quot;red&quot;, lty=2)
    
    # Q-Q plot of residuals
    qqnorm(residuals(anova_results$full_model),
           main=&quot;Q-Q Plot of Residuals&quot;)
    qqline(residuals(anova_results$full_model), col=&quot;red&quot;)
    
    par(mfrow=c(1,1))
    
    # Additional: Profile plot
    profile_plot &lt;- function() {
      means &lt;- anova_results$cell_means
      x &lt;- 1:nrow(means)
      
      plot(x, means[,1], type=&quot;b&quot;, pch=19, lwd=2,
           main=&quot;Profile Plot&quot;,
           xlab=&quot;Factor A&quot;, ylab=&quot;Mean Value&quot;,
           ylim=range(means), xaxt=&quot;n&quot;)
      axis(1, at=x, labels=rownames(means))
      
      for (j in 2:ncol(means)) {
        lines(x, means[,j], type=&quot;b&quot;, pch=19, lwd=2, col=j)
      }
      
      legend(&quot;topleft&quot;, legend=colnames(means),
             col=1:ncol(means), lwd=2, pch=19)
    }
    
    profile_plot()
  }
  
  # 4. Post-hoc tests
  post_hoc_analysis &lt;- function(anova_results) {
    # Simple effects analysis (if interaction is significant)
    
    # Pairwise comparisons for Factor A at each level of Factor B
    # This would typically use emmeans package
    # Here&#x27;s a simplified version
    
    cat(&quot;POST-HOC ANALYSIS\n&quot;)
    cat(&quot;================\n\n&quot;)
    
    cat(&quot;For detailed post-hoc tests, use:\n&quot;)
    cat(&quot;1. install.packages(&#x27;emmeans&#x27;)\n&quot;)
    cat(&quot;2. library(emmeans)\n&quot;)
    cat(&quot;3. emmeans(model, pairwise ~ factor_A | factor_B)\n&quot;)
    cat(&quot;4. emmeans(model, pairwise ~ factor_B | factor_A)\n\n&quot;)
    
    # Simple pairwise comparisons using TukeyHSD
    if (anova_results$full_summary[[1]][&quot;factor_A:factor_B&quot;, &quot;Pr(&gt;F)&quot;] &lt; 0.05) {
      cat(&quot;Significant interaction detected.\n&quot;)
      cat(&quot;Interpret main effects with caution.\n&quot;)
      cat(&quot;Consider simple effects analysis.\n&quot;)
    } else {
      cat(&quot;No significant interaction.\n&quot;)
      cat(&quot;Main effects can be interpreted independently.\n&quot;)
      
      # Tukey HSD for Factor A
      cat(&quot;\nTukey HSD for Factor A:\n&quot;)
      tukey_A &lt;- TukeyHSD(aov(value ~ factor_A, 
                             data=environment()$data_df))
      print(tukey_A)
      
      # Tukey HSD for Factor B
      cat(&quot;\nTukey HSD for Factor B:\n&quot;)
      tukey_B &lt;- TukeyHSD(aov(value ~ factor_B, 
                             data=environment()$data_df))
      print(tukey_B)
    }
  }
  
  # 5. Comprehensive demonstration
  demonstrate_two_way_anova &lt;- function() {
    # Create data
    data_df &lt;- create_two_way_data()
    
    # Perform ANOVA
    anova_results &lt;- perform_two_way_anova(data_df)
    
    # Visualization
    visualize_two_way_anova(data_df, anova_results)
    
    # Post-hoc analysis
    post_hoc_analysis(anova_results)
    
    # Create results summary
    create_two_way_summary &lt;- function(results, data_df) {
      # Extract ANOVA table
      anova_table &lt;- as.data.frame(results$full_summary[[1]])
      
      # Calculate descriptive statistics
      desc_stats &lt;- do.call(rbind, tapply(data_df$value, 
                                         list(data_df$factor_A, data_df$factor_B),
                                         function(x) c(mean=mean(x), sd=sd(x), n=length(x))))
      
      # Effect size interpretation
      effect_interp &lt;- sapply(results$effect_sizes[1:3], function(eta2) {
        if (eta2 &lt; 0.01) return(&quot;Negligible&quot;)
        if (eta2 &lt; 0.06) return(&quot;Small&quot;)
        if (eta2 &lt; 0.14) return(&quot;Medium&quot;)
        return(&quot;Large&quot;)
      })
      
      summary_list &lt;- list(
        anova_table = anova_table,
        descriptive_stats = desc_stats,
        effect_sizes = data.frame(
          Effect = names(results$effect_sizes[1:3]),
          Eta_Squared = round(results$effect_sizes[1:3], 4),
          Interpretation = effect_interp
        ),
        interaction_present = results$interaction_test$`Pr(&gt;F)`[2] &lt; 0.05,
        model_comparison = results$interaction_test
      )
      
      return(summary_list)
    }
    
    summary_results &lt;- create_two_way_summary(anova_results, data_df)
    
    return(list(
      data = data_df,
      anova_results = anova_results,
      summary = summary_results
    ))
  }
  
  # Run demonstration
  demo_results &lt;- demonstrate_two_way_anova()
  
  return(demo_results)
}

# Create and run two-way ANOVA system
two_way_system &lt;- two_way_anova_analysis()</code></pre>
            </div>
            

            <div class="special-block reference">
                <div class="special-label">Reference: Davies (2016) Chapter 16; Pawgi (2022) Chapter 11</div>
                <div class="special-content"></div>
            </div>
            
<hr class="content-hr">
</section>

            <section class="content-section" id="9-complete-statistical-analysis-framework">
                <h2 class="section-heading"><strong>9. Complete Statistical Analysis Framework</strong></h2>
            

            <div class="code-block">
                <pre><code class="language-r"># Complete statistical analysis pipeline
statistical_analysis_pipeline &lt;- function(data, dependent_var, independent_vars) {
  # Comprehensive pipeline for statistical analysis
  
  cat(&quot;STATISTICAL ANALYSIS PIPELINE\n&quot;)
  cat(&quot;=============================\n\n&quot;)
  
  # Step 1: Data Exploration
  cat(&quot;STEP 1: DATA EXPLORATION\n&quot;)
  cat(&quot;------------------------\n&quot;)
  
  # Summary statistics
  cat(&quot;Summary Statistics:\n&quot;)
  print(summary(data[[dependent_var]]))
  
  # Visualization
  par(mfrow=c(2,2))
  hist(data[[dependent_var]], main=&quot;Distribution&quot;, col=&quot;lightblue&quot;)
  boxplot(data[[dependent_var]], main=&quot;Boxplot&quot;, col=&quot;lightgreen&quot;)
  qqnorm(data[[dependent_var]], main=&quot;Q-Q Plot&quot;)
  qqline(data[[dependent_var]], col=&quot;red&quot;)
  plot(density(data[[dependent_var]]), main=&quot;Density Plot&quot;)
  par(mfrow=c(1,1))
  
  # Step 2: Assumption Checking
  cat(&quot;\nSTEP 2: ASSUMPTION CHECKING\n&quot;)
  cat(&quot;---------------------------\n&quot;)
  
  # Normality test
  normality_test &lt;- shapiro.test(data[[dependent_var]])
  cat(&quot;Normality Test (Shapiro-Wilk):\n&quot;)
  cat(&quot;  W =&quot;, round(normality_test$statistic, 4), 
      &quot;, p =&quot;, format.pval(normality_test$p.value, digits=3), &quot;\n&quot;)
  
  # Step 3: Statistical Testing
  cat(&quot;\nSTEP 3: STATISTICAL TESTING\n&quot;)
  cat(&quot;---------------------------\n&quot;)
  
  # Determine appropriate test based on data characteristics
  if (length(independent_vars) == 1) {
    iv &lt;- independent_vars[1]
    
    if (is.numeric(data[[iv]])) {
      # Correlation/Regression
      cat(&quot;Continuous independent variable: Using correlation/regression\n&quot;)
      cor_test &lt;- cor.test(data[[dependent_var]], data[[iv]])
      print(cor_test)
      
      # Linear regression
      lm_model &lt;- lm(paste(dependent_var, &quot;~&quot;, iv), data=data)
      print(summary(lm_model))
      
    } else if (is.factor(data[[iv]]) || is.character(data[[iv]])) {
      # Categorical independent variable
      n_groups &lt;- length(unique(data[[iv]]))
      
      if (n_groups == 2) {
        cat(&quot;Two groups: Using t-test\n&quot;)
        # Check for normality
        if (normality_test$p.value &gt; 0.05) {
          # Parametric test
          t_test &lt;- t.test(data[[dependent_var]] ~ data[[iv]])
          print(t_test)
        } else {
          # Non-parametric test
          cat(&quot;Non-normal data: Using Mann-Whitney U test\n&quot;)
          mw_test &lt;- wilcox.test(data[[dependent_var]] ~ data[[iv]])
          print(mw_test)
        }
      } else if (n_groups &gt; 2) {
        cat(&quot;More than two groups: Using ANOVA\n&quot;)
        # Check homogeneity of variance
        bartlett_test &lt;- bartlett.test(data[[dependent_var]] ~ data[[iv]])
        cat(&quot;Homogeneity of variance (Bartlett&#x27;s test):\n&quot;)
        cat(&quot;  K-squared =&quot;, round(bartlett_test$statistic, 4),
            &quot;, p =&quot;, format.pval(bartlett_test$p.value, digits=3), &quot;\n&quot;)
        
        if (normality_test$p.value &gt; 0.05 &amp;&amp; bartlett_test$p.value &gt; 0.05) {
          # Parametric ANOVA
          anova_model &lt;- aov(paste(dependent_var, &quot;~&quot;, iv), data=data)
          print(summary(anova_model))
          
          # Post-hoc tests if significant
          if (summary(anova_model)[[1]][1, &quot;Pr(&gt;F)&quot;] &lt; 0.05) {
            cat(&quot;\nSignificant ANOVA result. Performing Tukey HSD post-hoc test:\n&quot;)
            tukey_result &lt;- TukeyHSD(anova_model)
            print(tukey_result)
          }
        } else {
          # Non-parametric Kruskal-Wallis
          cat(&quot;Assumptions violated: Using Kruskal-Wallis test\n&quot;)
          kw_test &lt;- kruskal.test(data[[dependent_var]] ~ data[[iv]])
          print(kw_test)
        }
      }
    }
  } else if (length(independent_vars) == 2) {
    # Two-way ANOVA
    cat(&quot;Two independent variables: Considering two-way ANOVA\n&quot;)
    formula_str &lt;- paste(dependent_var, &quot;~&quot;, 
                        paste(independent_vars, collapse=&quot;*&quot;))
    anova_model &lt;- aov(as.formula(formula_str), data=data)
    print(summary(anova_model))
  }
  
  # Step 4: Effect Size Calculation
  cat(&quot;\nSTEP 4: EFFECT SIZE CALCULATION\n&quot;)
  cat(&quot;-------------------------------\n&quot;)
  
  # Step 5: Results Interpretation
  cat(&quot;\nSTEP 5: RESULTS INTERPRETATION\n&quot;)
  cat(&quot;-------------------------------\n&quot;)
  
  # Provide interpretation guidance
  cat(&quot;Interpretation Guidelines:\n&quot;)
  cat(&quot;1. Check p-value against significance level (typically α=0.05)\n&quot;)
  cat(&quot;2. Consider effect size (practical significance)\n&quot;)
  cat(&quot;3. Check assumptions of the test used\n&quot;)
  cat(&quot;4. Consider confidence intervals\n&quot;)
  cat(&quot;5. Evaluate practical implications\n&quot;)
  
  # Return key results
  return(list(
    normality_test = normality_test,
    test_results = if(exists(&quot;t_test&quot;)) t_test else 
                  if(exists(&quot;anova_model&quot;)) summary(anova_model) else
                  if(exists(&quot;cor_test&quot;)) cor_test else NULL
  ))
}

# Example usage
# Create sample data
set.seed(123)
example_data &lt;- data.frame(
  score = c(rnorm(30, mean=75, sd=10),
           rnorm(30, mean=85, sd=10)),
  group = factor(rep(c(&quot;Control&quot;, &quot;Treatment&quot;), each=30))
)

# Run pipeline
pipeline_results &lt;- statistical_analysis_pipeline(
  data = example_data,
  dependent_var = &quot;score&quot;,
  independent_vars = &quot;group&quot;
)</code></pre>
            </div>
            
<hr class="content-hr">
</section>

            <section class="content-section" id="10-books-reference-as-per-karnataka-university-dharwad">
                <h2 class="section-heading"><strong>10. Books Reference as per Karnataka University Dharwad</strong></h2>
            
</section>

            <section class="content-section" id="primary-references">
                <h3 class="section-heading"><strong>Primary References:</strong></h3>
            
<ol class="content-list"><li><strong>Tilman M. Davies (2016)</strong> - "The Book of R"</li></ol>
<p class="paragraph">- Chapters 13-16 cover statistical testing and modelling
   - Comprehensive coverage of hypothesis testing, ANOVA
   - Practical R examples throughout</p>
<ol class="content-list"><li><strong>Vishwas R. Pawgi (2022)</strong> - "Statistical Computing using R Software"</li></ol>
<p class="paragraph">- Chapters 8-11 cover Unit 3 topics
   - Indian context and examples
   - Exam-oriented approach with problems</p>
</section>

            <section class="content-section" id="additional-references">
                <h3 class="section-heading"><strong>Additional References:</strong></h3>
            
<ul class="content-list"><li>Montgomery (2012) - "Design and Analysis of Experiments"</li>
<li>Kutner et al. (2004) - "Applied Linear Statistical Models"</li>
<li>Field et al. (2012) - "Discovering Statistics Using R"</li></ul>
</section>

            <section class="content-section" id="r-specific-references">
                <h3 class="section-heading"><strong>R-specific References:</strong></h3>
            
<ul class="content-list"><li>Crawley (2012) - "The R Book" (Chapters on ANOVA and modelling)</li>
<li>Kabacoff (2015) - "R in Action" (Statistical analysis chapters)</li></ul>
<hr class="content-hr">
</section>

            <section class="content-section" id="important-formulas-reference">
                <h2 class="section-heading"><strong>Important Formulas Reference</strong></h2>
            
</section>

            <section class="content-section" id="hypothesis-testing-formulas">
                <h3 class="section-heading"><strong>Hypothesis Testing Formulas</strong></h3>
            
<ol class="content-list"><li><strong>Test Statistics</strong>:</li></ol>
<p class="paragraph">- One-sample t-test: <code>t = (x̄ - μ₀) / (s/√n)</code>
   - Two-sample t-test: <code>t = (x̄₁ - x̄₂) / √(s_p²(1/n₁ + 1/n₂))</code>
   - Z-test for proportion: <code>z = (p̂ - p₀) / √(p₀(1-p₀)/n)</code>
   - Chi-square: <code>χ² = Σ((O-E)²/E)</code>
   - F-test (ANOVA): <code>F = MSB/MSW</code></p>
<ol class="content-list"><li><strong>Effect Sizes</strong>:</li></ol>
<p class="paragraph">- Cohen's d: <code>d = (x̄₁ - x̄₂) / s_pooled</code>
   - Eta-squared: <code>η² = SSB/SST</code>
   - Cramer's V: <code>V = √(χ²/(n(k-1)))</code>
   - Phi coefficient: <code>φ = √(χ²/n)</code></p>
</section>

            <section class="content-section" id="anova-formulas">
                <h3 class="section-heading"><strong>ANOVA Formulas</strong></h3>
            
<ol class="content-list"><li><strong>Sum of Squares</strong>:</li></ol>
<p class="paragraph">- SST = ΣΣ(x_ij - x̄)²
   - SSB = Σn_i(x̄_i - x̄)²
   - SSW = ΣΣ(x_ij - x̄_i)²</p>
<ol class="content-list"><li><strong>Mean Squares</strong>:</li></ol>
<p class="paragraph">- MSB = SSB/(k-1)
   - MSW = SSW/(N-k)</p>
<ol class="content-list"><li><strong>F-statistic</strong>: F = MSB/MSW</li></ol>
<hr class="content-hr">
</section>

            <section class="content-section" id="examination-preparation">
                <h2 class="section-heading"><strong>Examination Preparation</strong></h2>
            
</section>

            <section class="content-section" id="key-concepts-for-exams">
                <h3 class="section-heading"><strong>Key Concepts for Exams:</strong></h3>
            
<ol class="content-list"><li><strong>Test Selection Criteria</strong>:</li></ol>
<p class="paragraph">- Number of groups
   - Dependent variable type
   - Independence of observations
   - Assumptions (normality, homogeneity)</p>
<ol class="content-list"><li><strong>Interpretation Guidelines</strong>:</li></ol>
<p class="paragraph">- p-value vs significance level
   - Effect size interpretation
   - Confidence intervals
   - Practical vs statistical significance</p>
<ol class="content-list"><li><strong>Common Mistakes to Avoid</strong>:</li></ol>
<p class="paragraph">- Using parametric tests without checking assumptions
   - Interpreting non-significant results as "no effect"
   - Confusing correlation with causation
   - Ignoring effect sizes</p>
</section>

            <section class="content-section" id="problem-solving-framework">
                <h3 class="section-heading"><strong>Problem-Solving Framework:</strong></h3>
            

            <div class="code-block">
                <pre><code class="language-r"># Template for statistical problems
solve_stat_problem &lt;- function() {
  cat(&quot;1. State the research question\n&quot;)
  cat(&quot;2. Identify variables and their types\n&quot;)
  cat(&quot;3. Choose appropriate statistical test\n&quot;)
  cat(&quot;4. Check assumptions\n&quot;)
  cat(&quot;5. Perform the test\n&quot;)
  cat(&quot;6. Interpret results (p-value, effect size)\n&quot;)
  cat(&quot;7. State conclusions in context\n&quot;)
}</code></pre>
            </div>
            
</section>

            <section class="content-section" id="practice-problems-with-r-code">
                <h3 class="section-heading"><strong>Practice Problems with R Code:</strong></h3>
            

            <div class="code-block">
                <pre><code class="language-r"># Practice Problem 1: Compare three teaching methods
# Data: Scores from three different teaching methods
method_A &lt;- rnorm(25, mean=75, sd=10)
method_B &lt;- rnorm(25, mean=80, sd=10)
method_C &lt;- rnorm(25, mean=70, sd=10)

# Perform appropriate test
# 1. Check normality
shapiro.test(method_A)
shapiro.test(method_B)
shapiro.test(method_C)

# 2. Check homogeneity of variance
bartlett.test(list(method_A, method_B, method_C))

# 3. Perform ANOVA
anova_result &lt;- aov(c(method_A, method_B, method_C) ~ 
                    factor(rep(1:3, each=25)))
summary(anova_result)

# 4. Post-hoc test if significant
TukeyHSD(anova_result)

# Practice Problem 2: Test proportion
# Claim: 60% of students prefer online classes
# Survey: 45 out of 70 prefer online
prop.test(45, 70, p=0.6, alternative=&quot;two.sided&quot;)</code></pre>
            </div>
            
<p class="paragraph"><strong>Unit 4: Regression & Advanced Graphics (Comprehensive Guide)</strong></p>
</section>

            <section class="content-section" id="1-simple-linear-regression">
                <h2 class="section-heading"><strong>1. Simple Linear Regression</strong></h2>
            
</section>

            <section class="content-section" id="a-fundamental-concepts">
                <h3 class="section-heading"><strong>A. Fundamental Concepts</strong></h3>
            
<ul class="content-list"><li><strong>Definition</strong>: Statistical method to model relationship between one independent variable (predictor) and one dependent variable (response)</li>
<li><strong>Model</strong>: <code>Y = β₀ + β₁X + ε</code></li></ul>
<p class="paragraph">- <code>Y</code>: Dependent/response variable
  - <code>X</code>: Independent/predictor variable
  - <code>β₀</code>: Intercept (value of Y when X=0)
  - <code>β₁</code>: Slope (change in Y per unit change in X)
  - <code>ε</code>: Error term (random variation)</p>
</section>

            <section class="content-section" id="b-mathematical-formulation">
                <h3 class="section-heading"><strong>B. Mathematical Formulation</strong></h3>
            

            <div class="code-block">
                <pre><code class="language-r"># Mathematical implementation of simple linear regression
simple_linear_regression_manual &lt;- function(x, y) {
  # 1. Calculate basic statistics
  n &lt;- length(x)
  mean_x &lt;- mean(x)
  mean_y &lt;- mean(y)
  
  # 2. Calculate sums of squares
  SS_xy &lt;- sum((x - mean_x) * (y - mean_y))
  SS_xx &lt;- sum((x - mean_x)^2)
  SS_yy &lt;- sum((y - mean_y)^2)
  
  # 3. Calculate regression coefficients
  beta1 &lt;- SS_xy / SS_xx  # Slope
  beta0 &lt;- mean_y - beta1 * mean_x  # Intercept
  
  # 4. Calculate fitted values and residuals
  y_hat &lt;- beta0 + beta1 * x
  residuals &lt;- y - y_hat
  
  # 5. Calculate variance and standard errors
  sigma_squared &lt;- sum(residuals^2) / (n - 2)  # MSE
  se_beta0 &lt;- sqrt(sigma_squared * (1/n + mean_x^2/SS_xx))
  se_beta1 &lt;- sqrt(sigma_squared / SS_xx)
  
  # 6. t-statistics and p-values
  t_beta0 &lt;- beta0 / se_beta0
  t_beta1 &lt;- beta1 / se_beta1
  p_beta0 &lt;- 2 * pt(-abs(t_beta0), df = n-2)
  p_beta1 &lt;- 2 * pt(-abs(t_beta1), df = n-2)
  
  # 7. Confidence intervals (95%)
  t_critical &lt;- qt(0.975, df = n-2)
  ci_beta0 &lt;- beta0 + c(-1, 1) * t_critical * se_beta0
  ci_beta1 &lt;- beta1 + c(-1, 1) * t_critical * se_beta1
  
  # 8. R-squared and adjusted R-squared
  SS_residual &lt;- sum(residuals^2)
  SS_total &lt;- SS_yy
  r_squared &lt;- 1 - (SS_residual / SS_total)
  adj_r_squared &lt;- 1 - (SS_residual/(n-2)) / (SS_total/(n-1))
  
  # 9. F-statistic for overall model
  SS_regression &lt;- sum((y_hat - mean_y)^2)
  MS_regression &lt;- SS_regression / 1
  MS_residual &lt;- SS_residual / (n-2)
  F_stat &lt;- MS_regression / MS_residual
  p_F &lt;- pf(F_stat, df1 = 1, df2 = n-2, lower.tail = FALSE)
  
  # 10. Correlation coefficient
  correlation &lt;- SS_xy / sqrt(SS_xx * SS_yy)
  
  # 11. Diagnostic statistics
  # Standardized residuals
  std_residuals &lt;- residuals / sqrt(sigma_squared)
  
  # Leverage (hat values)
  leverage &lt;- 1/n + (x - mean_x)^2 / SS_xx
  
  # Cook&#x27;s distance
  cooks_d &lt;- (std_residuals^2 / 2) * (leverage / (1 - leverage))
  
  # Durbin-Watson for autocorrelation
  dw_stat &lt;- sum(diff(residuals)^2) / sum(residuals^2)
  
  return(list(
    coefficients = data.frame(
      term = c(&quot;(Intercept)&quot;, &quot;x&quot;),
      estimate = c(beta0, beta1),
      std_error = c(se_beta0, se_beta1),
      t_value = c(t_beta0, t_beta1),
      p_value = c(p_beta0, p_beta1),
      ci_lower = c(ci_beta0[1], ci_beta1[1]),
      ci_upper = c(ci_beta0[2], ci_beta1[2])
    ),
    model_stats = list(
      r_squared = r_squared,
      adj_r_squared = adj_r_squared,
      sigma = sqrt(sigma_squared),
      f_statistic = F_stat,
      f_p_value = p_F,
      correlation = correlation,
      n = n,
      df = c(regression = 1, residual = n-2, total = n-1)
    ),
    sums_of_squares = list(
      SS_regression = SS_regression,
      SS_residual = SS_residual,
      SS_total = SS_total
    ),
    diagnostics = list(
      residuals = residuals,
      standardized_residuals = std_residuals,
      fitted_values = y_hat,
      leverage = leverage,
      cooks_distance = cooks_d,
      durbin_watson = dw_stat
    ),
    formula = &quot;y = β₀ + β₁x + ε&quot;,
    manual_calculations = list(
      mean_x = mean_x,
      mean_y = mean_y,
      SS_xx = SS_xx,
      SS_xy = SS_xy,
      SS_yy = SS_yy
    )
  ))
}

# C. Comprehensive Example with Visualization
simple_linear_regression_demo &lt;- function() {
  set.seed(123)
  
  # Generate synthetic data with linear relationship
  n &lt;- 100
  x &lt;- seq(10, 100, length.out = n)
  true_beta0 &lt;- 20
  true_beta1 &lt;- 1.5
  error &lt;- rnorm(n, mean = 0, sd = 15)
  y &lt;- true_beta0 + true_beta1 * x + error
  
  # Create data frame
  data &lt;- data.frame(x = x, y = y)
  
  # Manual calculation
  manual_results &lt;- simple_linear_regression_manual(x, y)
  
  # Built-in lm function for comparison
  lm_model &lt;- lm(y ~ x, data = data)
  lm_summary &lt;- summary(lm_model)
  lm_confint &lt;- confint(lm_model)
  
  # Visualization 1: Scatter plot with regression line
  par(mfrow = c(2, 3))
  
  # Plot 1: Scatter plot with regression line
  plot(x, y, pch = 19, col = rgb(0, 0, 1, 0.5), cex = 1.2,
       main = &quot;Simple Linear Regression&quot;,
       xlab = &quot;Predictor (X)&quot;, ylab = &quot;Response (Y)&quot;,
       xlim = c(min(x), max(x)), ylim = c(min(y), max(y)))
  
  # Add regression line
  abline(lm_model, col = &quot;red&quot;, lwd = 3)
  
  # Add confidence band
  new_x &lt;- seq(min(x), max(x), length.out = 100)
  pred &lt;- predict(lm_model, newdata = data.frame(x = new_x), 
                  interval = &quot;confidence&quot;)
  lines(new_x, pred[, &quot;lwr&quot;], col = &quot;red&quot;, lty = 2, lwd = 2)
  lines(new_x, pred[, &quot;upr&quot;], col = &quot;red&quot;, lty = 2, lwd = 2)
  
  # Add prediction band
  pred_pred &lt;- predict(lm_model, newdata = data.frame(x = new_x),
                       interval = &quot;prediction&quot;)
  lines(new_x, pred_pred[, &quot;lwr&quot;], col = &quot;blue&quot;, lty = 3, lwd = 2)
  lines(new_x, pred_pred[, &quot;upr&quot;], col = &quot;blue&quot;, lty = 3, lwd = 2)
  
  legend(&quot;topleft&quot;,
         legend = c(&quot;Data&quot;, &quot;Regression line&quot;, 
                   &quot;95% Confidence band&quot;, &quot;95% Prediction band&quot;),
         col = c(&quot;blue&quot;, &quot;red&quot;, &quot;red&quot;, &quot;blue&quot;),
         lty = c(NA, 1, 2, 3), lwd = c(NA, 3, 2, 2),
         pch = c(19, NA, NA, NA), bg = &quot;white&quot;)
  
  # Plot 2: Residuals vs Fitted
  plot(fitted(lm_model), residuals(lm_model),
       pch = 19, col = rgb(0, 0.5, 0, 0.6),
       main = &quot;Residuals vs Fitted Values&quot;,
       xlab = &quot;Fitted Values&quot;, ylab = &quot;Residuals&quot;)
  abline(h = 0, col = &quot;red&quot;, lwd = 2, lty = 2)
  
  # Add LOWESS smoother
  lines(lowess(fitted(lm_model), residuals(lm_model)), 
        col = &quot;blue&quot;, lwd = 2)
  
  # Plot 3: Q-Q plot of residuals
  qqnorm(residuals(lm_model), pch = 19, col = &quot;darkgreen&quot;,
         main = &quot;Normal Q-Q Plot of Residuals&quot;)
  qqline(residuals(lm_model), col = &quot;red&quot;, lwd = 2)
  
  # Add Shapiro-Wilk test annotation
  shapiro_test &lt;- shapiro.test(residuals(lm_model))
  text(min(residuals(lm_model)), max(residuals(lm_model)) * 0.9,
       paste(&quot;Shapiro-Wilk p =&quot;, 
             format.pval(shapiro_test$p.value, digits = 3)),
       pos = 4, col = &quot;darkred&quot;)
  
  # Plot 4: Scale-Location plot
  sqrt_abs_resid &lt;- sqrt(abs(residuals(lm_model)))
  plot(fitted(lm_model), sqrt_abs_resid,
       pch = 19, col = rgb(0.5, 0, 0.5, 0.6),
       main = &quot;Scale-Location Plot&quot;,
       xlab = &quot;Fitted Values&quot;, 
       ylab = expression(sqrt(&quot;|Standardized Residuals|&quot;)))
  lines(lowess(fitted(lm_model), sqrt_abs_resid), 
        col = &quot;blue&quot;, lwd = 2)
  
  # Plot 5: Residuals vs Leverage
  plot(hatvalues(lm_model), residuals(lm_model),
       pch = 19, col = rgb(1, 0.5, 0, 0.6),
       main = &quot;Residuals vs Leverage&quot;,
       xlab = &quot;Leverage&quot;, ylab = &quot;Residuals&quot;)
  abline(h = 0, col = &quot;red&quot;, lwd = 1, lty = 2)
  
  # Add Cook&#x27;s distance contours
  cook_levels &lt;- c(0.5, 1)
  n &lt;- length(x)
  p &lt;- 2  # Number of parameters
  for (level in cook_levels) {
    x_seq &lt;- seq(min(hatvalues(lm_model)), max(hatvalues(lm_model)), 
                 length.out = 100)
    y_upper &lt;- sqrt(level * p * (1 - x_seq) / x_seq)
    y_lower &lt;- -y_upper
    lines(x_seq, y_upper, col = &quot;red&quot;, lty = 2)
    lines(x_seq, y_lower, col = &quot;red&quot;, lty = 2)
    text(max(x_seq), max(y_upper), 
         paste(&quot;Cook&#x27;s D =&quot;, level), pos = 2, cex = 0.8, col = &quot;red&quot;)
  }
  
  # Highlight high leverage points
  high_leverage &lt;- hatvalues(lm_model) &gt; 2 * p / n
  if (any(high_leverage)) {
    points(hatvalues(lm_model)[high_leverage], 
           residuals(lm_model)[high_leverage],
           pch = 21, col = &quot;red&quot;, bg = &quot;yellow&quot;, cex = 1.5)
  }
  
  # Plot 6: Histogram of residuals
  hist(residuals(lm_model), breaks = 20, col = &quot;lightblue&quot;,
       main = &quot;Distribution of Residuals&quot;,
       xlab = &quot;Residuals&quot;, freq = FALSE)
  curve(dnorm(x, mean = mean(residuals(lm_model)), 
              sd = sd(residuals(lm_model))),
        add = TRUE, col = &quot;red&quot;, lwd = 2)
  
  par(mfrow = c(1, 1))
  
  # D. Model Summary and Comparison
  cat(&quot;SIMPLE LINEAR REGRESSION ANALYSIS\n&quot;)
  cat(&quot;=================================\n\n&quot;)
  
  cat(&quot;1. MODEL FORMULA:\n&quot;)
  cat(&quot;   y =&quot;, round(manual_results$coefficients$estimate[1], 3), 
      &quot;+&quot;, round(manual_results$coefficients$estimate[2], 3), &quot;* x\n\n&quot;)
  
  cat(&quot;2. COEFFICIENTS:\n&quot;)
  print(manual_results$coefficients)
  cat(&quot;\n&quot;)
  
  cat(&quot;3. MODEL STATISTICS:\n&quot;)
  cat(&quot;   R-squared:&quot;, round(manual_results$model_stats$r_squared, 4), &quot;\n&quot;)
  cat(&quot;   Adjusted R-squared:&quot;, round(manual_results$model_stats$adj_r_squared, 4), &quot;\n&quot;)
  cat(&quot;   Residual Standard Error:&quot;, round(manual_results$model_stats$sigma, 3), &quot;\n&quot;)
  cat(&quot;   F-statistic:&quot;, round(manual_results$model_stats$f_statistic, 3), &quot;\n&quot;)
  cat(&quot;   p-value (F-test):&quot;, format.pval(manual_results$model_stats$f_p_value, digits = 3), &quot;\n&quot;)
  cat(&quot;   Correlation (r):&quot;, round(manual_results$model_stats$correlation, 4), &quot;\n\n&quot;)
  
  cat(&quot;4. DIAGNOSTIC TESTS:\n&quot;)
  cat(&quot;   Shapiro-Wilk normality test p-value:&quot;, 
      format.pval(shapiro_test$p.value, digits = 3), &quot;\n&quot;)
  cat(&quot;   Durbin-Watson statistic:&quot;, 
      round(manual_results$diagnostics$durbin_watson, 3), &quot;\n&quot;)
  
  # Breusch-Pagan test for heteroscedasticity
  if (requireNamespace(&quot;lmtest&quot;, quietly = TRUE)) {
    bp_test &lt;- lmtest::bptest(lm_model)
    cat(&quot;   Breusch-Pagan test p-value:&quot;, 
        format.pval(bp_test$p.value, digits = 3), &quot;\n&quot;)
  }
  
  # E. Prediction Example
  cat(&quot;\n5. PREDICTION EXAMPLE:\n&quot;)
  new_x_values &lt;- c(30, 50, 80)
  predictions &lt;- predict(lm_model, 
                         newdata = data.frame(x = new_x_values),
                         interval = &quot;prediction&quot;)
  
  pred_df &lt;- data.frame(
    x = new_x_values,
    predicted_y = predictions[, &quot;fit&quot;],
    lower_ci = predictions[, &quot;lwr&quot;],
    upper_ci = predictions[, &quot;upr&quot;]
  )
  
  print(pred_df)
  
  # F. Return comprehensive results
  return(list(
    data = data,
    manual_results = manual_results,
    lm_model = lm_model,
    lm_summary = lm_summary,
    diagnostics = list(
      shapiro_test = shapiro_test,
      residuals_plot = list(
        fitted = fitted(lm_model),
        residuals = residuals(lm_model),
        standardized = rstandard(lm_model)
      )
    ),
    predictions = pred_df
  ))
}

# Run the demonstration
slr_demo &lt;- simple_linear_regression_demo()</code></pre>
            </div>
            

            <div class="special-block reference">
                <div class="special-label">Reference: Davies (2016) Chapter 17; Pawgi (2022) Chapter 12</div>
                <div class="special-content"></div>
            </div>
            
<hr class="content-hr">
</section>

            <section class="content-section" id="2-multiple-linear-regression">
                <h2 class="section-heading"><strong>2. Multiple Linear Regression</strong></h2>
            
</section>

            <section class="content-section" id="a-fundamental-concepts">
                <h3 class="section-heading"><strong>A. Fundamental Concepts</strong></h3>
            
<ul class="content-list"><li><strong>Definition</strong>: Extension of simple linear regression with multiple predictors</li>
<li><strong>Model</strong>: <code>Y = β₀ + β₁X₁ + β₂X₂ + ... + βₖXₖ + ε</code></li>
<li><strong>Matrix Form</strong>: <code>Y = Xβ + ε</code></li></ul>
<p class="paragraph">- <code>Y</code>: n×1 response vector
  - <code>X</code>: n×(k+1) design matrix
  - <code>β</code>: (k+1)×1 parameter vector
  - <code>ε</code>: n×1 error vector</p>
</section>

            <section class="content-section" id="b-mathematical-implementation">
                <h3 class="section-heading"><strong>B. Mathematical Implementation</strong></h3>
            

            <div class="code-block">
                <pre><code class="language-r"># Manual implementation of multiple linear regression
multiple_linear_regression_manual &lt;- function(formula, data) {
  # Extract variables from formula
  mf &lt;- model.frame(formula, data)
  y &lt;- model.response(mf)
  X &lt;- model.matrix(formula, data)
  
  n &lt;- nrow(X)  # Number of observations
  p &lt;- ncol(X)  # Number of parameters (including intercept)
  
  # 1. Estimate coefficients using matrix algebra
  # β = (X&#x27;X)^(-1) X&#x27;y
  XtX &lt;- t(X) %*% X
  XtX_inv &lt;- solve(XtX)
  beta_hat &lt;- XtX_inv %*% t(X) %*% y
  
  # 2. Calculate fitted values and residuals
  y_hat &lt;- X %*% beta_hat
  residuals &lt;- y - y_hat
  
  # 3. Calculate variance-covariance matrix
  sigma_squared &lt;- as.numeric(t(residuals) %*% residuals / (n - p))
  vcov_beta &lt;- sigma_squared * XtX_inv
  
  # 4. Standard errors of coefficients
  se_beta &lt;- sqrt(diag(vcov_beta))
  
  # 5. t-statistics and p-values
  t_stats &lt;- beta_hat / se_beta
  p_values &lt;- 2 * pt(-abs(t_stats), df = n - p)
  
  # 6. Confidence intervals
  t_critical &lt;- qt(0.975, df = n - p)
  ci_lower &lt;- beta_hat - t_critical * se_beta
  ci_upper &lt;- beta_hat + t_critical * se_beta
  
  # 7. R-squared and adjusted R-squared
  y_mean &lt;- mean(y)
  SS_total &lt;- sum((y - y_mean)^2)
  SS_residual &lt;- sum(residuals^2)
  SS_regression &lt;- SS_total - SS_residual
  r_squared &lt;- SS_regression / SS_total
  adj_r_squared &lt;- 1 - (SS_residual/(n-p)) / (SS_total/(n-1))
  
  # 8. F-test for overall model
  MS_regression &lt;- SS_regression / (p - 1)
  MS_residual &lt;- SS_residual / (n - p)
  F_stat &lt;- MS_regression / MS_residual
  p_F &lt;- pf(F_stat, df1 = p-1, df2 = n-p, lower.tail = FALSE)
  
  # 9. Calculate VIF for multicollinearity
  vif &lt;- numeric(p)
  for (j in 2:p) {  # Skip intercept
    # Regress j-th predictor on all other predictors
    X_other &lt;- X[, -j, drop = FALSE]
    if (ncol(X_other) &gt; 1) {  # Check if there are other predictors
      beta_temp &lt;- solve(t(X_other) %*% X_other) %*% t(X_other) %*% X[, j]
      y_hat_temp &lt;- X_other %*% beta_temp
      residuals_temp &lt;- X[, j] - y_hat_temp
      r_squared_temp &lt;- 1 - sum(residuals_temp^2) / sum((X[, j] - mean(X[, j]))^2)
      vif[j] &lt;- 1 / (1 - r_squared_temp)
    } else {
      vif[j] &lt;- 1
    }
  }
  
  # 10. Calculate standardized coefficients (beta weights)
  # Standardize variables
  X_scaled &lt;- scale(X[, -1], center = TRUE, scale = TRUE)  # Exclude intercept
  y_scaled &lt;- scale(y, center = TRUE, scale = TRUE)
  
  if (ncol(X_scaled) &gt; 0) {
    beta_standardized &lt;- solve(t(X_scaled) %*% X_scaled) %*% 
                         t(X_scaled) %*% y_scaled
  } else {
    beta_standardized &lt;- numeric(0)
  }
  
  # 11. Create coefficient table
  coef_table &lt;- data.frame(
    term = colnames(X),
    estimate = as.numeric(beta_hat),
    std_error = se_beta,
    t_value = as.numeric(t_stats),
    p_value = p_values,
    ci_lower = as.numeric(ci_lower),
    ci_upper = as.numeric(ci_upper),
    vif = vif
  )
  
  # Add standardized coefficients
  if (length(beta_standardized) &gt; 0) {
    coef_table$std_coefficient &lt;- c(NA, as.numeric(beta_standardized))
  } else {
    coef_table$std_coefficient &lt;- NA
  }
  
  # 12. Diagnostic statistics
  # Standardized residuals
  std_residuals &lt;- residuals / sqrt(sigma_squared)
  
  # Leverage (hat values)
  leverage &lt;- diag(X %*% XtX_inv %*% t(X))
  
  # Cook&#x27;s distance
  cooks_d &lt;- (std_residuals^2 / p) * (leverage / (1 - leverage)^2)
  
  # DFFITS
  dffits &lt;- std_residuals * sqrt(leverage / (1 - leverage))
  
  return(list(
    formula = formula,
    coefficients = coef_table,
    model_stats = list(
      r_squared = r_squared,
      adj_r_squared = adj_r_squared,
      sigma = sqrt(sigma_squared),
      f_statistic = F_stat,
      f_p_value = p_F,
      n = n,
      df = c(regression = p-1, residual = n-p, total = n-1),
      AIC = n * log(SS_residual/n) + 2*p,
      BIC = n * log(SS_residual/n) + p * log(n)
    ),
    sums_of_squares = list(
      SS_regression = SS_regression,
      SS_residual = SS_residual,
      SS_total = SS_total
    ),
    diagnostics = list(
      residuals = as.numeric(residuals),
      standardized_residuals = as.numeric(std_residuals),
      fitted_values = as.numeric(y_hat),
      leverage = leverage,
      cooks_distance = cooks_d,
      dffits = dffits,
      vif = vif,
      condition_number = kappa(X, exact = TRUE)
    ),
    matrix_calculations = list(
      X = X,
      XtX = XtX,
      XtX_inv = XtX_inv,
      vcov_matrix = vcov_beta
    )
  ))
}

# C. Comprehensive Multiple Regression Example
multiple_linear_regression_demo &lt;- function() {
  # Create synthetic dataset with multiple predictors
  set.seed(123)
  n &lt;- 200
  
  # Generate predictors
  x1 &lt;- rnorm(n, mean = 50, sd = 10)
  x2 &lt;- rnorm(n, mean = 30, sd = 5)
  x3 &lt;- 0.8 * x1 + 0.2 * x2 + rnorm(n, sd = 2)  # Correlated with x1 and x2
  x4 &lt;- rnorm(n, mean = 100, sd = 20)
  
  # Generate response variable
  true_beta &lt;- c(10, 0.5, 1.2, -0.3, 0.05)  # Intercept + 4 slopes
  error &lt;- rnorm(n, mean = 0, sd = 5)
  y &lt;- true_beta[1] + true_beta[2] * x1 + true_beta[3] * x2 + 
       true_beta[4] * x3 + true_beta[5] * x4 + error
  
  # Create data frame
  data &lt;- data.frame(y = y, x1 = x1, x2 = x2, x3 = x3, x4 = x4)
  
  # 1. Full model with all predictors
  formula_full &lt;- y ~ x1 + x2 + x3 + x4
  manual_full &lt;- multiple_linear_regression_manual(formula_full, data)
  
  # Built-in lm function for comparison
  lm_full &lt;- lm(formula_full, data = data)
  lm_summary_full &lt;- summary(lm_full)
  
  # 2. Model without multicollinear predictor
  formula_reduced &lt;- y ~ x1 + x2 + x4
  lm_reduced &lt;- lm(formula_reduced, data = data)
  
  # 3. Stepwise selection
  if (requireNamespace(&quot;MASS&quot;, quietly = TRUE)) {
    # Forward selection
    null_model &lt;- lm(y ~ 1, data = data)
    forward_model &lt;- step(null_model,
                         scope = list(lower = null_model, upper = lm_full),
                         direction = &quot;forward&quot;, trace = 0)
    
    # Backward elimination
    backward_model &lt;- step(lm_full,
                          direction = &quot;backward&quot;, trace = 0)
    
    # Stepwise (both directions)
    stepwise_model &lt;- step(null_model,
                          scope = list(lower = null_model, upper = lm_full),
                          direction = &quot;both&quot;, trace = 0)
  }
  
  # D. Comprehensive Visualization
  par(mfrow = c(3, 3))
  
  # Plot 1: Pairwise scatter plots
  pairs(data, pch = 19, col = rgb(0, 0, 1, 0.3),
        main = &quot;Pairwise Scatter Plots&quot;)
  
  # Plot 2: Correlation matrix heatmap
  cor_matrix &lt;- cor(data)
  corrplot::corrplot(cor_matrix, method = &quot;color&quot;, type = &quot;upper&quot;,
                     addCoef.col = &quot;black&quot;, tl.col = &quot;black&quot;,
                     main = &quot;Correlation Matrix&quot;)
  
  # Plot 3: Actual vs Predicted
  plot(data$y, fitted(lm_full), pch = 19, col = &quot;blue&quot;,
       main = &quot;Actual vs Predicted Values&quot;,
       xlab = &quot;Actual Y&quot;, ylab = &quot;Predicted Y&quot;)
  abline(0, 1, col = &quot;red&quot;, lwd = 2)
  lines(lowess(data$y, fitted(lm_full)), col = &quot;green&quot;, lwd = 2)
  
  # Plot 4: Residuals vs Fitted
  plot(fitted(lm_full), residuals(lm_full), pch = 19, col = &quot;darkgreen&quot;,
       main = &quot;Residuals vs Fitted&quot;,
       xlab = &quot;Fitted Values&quot;, ylab = &quot;Residuals&quot;)
  abline(h = 0, col = &quot;red&quot;, lwd = 2)
  lines(lowess(fitted(lm_full), residuals(lm_full)), col = &quot;blue&quot;, lwd = 2)
  
  # Plot 5: Q-Q plot of residuals
  qqnorm(residuals(lm_full), pch = 19, col = &quot;purple&quot;,
         main = &quot;Normal Q-Q Plot&quot;)
  qqline(residuals(lm_full), col = &quot;red&quot;, lwd = 2)
  
  # Plot 6: Cook&#x27;s distance
  plot(cooks.distance(lm_full), type = &quot;h&quot;, col = &quot;red&quot;,
       main = &quot;Cook&#x27;s Distance&quot;,
       xlab = &quot;Observation Index&quot;, ylab = &quot;Cook&#x27;s Distance&quot;)
  abline(h = 4/n, col = &quot;blue&quot;, lty = 2)
  text(n*0.8, 4/n*1.2, &quot;Threshold = 4/n&quot;, col = &quot;blue&quot;)
  
  # Plot 7: Leverage vs Residuals
  plot(hatvalues(lm_full), rstudent(lm_full), pch = 19, col = &quot;orange&quot;,
       main = &quot;Leverage vs Studentized Residuals&quot;,
       xlab = &quot;Leverage (Hat Values)&quot;, ylab = &quot;Studentized Residuals&quot;)
  abline(h = c(-2, 2), col = &quot;red&quot;, lty = 2)
  abline(v = 2*length(coef(lm_full))/n, col = &quot;blue&quot;, lty = 2)
  
  # Plot 8: Partial regression plots (Added Variable Plots)
  # For x1
  avPlot(lm_full, variable = &quot;x1&quot;, main = &quot;Added Variable Plot for x1&quot;,
         pch = 19, col = &quot;blue&quot;, lwd = 2)
  
  # Plot 9: Coefficient plot
  coef_plot_data &lt;- manual_full$coefficients
  coef_plot_data &lt;- coef_plot_data[coef_plot_data$term != &quot;(Intercept)&quot;, ]
  
  plot(1:nrow(coef_plot_data), coef_plot_data$estimate,
       xlim = c(0.5, nrow(coef_plot_data) + 0.5),
       ylim = range(c(coef_plot_data$ci_lower, coef_plot_data$ci_upper)),
       pch = 19, cex = 1.5, col = &quot;blue&quot;,
       main = &quot;Coefficient Estimates with 95% CI&quot;,
       xlab = &quot;&quot;, ylab = &quot;Coefficient Value&quot;,
       xaxt = &quot;n&quot;)
  axis(1, at = 1:nrow(coef_plot_data), labels = coef_plot_data$term)
  
  # Add confidence intervals
  arrows(1:nrow(coef_plot_data), coef_plot_data$ci_lower,
         1:nrow(coef_plot_data), coef_plot_data$ci_upper,
         angle = 90, code = 3, length = 0.1, col = &quot;blue&quot;, lwd = 2)
  
  abline(h = 0, col = &quot;red&quot;, lty = 2)
  
  par(mfrow = c(1, 1))
  
  # E. Model Comparison Table
  cat(&quot;MULTIPLE LINEAR REGRESSION ANALYSIS\n&quot;)
  cat(&quot;====================================\n\n&quot;)
  
  cat(&quot;1. FULL MODEL SUMMARY:\n&quot;)
  cat(&quot;   Formula:&quot;, deparse(formula_full), &quot;\n&quot;)
  cat(&quot;   R-squared:&quot;, round(manual_full$model_stats$r_squared, 4), &quot;\n&quot;)
  cat(&quot;   Adjusted R-squared:&quot;, round(manual_full$model_stats$adj_r_squared, 4), &quot;\n&quot;)
  cat(&quot;   F-statistic:&quot;, round(manual_full$model_stats$f_statistic, 3), &quot;\n&quot;)
  cat(&quot;   p-value:&quot;, format.pval(manual_full$model_stats$f_p_value, digits = 3), &quot;\n&quot;)
  cat(&quot;   Residual SE:&quot;, round(manual_full$model_stats$sigma, 3), &quot;\n&quot;)
  cat(&quot;   Condition Number:&quot;, round(manual_full$diagnostics$condition_number, 3), &quot;\n\n&quot;)
  
  cat(&quot;2. COEFFICIENT SUMMARY:\n&quot;)
  print(manual_full$coefficients)
  cat(&quot;\n&quot;)
  
  cat(&quot;3. MULTICOLLINEARITY DIAGNOSTICS:\n&quot;)
  vif_table &lt;- data.frame(
    Variable = manual_full$coefficients$term,
    VIF = round(manual_full$coefficients$vif, 3)
  )
  print(vif_table)
  cat(&quot;\n   VIF &gt; 10 indicates serious multicollinearity\n\n&quot;)
  
  cat(&quot;4. MODEL COMPARISON:\n&quot;)
  models &lt;- list(
    &quot;Full&quot; = lm_full,
    &quot;Reduced&quot; = lm_reduced
  )
  
  if (exists(&quot;forward_model&quot;)) {
    models[[&quot;Forward&quot;]] &lt;- forward_model
    models[[&quot;Backward&quot;]] &lt;- backward_model
    models[[&quot;Stepwise&quot;]] &lt;- stepwise_model
  }
  
  comparison_table &lt;- do.call(rbind, lapply(names(models), function(name) {
    model &lt;- models[[name]]
    s &lt;- summary(model)
    data.frame(
      Model = name,
      Predictors = paste(names(coef(model))[-1], collapse = &quot;, &quot;),
      R2 = round(s$r.squared, 4),
      Adj_R2 = round(s$adj.r.squared, 4),
      AIC = round(AIC(model), 2),
      BIC = round(BIC(model), 2),
      Sigma = round(s$sigma, 3)
    )
  }))
  
  print(comparison_table)
  cat(&quot;\n&quot;)
  
  # F. ANOVA for model comparison
  cat(&quot;5. NESTED MODEL F-TEST:\n&quot;)
  anova_test &lt;- anova(lm_reduced, lm_full)
  print(anova_test)
  
  if (anova_test$`Pr(&gt;F)`[2] &gt; 0.05) {
    cat(&quot;\n   Conclusion: Reduced model is sufficient\n&quot;)
  } else {
    cat(&quot;\n   Conclusion: Full model is significantly better\n&quot;)
  }
  
  # G. Diagnostic tests
  cat(&quot;\n6. DIAGNOSTIC TESTS:\n&quot;)
  
  # Shapiro-Wilk normality test
  shapiro_test &lt;- shapiro.test(residuals(lm_full))
  cat(&quot;   Normality (Shapiro-Wilk): W =&quot;, 
      round(shapiro_test$statistic, 4),
      &quot;, p =&quot;, format.pval(shapiro_test$p.value, digits = 3), &quot;\n&quot;)
  
  # Breusch-Pagan test for heteroscedasticity
  if (requireNamespace(&quot;lmtest&quot;, quietly = TRUE)) {
    bp_test &lt;- lmtest::bptest(lm_full)
    cat(&quot;   Heteroscedasticity (Breusch-Pagan): BP =&quot;,
        round(bp_test$statistic, 3),
        &quot;, p =&quot;, format.pval(bp_test$p.value, digits = 3), &quot;\n&quot;)
  }
  
  # Durbin-Watson test for autocorrelation
  if (requireNamespace(&quot;lmtest&quot;, quietly = TRUE)) {
    dw_test &lt;- lmtest::dwtest(lm_full)
    cat(&quot;   Autocorrelation (Durbin-Watson): DW =&quot;,
        round(dw_test$statistic, 3),
        &quot;, p =&quot;, format.pval(dw_test$p.value, digits = 3), &quot;\n&quot;)
  }
  
  # H. Return comprehensive results
  return(list(
    data = data,
    manual_results = manual_full,
    models = models,
    comparison_table = comparison_table,
    anova_test = anova_test,
    diagnostics = list(
      shapiro_test = shapiro_test,
      bp_test = if (exists(&quot;bp_test&quot;)) bp_test else NULL,
      dw_test = if (exists(&quot;dw_test&quot;)) dw_test else NULL
    ),
    vif_table = vif_table
  ))
}

# Run the demonstration
mlr_demo &lt;- multiple_linear_regression_demo()</code></pre>
            </div>
            

            <div class="special-block reference">
                <div class="special-label">Reference: Davies (2016) Chapter 18; Pawgi (2022) Chapter 13</div>
                <div class="special-content"></div>
            </div>
            
<hr class="content-hr">
</section>

            <section class="content-section" id="3-linear-model-selection-and-diagnostics">
                <h2 class="section-heading"><strong>3. Linear Model Selection and Diagnostics</strong></h2>
            
</section>

            <section class="content-section" id="a-model-selection-techniques">
                <h3 class="section-heading"><strong>A. Model Selection Techniques</strong></h3>
            

            <div class="code-block">
                <pre><code class="language-r"># Comprehensive model selection and diagnostics
model_selection_diagnostics &lt;- function() {
  
  # 1. Create simulated dataset
  set.seed(123)
  n &lt;- 100
  p &lt;- 10  # Number of potential predictors
  
  # Generate correlated predictors
  Sigma &lt;- matrix(0.3, nrow = p, ncol = p)
  diag(Sigma) &lt;- 1
  X_raw &lt;- MASS::mvrnorm(n, mu = rep(0, p), Sigma = Sigma)
  
  # True model uses only first 3 predictors
  true_beta &lt;- c(2, 1.5, -1, rep(0, p-3))
  y &lt;- 10 + X_raw %*% true_beta + rnorm(n, sd = 2)
  
  # Create data frame
  data &lt;- data.frame(y = y)
  for (i in 1:p) {
    data[[paste0(&quot;x&quot;, i)]] &lt;- X_raw[, i]
  }
  
  # Add irrelevant polynomial terms
  data$x1_sq &lt;- data$x1^2
  data$x2_sq &lt;- data$x2^2
  data$x1_x2 &lt;- data$x1 * data$x2
  
  # Full model formula (includes all terms)
  full_formula &lt;- as.formula(paste(&quot;y ~&quot;, 
                                  paste(names(data)[-1], collapse = &quot; + &quot;)))
  
  # 2. Fit full model
  full_model &lt;- lm(full_formula, data = data)
  
  # 3. Model selection methods
  
  # A. Stepwise Selection (AIC based)
  cat(&quot;STEPWISE SELECTION METHODS\n&quot;)
  cat(&quot;===========================\n\n&quot;)
  
  # Forward selection
  null_model &lt;- lm(y ~ 1, data = data)
  forward_model &lt;- step(null_model, 
                       scope = list(lower = null_model, upper = full_model),
                       direction = &quot;forward&quot;, trace = 0)
  
  cat(&quot;Forward Selection Results:\n&quot;)
  cat(&quot;Final model:&quot;, deparse(formula(forward_model)), &quot;\n&quot;)
  cat(&quot;AIC:&quot;, round(AIC(forward_model), 2), &quot;\n\n&quot;)
  
  # Backward elimination
  backward_model &lt;- step(full_model, direction = &quot;backward&quot;, trace = 0)
  
  cat(&quot;Backward Elimination Results:\n&quot;)
  cat(&quot;Final model:&quot;, deparse(formula(backward_model)), &quot;\n&quot;)
  cat(&quot;AIC:&quot;, round(AIC(backward_model), 2), &quot;\n\n&quot;)
  
  # Stepwise (both directions)
  stepwise_model &lt;- step(null_model,
                        scope = list(lower = null_model, upper = full_model),
                        direction = &quot;both&quot;, trace = 0)
  
  cat(&quot;Stepwise Selection Results:\n&quot;)
  cat(&quot;Final model:&quot;, deparse(formula(stepwise_model)), &quot;\n&quot;)
  cat(&quot;AIC:&quot;, round(AIC(stepwise_model), 2), &quot;\n\n&quot;)
  
  # B. Information Criteria Comparison
  cat(&quot;INFORMATION CRITERIA COMPARISON\n&quot;)
  cat(&quot;===============================\n\n&quot;)
  
  models &lt;- list(
    &quot;Null&quot; = null_model,
    &quot;Full&quot; = full_model,
    &quot;Forward&quot; = forward_model,
    &quot;Backward&quot; = backward_model,
    &quot;Stepwise&quot; = stepwise_model
  )
  
  ic_table &lt;- do.call(rbind, lapply(names(models), function(name) {
    model &lt;- models[[name]]
    k &lt;- length(coef(model))
    n_obs &lt;- nobs(model)
    RSS &lt;- sum(residuals(model)^2)
    
    data.frame(
      Model = name,
      Predictors = k - 1,  # Excluding intercept
      R2 = round(summary(model)$r.squared, 4),
      Adj_R2 = round(summary(model)$adj.r.squared, 4),
      AIC = round(AIC(model), 2),
      BIC = round(BIC(model), 2),
      Cp = round(RSS/summary(full_model)$sigma^2 + 2*k - n_obs, 2)
    )
  }))
  
  print(ic_table)
  cat(&quot;\n&quot;)
  
  # C. Cross-Validation for Model Selection
  cat(&quot;CROSS-VALIDATION RESULTS\n&quot;)
  cat(&quot;========================\n\n&quot;)
  
  # Function for k-fold cross-validation
  kfold_cv &lt;- function(formula, data, k = 10) {
    n &lt;- nrow(data)
    folds &lt;- sample(rep(1:k, length.out = n))
    
    mse_values &lt;- numeric(k)
    
    for (i in 1:k) {
      # Split data
      test_indices &lt;- which(folds == i)
      train_data &lt;- data[-test_indices, ]
      test_data &lt;- data[test_indices, ]
      
      # Fit model
      model &lt;- lm(formula, data = train_data)
      
      # Predict and calculate MSE
      predictions &lt;- predict(model, newdata = test_data)
      mse_values[i] &lt;- mean((test_data$y - predictions)^2)
    }
    
    return(mean(mse_values))
  }
  
  # CV for each model
  cv_results &lt;- sapply(models, function(model) {
    kfold_cv(formula(model), data)
  })
  
  cv_table &lt;- data.frame(
    Model = names(cv_results),
    CV_MSE = round(cv_results, 4)
  )
  
  print(cv_table)
  cat(&quot;\n&quot;)
  
  # D. Regularization Methods (Ridge, Lasso, Elastic Net)
  if (requireNamespace(&quot;glmnet&quot;, quietly = TRUE)) {
    cat(&quot;REGULARIZATION METHODS\n&quot;)
    cat(&quot;======================\n\n&quot;)
    
    # Prepare data for glmnet
    x_matrix &lt;- as.matrix(data[, -1])  # All predictors
    y_vector &lt;- data$y
    
    # Ridge Regression (L2 penalty)
    ridge_cv &lt;- glmnet::cv.glmnet(x_matrix, y_vector, alpha = 0)
    ridge_lambda &lt;- ridge_cv$lambda.min
    
    # Lasso Regression (L1 penalty)
    lasso_cv &lt;- glmnet::cv.glmnet(x_matrix, y_vector, alpha = 1)
    lasso_lambda &lt;- lasso_cv$lambda.min
    
    # Elastic Net (alpha = 0.5)
    enet_cv &lt;- glmnet::cv.glmnet(x_matrix, y_vector, alpha = 0.5)
    enet_lambda &lt;- enet_cv$lambda.min
    
    cat(&quot;Optimal lambda values:\n&quot;)
    cat(&quot;  Ridge (alpha=0):&quot;, round(ridge_lambda, 4), &quot;\n&quot;)
    cat(&quot;  Lasso (alpha=1):&quot;, round(lasso_lambda, 4), &quot;\n&quot;)
    cat(&quot;  Elastic Net (alpha=0.5):&quot;, round(enet_lambda, 4), &quot;\n\n&quot;)
    
    # Coefficient paths
    par(mfrow = c(2, 2))
    
    # Ridge coefficient path
    ridge_model &lt;- glmnet::glmnet(x_matrix, y_vector, alpha = 0)
    plot(ridge_model, xvar = &quot;lambda&quot;, main = &quot;Ridge Regression Path&quot;)
    abline(v = log(ridge_lambda), col = &quot;red&quot;, lty = 2)
    
    # Lasso coefficient path
    lasso_model &lt;- glmnet::glmnet(x_matrix, y_vector, alpha = 1)
    plot(lasso_model, xvar = &quot;lambda&quot;, main = &quot;Lasso Regression Path&quot;)
    abline(v = log(lasso_lambda), col = &quot;red&quot;, lty = 2)
    
    # Elastic Net coefficient path
    enet_model &lt;- glmnet::glmnet(x_matrix, y_vector, alpha = 0.5)
    plot(enet_model, xvar = &quot;lambda&quot;, main = &quot;Elastic Net Path (alpha=0.5)&quot;)
    abline(v = log(enet_lambda), col = &quot;red&quot;, lty = 2)
    
    # Cross-validation error
    plot(lasso_cv, main = &quot;Lasso CV Error&quot;)
    
    par(mfrow = c(1, 1))
    
    # Compare coefficients
    ridge_coef &lt;- as.numeric(coef(ridge_model, s = ridge_lambda))
    lasso_coef &lt;- as.numeric(coef(lasso_model, s = lasso_lambda))
    enet_coef &lt;- as.numeric(coef(enet_model, s = enet_lambda))
    ols_coef &lt;- coef(full_model)
    
    coef_comparison &lt;- data.frame(
      Predictor = c(&quot;Intercept&quot;, colnames(x_matrix)),
      OLS = round(ols_coef, 4),
      Ridge = round(ridge_coef, 4),
      Lasso = round(lasso_coef, 4),
      ElasticNet = round(enet_coef, 4)
    )
    
    cat(&quot;Coefficient Comparison:\n&quot;)
    print(coef_comparison)
    cat(&quot;\n&quot;)
  }
  
  # E. Comprehensive Diagnostics
  cat(&quot;COMPREHENSIVE MODEL DIAGNOSTICS\n&quot;)
  cat(&quot;===============================\n\n&quot;)
  
  # Function for comprehensive diagnostics
  comprehensive_diagnostics &lt;- function(model, model_name) {
    cat(&quot;\nDiagnostics for&quot;, model_name, &quot;model:\n&quot;)
    cat(&quot;-&quot; %*% (nchar(model_name) + 20), &quot;\n&quot;)
    
    # 1. Basic statistics
    s &lt;- summary(model)
    cat(&quot;R-squared:&quot;, round(s$r.squared, 4), &quot;\n&quot;)
    cat(&quot;Adj R-squared:&quot;, round(s$adj.r.squared, 4), &quot;\n&quot;)
    cat(&quot;Residual SE:&quot;, round(s$sigma, 4), &quot;\n&quot;)
    cat(&quot;F-statistic:&quot;, round(s$fstatistic[1], 2), &quot;\n&quot;)
    cat(&quot;F p-value:&quot;, format.pval(pf(s$fstatistic[1], 
                                    s$fstatistic[2], 
                                    s$fstatistic[3], 
                                    lower.tail = FALSE), digits = 3), &quot;\n&quot;)
    
    # 2. Normality test
    shapiro_test &lt;- shapiro.test(residuals(model))
    cat(&quot;Shapiro-Wilk normality test: W =&quot;, 
        round(shapiro_test$statistic, 4),
        &quot;, p =&quot;, format.pval(shapiro_test$p.value, digits = 3), &quot;\n&quot;)
    
    # 3. Heteroscedasticity tests
    if (requireNamespace(&quot;lmtest&quot;, quietly = TRUE)) {
      # Breusch-Pagan test
      bp_test &lt;- lmtest::bptest(model)
      cat(&quot;Breusch-Pagan test: BP =&quot;, round(bp_test$statistic, 3),
          &quot;, p =&quot;, format.pval(bp_test$p.value, digits = 3), &quot;\n&quot;)
      
      # White test
      white_test &lt;- lmtest::bptest(model, ~ fitted(model) + I(fitted(model)^2))
      cat(&quot;White test: W =&quot;, round(white_test$statistic, 3),
          &quot;, p =&quot;, format.pval(white_test$p.value, digits = 3), &quot;\n&quot;)
    }
    
    # 4. Autocorrelation test
    if (requireNamespace(&quot;lmtest&quot;, quietly = TRUE)) {
      dw_test &lt;- lmtest::dwtest(model)
      cat(&quot;Durbin-Watson test: DW =&quot;, round(dw_test$statistic, 3),
          &quot;, p =&quot;, format.pval(dw_test$p.value, digits = 3), &quot;\n&quot;)
    }
    
    # 5. Multicollinearity diagnostics
    if (length(coef(model)) &gt; 2) {  # More than just intercept
      vif_values &lt;- car::vif(model)
      cat(&quot;Variance Inflation Factors:\n&quot;)
      for (i in 1:length(vif_values)) {
        cat(&quot;  &quot;, names(vif_values)[i], &quot;:&quot;, round(vif_values[i], 2), &quot;\n&quot;)
      }
      cat(&quot;  Max VIF:&quot;, round(max(vif_values), 2), &quot;\n&quot;)
    }
    
    # 6. Outlier and influence diagnostics
    n &lt;- nobs(model)
    p &lt;- length(coef(model))
    
    # Standardized residuals &gt; 3
    std_res &lt;- rstandard(model)
    outliers &lt;- sum(abs(std_res) &gt; 3)
    cat(&quot;Outliers (|std residual| &gt; 3):&quot;, outliers, &quot;\n&quot;)
    
    # High leverage points
    leverage &lt;- hatvalues(model)
    high_leverage &lt;- sum(leverage &gt; 2 * p / n)
    cat(&quot;High leverage points:&quot;, high_leverage, &quot;\n&quot;)
    
    # Influential points (Cook&#x27;s D &gt; 4/n)
    cooks_d &lt;- cooks.distance(model)
    influential &lt;- sum(cooks_d &gt; 4 / n)
    cat(&quot;Influential points (Cook&#x27;s D &gt; 4/n):&quot;, influential, &quot;\n&quot;)
    
    cat(&quot;\n&quot;)
  }
  
  # Run diagnostics for selected models
  comprehensive_diagnostics(full_model, &quot;Full&quot;)
  comprehensive_diagnostics(stepwise_model, &quot;Stepwise Selected&quot;)
  
  # F. Visualization of Diagnostics
  par(mfrow = c(3, 3))
  
  # 1. Residuals vs Fitted
  plot(fitted(full_model), residuals(full_model),
       pch = 19, col = rgb(0, 0, 1, 0.5),
       main = &quot;Residuals vs Fitted&quot;,
       xlab = &quot;Fitted Values&quot;, ylab = &quot;Residuals&quot;)
  abline(h = 0, col = &quot;red&quot;, lwd = 2)
  lines(lowess(fitted(full_model), residuals(full_model)), 
        col = &quot;green&quot;, lwd = 2)
  
  # 2. Normal Q-Q Plot
  qqPlot(full_model, pch = 19, col = &quot;blue&quot;,
         main = &quot;Normal Q-Q Plot&quot;,
         ylab = &quot;Studentized Residuals&quot;)
  
  # 3. Scale-Location Plot
  plot(fitted(full_model), sqrt(abs(rstandard(full_model))),
       pch = 19, col = rgb(0.5, 0, 0.5, 0.5),
       main = &quot;Scale-Location Plot&quot;,
       xlab = &quot;Fitted Values&quot;, 
       ylab = expression(sqrt(&quot;|Standardized Residuals|&quot;)))
  lines(lowess(fitted(full_model), sqrt(abs(rstandard(full_model)))), 
        col = &quot;red&quot;, lwd = 2)
  
  # 4. Residuals vs Leverage
  plot(hatvalues(full_model), rstudent(full_model),
       pch = 19, col = rgb(1, 0.5, 0, 0.5),
       main = &quot;Residuals vs Leverage&quot;,
       xlab = &quot;Leverage&quot;, ylab = &quot;Studentized Residuals&quot;)
  abline(h = c(-2, 0, 2), col = c(&quot;red&quot;, &quot;black&quot;, &quot;red&quot;), lty = c(2, 1, 2))
  abline(v = 2 * p / n, col = &quot;blue&quot;, lty = 2)
  
  # Add Cook&#x27;s distance contours
  x_seq &lt;- seq(min(hatvalues(full_model)), max(hatvalues(full_model)), 
               length.out = 100)
  cook_levels &lt;- c(0.5, 1)
  for (level in cook_levels) {
    y_upper &lt;- sqrt(level * p * (1 - x_seq) / x_seq)
    y_lower &lt;- -y_upper
    lines(x_seq, y_upper, col = &quot;red&quot;, lty = 3)
    lines(x_seq, y_lower, col = &quot;red&quot;, lty = 3)
  }
  
  # 5. Cook&#x27;s Distance
  plot(cooks.distance(full_model), type = &quot;h&quot;,
       col = ifelse(cooks.distance(full_model) &gt; 4/n, &quot;red&quot;, &quot;blue&quot;),
       main = &quot;Cook&#x27;s Distance&quot;,
       xlab = &quot;Observation Index&quot;, ylab = &quot;Cook&#x27;s Distance&quot;)
  abline(h = 4/n, col = &quot;red&quot;, lty = 2, lwd = 2)
  text(n * 0.8, 4/n * 1.2, &quot;Threshold = 4/n&quot;, col = &quot;red&quot;)
  
  # 6. DFFITS
  dffits_values &lt;- dffits(full_model)
  plot(dffits_values, type = &quot;h&quot;,
       col = ifelse(abs(dffits_values) &gt; 2 * sqrt(p/n), &quot;red&quot;, &quot;blue&quot;),
       main = &quot;DFFITS&quot;,
       xlab = &quot;Observation Index&quot;, ylab = &quot;DFFITS&quot;)
  abline(h = c(-2 * sqrt(p/n), 2 * sqrt(p/n)), 
         col = &quot;red&quot;, lty = 2, lwd = 1)
  
  # 7. Added Variable Plots for key predictors
  avPlots(full_model, terms = ~ x1 + x2 + x3,
          main = &quot;Added Variable Plots&quot;,
          layout = c(3, 1))
  
  # 8. Component + Residual Plots
  crPlots(full_model, terms = ~ x1 + x2,
          main = &quot;Component + Residual Plots&quot;,
          layout = c(2, 1))
  
  # 9. Model Comparison: R-squared vs Complexity
  plot(ic_table$Predictors, ic_table$R2, type = &quot;b&quot;,
       pch = 19, col = &quot;blue&quot;, lwd = 2,
       main = &quot;Model Complexity vs R-squared&quot;,
       xlab = &quot;Number of Predictors&quot;, ylab = &quot;R-squared&quot;)
  points(ic_table$Predictors, ic_table$Adj_R2, type = &quot;b&quot;,
         pch = 17, col = &quot;red&quot;, lwd = 2)
  legend(&quot;bottomright&quot;, legend = c(&quot;R-squared&quot;, &quot;Adjusted R-squared&quot;),
         col = c(&quot;blue&quot;, &quot;red&quot;), pch = c(19, 17), lwd = 2)
  
  par(mfrow = c(1, 1))
  
  # G. Return comprehensive results
  return(list(
    data = data,
    models = models,
    ic_table = ic_table,
    cv_table = cv_table,
    regularization = if (exists(&quot;coef_comparison&quot;)) list(
      ridge_lambda = ridge_lambda,
      lasso_lambda = lasso_lambda,
      enet_lambda = enet_lambda,
      coef_comparison = coef_comparison
    ) else NULL,
    diagnostics = list(
      full_model = car::influencePlot(full_model),
      stepwise_model = car::influencePlot(stepwise_model)
    )
  ))
}

# Run model selection and diagnostics
model_selection_results &lt;- model_selection_diagnostics()</code></pre>
            </div>
            

            <div class="special-block reference">
                <div class="special-label">Reference: Davies (2016) Chapter 19; Pawgi (2022) Chapter 14</div>
                <div class="special-content"></div>
            </div>
            
<hr class="content-hr">
</section>

            <section class="content-section" id="4-advanced-graphics-plot-customization">
                <h2 class="section-heading"><strong>4. Advanced Graphics: Plot Customization</strong></h2>
            
</section>

            <section class="content-section" id="a-comprehensive-plot-customization-system">
                <h3 class="section-heading"><strong>A. Comprehensive Plot Customization System</strong></h3>
            

            <div class="code-block">
                <pre><code class="language-r"># Advanced Plot Customization Framework
advanced_graphics_framework &lt;- function() {
  
  # 1. Master Plot Customization Function
  create_custom_plot &lt;- function(data, plot_type = &quot;scatter&quot;, 
                                custom_params = list()) {
    # Default parameters
    defaults &lt;- list(
      main = &quot;Custom Plot&quot;,
      xlab = &quot;X-axis&quot;,
      ylab = &quot;Y-axis&quot;,
      col = &quot;blue&quot;,
      pch = 19,
      cex = 1.0,
      lwd = 1,
      lty = 1,
      xlim = NULL,
      ylim = NULL,
      bg = &quot;white&quot;,
      fg = &quot;black&quot;,
      family = &quot;sans&quot;,
      font = 1,
      las = 1,
      tck = 0.02,
      tcl = -0.5,
      mgp = c(3, 1, 0),
      mar = c(5, 4, 4, 2) + 0.1,
      oma = c(0, 0, 0, 0),
      xaxs = &quot;r&quot;,
      yaxs = &quot;r&quot;,
      xaxt = &quot;s&quot;,
      yaxt = &quot;s&quot;,
      bty = &quot;o&quot;,
      cex.axis = 1,
      cex.lab = 1,
      cex.main = 1.2,
      cex.sub = 0.8,
      col.axis = &quot;black&quot;,
      col.lab = &quot;black&quot;,
      col.main = &quot;black&quot;,
      col.sub = &quot;gray&quot;,
      font.axis = 1,
      font.lab = 1,
      font.main = 2,
      font.sub = 3
    )
    
    # Merge with custom parameters
    params &lt;- modifyList(defaults, custom_params)
    
    # Set graphical parameters
    old_par &lt;- par(no.readonly = TRUE)
    
    par(
      family = params$family,
      bg = params$bg,
      fg = params$fg,
      mar = params$mar,
      oma = params$oma,
      mgp = params$mgp,
      tck = params$tck,
      tcl = params$tcl,
      las = params$las
    )
    
    # Create plot based on type
    if (plot_type == &quot;scatter&quot;) {
      if (is.null(params$xlim)) params$xlim &lt;- range(data$x, na.rm = TRUE)
      if (is.null(params$ylim)) params$ylim &lt;- range(data$y, na.rm = TRUE)
      
      plot(data$x, data$y,
           type = &quot;p&quot;,
           main = params$main,
           xlab = params$xlab,
           ylab = params$ylab,
           col = params$col,
           pch = params$pch,
           cex = params$cex,
           xlim = params$xlim,
           ylim = params$ylim,
           xaxs = params$xaxs,
           yaxs = params$yaxs,
           xaxt = params$xaxt,
           yaxt = params$yaxt,
           bty = params$bty,
           cex.axis = params$cex.axis,
           cex.lab = params$cex.lab,
           cex.main = params$cex.main,
           cex.sub = params$cex.sub,
           col.axis = params$col.axis,
           col.lab = params$col.lab,
           col.main = params$col.main,
           col.sub = params$col.sub,
           font.axis = params$font.axis,
           font.lab = params$font.lab,
           font.main = params$font.main,
           font.sub = params$font.sub)
    } else if (plot_type == &quot;line&quot;) {
      plot(data$x, data$y, type = &quot;l&quot;,
           main = params$main,
           xlab = params$xlab,
           ylab = params$ylab,
           col = params$col,
           lwd = params$lwd,
           lty = params$lty,
           xlim = params$xlim,
           ylim = params$ylim)
    } else if (plot_type == &quot;histogram&quot;) {
      hist(data$x,
           main = params$main,
           xlab = params$xlab,
           ylab = params$ylab,
           col = params$col,
           border = params$fg,
           freq = FALSE)
    }
    
    # Reset parameters
    par(old_par)
  }
  
  # 2. Color System with Multiple Palettes
  color_system &lt;- function() {
    palettes &lt;- list(
      # Basic palettes
      basic = c(&quot;black&quot;, &quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;cyan&quot;, &quot;magenta&quot;, &quot;yellow&quot;, &quot;gray&quot;),
      
      # RColorBrewer palettes
      sequential = colorRampPalette(c(&quot;#FFF7FB&quot;, &quot;#74A9CF&quot;, &quot;#023858&quot;))(8),
      diverging = colorRampPalette(c(&quot;#D7191C&quot;, &quot;#FDAE61&quot;, &quot;#FFFFBF&quot;, &quot;#ABD9E9&quot;, &quot;#2C7BB6&quot;))(9),
      qualitative = c(&quot;#E41A1C&quot;, &quot;#377EB8&quot;, &quot;#4DAF4A&quot;, &quot;#984EA3&quot;, 
                     &quot;#FF7F00&quot;, &quot;#FFFF33&quot;, &quot;#A65628&quot;, &quot;#F781BF&quot;),
      
      # Viridis palettes
      viridis = viridis::viridis(8),
      plasma = viridis::plasma(8),
      inferno = viridis::inferno(8),
      magma = viridis::magma(8),
      
      # Custom gradients
      heat = heat.colors(8),
      terrain = terrain.colors(8),
      topo = topo.colors(8),
      cm = cm.colors(8),
      
      # Gray scale
      gray = gray.colors(8, start = 0.1, end = 0.9),
      
      # Rainbow (use with caution)
      rainbow = rainbow(8)
    )
    
    # Color conversion functions
    color_functions &lt;- list(
      rgb_to_hex = function(r, g, b) {
        rgb(r, g, b, maxColorValue = 255)
      },
      hex_to_rgb = function(hex) {
        col2rgb(hex)
      },
      adjust_brightness = function(col, factor) {
        rgb_mat &lt;- col2rgb(col) / 255
        rgb_mat &lt;- pmin(pmax(rgb_mat * factor, 0), 1)
        rgb(rgb_mat[1, ], rgb_mat[2, ], rgb_mat[3, ])
      },
      create_gradient = function(col1, col2, n = 100) {
        colorRampPalette(c(col1, col2))(n)
      },
      blend_colors = function(col1, col2, alpha = 0.5) {
        rgb1 &lt;- col2rgb(col1) / 255
        rgb2 &lt;- col2rgb(col2) / 255
        blended &lt;- alpha * rgb1 + (1 - alpha) * rgb2
        rgb(blended[1, ], blended[2, ], blended[3, ])
      }
    )
    
    # Color blindness simulation
    if (requireNamespace(&quot;dichromat&quot;, quietly = TRUE)) {
      color_functions$simulate_colorblind &lt;- function(col, type = &quot;deutan&quot;) {
        dichromat::dichromat(col, type)
      }
    }
    
    return(list(palettes = palettes, functions = color_functions))
  }
  
  # 3. Text and Label Customization
  text_customization &lt;- function() {
    text_functions &lt;- list(
      # Mathematical annotation
      math_expression = function() {
        expressions &lt;- list(
          beta = expression(beta),
          alpha = expression(alpha),
          sigma = expression(sigma),
          mu = expression(mu),
          integral = expression(integral(f(x) * dx, a, b)),
          sum = expression(sum(x[i], i==1, n)),
          fraction = expression(frac(a, b)),
          sqrt = expression(sqrt(x)),
          power = expression(x^{2}),
          subscript = expression(x[1])
        )
        return(expressions)
      },
      
      # Unicode and special characters
      special_characters = function() {
        chars &lt;- list(
          degree = &quot;°&quot;,
          plus_minus = &quot;±&quot;,
          micro = &quot;µ&quot;,
          alpha = &quot;α&quot;,
          beta = &quot;β&quot;,
          gamma = &quot;γ&quot;,
          delta = &quot;δ&quot;,
          infinity = &quot;∞&quot;,
          not_equal = &quot;≠&quot;,
          approximately = &quot;≈&quot;,
          less_equal = &quot;≤&quot;,
          greater_equal = &quot;≥&quot;
        )
        return(chars)
      },
      
      # Text formatting functions
      format_text = function(text, type = &quot;bold&quot;) {
        switch(type,
               bold = bquote(bold(.(text))),
               italic = bquote(italic(.(text))),
               bold_italic = bquote(bolditalic(.(text))),
               underline = paste0(&quot;\\underline{&quot;, text, &quot;}&quot;),
               text)
      },
      
      # Annotation with arrows
      annotate_with_arrow = function(x, y, label, 
                                    arrow_length = 0.1,
                                    arrow_angle = 30,
                                    arrow_code = 2) {
        text(x, y, label, pos = 3)
        arrows(x, y - strheight(label) * 0.5, 
               x, y - strheight(label) * 0.5 - arrow_length,
               length = arrow_length, angle = arrow_angle, code = arrow_code)
      }
    )
    
    return(text_functions)
  }
  
  # 4. Layout and Margin Management
  layout_system &lt;- function() {
    layout_functions &lt;- list(
      # Create complex layouts
      create_layout = function(rows, cols, widths = NULL, heights = NULL) {
        if (is.null(widths)) widths &lt;- rep(1, cols)
        if (is.null(heights)) heights &lt;- rep(1, rows)
        layout(matrix(1:(rows * cols), nrow = rows, byrow = TRUE),
               widths = widths, heights = heights)
      },
      
      # Nested layouts
      nested_layout = function(outer, inner) {
        old_par &lt;- par(no.readonly = TRUE)
        
        # Outer layout
        layout(outer$matrix, widths = outer$widths, heights = outer$heights)
        
        # Inner layouts
        for (i in 1:length(inner)) {
          if (!is.null(inner[[i]])) {
            par(fig = inner[[i]]$fig, new = TRUE)
            layout(inner[[i]]$matrix, 
                   widths = inner[[i]]$widths, 
                   heights = inner[[i]]$heights)
          }
        }
        
        par(old_par)
      },
      
      # Margin calculator
      calculate_margins = function(text_sizes = c(1, 1, 1, 1)) {
        # text_sizes: c(bottom, left, top, right) multiplier
        base_margins &lt;- c(5, 4, 4, 2) + 0.1
        adjusted_margins &lt;- base_margins * text_sizes
        return(adjusted_margins)
      },
      
      # Save and restore layout state
      save_layout_state = function() {
        list(
          layout = layout.state(),
          par = par(no.readonly = TRUE),
          mfrow = par(&quot;mfrow&quot;),
          mfcol = par(&quot;mfcol&quot;),
          fig = par(&quot;fig&quot;),
          plt = par(&quot;plt&quot;)
        )
      },
      
      restore_layout_state = function(state) {
        if (!is.null(state$layout)) layout(state$layout$mat, 
                                          state$layout$widths, 
                                          state$layout$heights)
        par(state$par)
        if (!is.null(state$mfrow)) par(mfrow = state$mfrow)
        if (!is.null(state$mfcol)) par(mfcol = state$mfcol)
        if (!is.null(state$fig)) par(fig = state$fig)
        if (!is.null(state$plt)) par(plt = state$plt)
      }
    )
    
    return(layout_functions)
  }
  
  # 5. Interactive Plot Elements
  interactive_elements &lt;- function() {
    interactive_functions &lt;- list(
      # Identify points
      identify_points = function(x, y, labels = NULL, n = length(x)) {
        if (is.null(labels)) labels &lt;- 1:length(x)
        identify(x, y, labels = labels, n = n)
      },
      
      # Get coordinates
      get_coordinates = function(n = 1, type = &quot;p&quot;) {
        locator(n = n, type = type)
      },
      
      # Interactive line drawing
      draw_interactive_line = function(col = &quot;red&quot;, lwd = 2, lty = 1) {
        coords &lt;- locator(2)
        if (length(coords$x) == 2) {
          lines(coords$x, coords$y, col = col, lwd = lwd, lty = lty)
          return(coords)
        }
        return(NULL)
      },
      
      # Interactive polygon
      draw_interactive_polygon = function(col = rgb(0, 0, 1, 0.3), 
                                         border = &quot;blue&quot;) {
        coords &lt;- locator()
        if (length(coords$x) &gt; 2) {
          polygon(coords$x, coords$y, col = col, border = border)
          return(coords)
        }
        return(NULL)
      },
      
      # Interactive text placement
      place_interactive_text = function(text = &quot;Label&quot;, 
                                       col = &quot;black&quot;,
                                       cex = 1,
                                       font = 1) {
        coords &lt;- locator(1)
        if (!is.null(coords)) {
          text(coords$x, coords$y, text, col = col, cex = cex, font = font)
          return(coords)
        }
        return(NULL)
      }
    )
    
    return(interactive_functions)
  }
  
  # 6. Demonstration: Complete Custom Plot
  demonstrate_custom_plot &lt;- function() {
    # Create sample data
    set.seed(123)
    n &lt;- 100
    x &lt;- seq(0, 10, length.out = n)
    y1 &lt;- sin(x) + rnorm(n, sd = 0.2)
    y2 &lt;- cos(x) + rnorm(n, sd = 0.2)
    groups &lt;- sample(1:4, n, replace = TRUE)
    
    data1 &lt;- data.frame(x = x, y = y1)
    data2 &lt;- data.frame(x = x, y = y2)
    
    # Get color system
    colors &lt;- color_system()
    
    # Create a complex custom plot
    old_par &lt;- par(no.readonly = TRUE)
    
    # Setup layout: 2 rows, 2 columns with different widths/heights
    layout_matrix &lt;- matrix(c(1, 2, 3, 4), nrow = 2, byrow = TRUE)
    layout(layout_matrix, widths = c(2, 1), heights = c(1, 2))
    
    # Plot 1: Scatter plot with custom styling
    par(mar = c(5, 5, 4, 2) + 0.1)
    create_custom_plot(data1, &quot;scatter&quot;,
                      custom_params = list(
                        main = expression(bold(&quot;Sine Function with Noise&quot;)),
                        xlab = expression(italic(&quot;Time (t)&quot;)),
                        ylab = expression(&quot;Amplitude &quot; * sin(omega * t)),
                        col = colors$palettes$viridis[cut(groups, 4)],
                        pch = 19,
                        cex = 1.2,
                        cex.main = 1.5,
                        cex.lab = 1.2,
                        col.main = &quot;darkblue&quot;,
                        font.main = 4,
                        bg = &quot;gray95&quot;,
                        fg = &quot;gray30&quot;
                      ))
    
    # Add a smooth line
    lines(lowess(data1$x, data1$y), col = &quot;red&quot;, lwd = 3, lty = 2)
    
    # Add mathematical annotation
    text(2, 1.5, expression(f(x) == sin(x) + epsilon), 
         cex = 1.2, col = &quot;darkred&quot;)
    
    # Add legend with custom colors
    legend(&quot;topright&quot;, 
           legend = paste(&quot;Group&quot;, 1:4),
           pch = 19, 
           col = colors$palettes$viridis[1:4],
           pt.cex = 1.5,
           bg = &quot;white&quot;,
           box.col = &quot;gray50&quot;,
           title = expression(bold(&quot;Categories&quot;)))
    
    # Plot 2: Line plot in second panel
    par(mar = c(5, 4, 4, 2) + 0.1)
    create_custom_plot(data2, &quot;line&quot;,
                      custom_params = list(
                        main = &quot;Cosine Function&quot;,
                        xlab = &quot;X&quot;,
                        ylab = &quot;Y&quot;,
                        col = colors$palettes$plasma[4],
                        lwd = 3,
                        lty = 1,
                        bg = &quot;gray98&quot;
                      ))
    
    # Add grid
    grid(col = &quot;gray80&quot;, lty = 3)
    
    # Add shaded confidence band
    polygon(c(x, rev(x)), 
            c(y2 - 0.3, rev(y2 + 0.3)),
            col = colors$functions$blend_colors(&quot;blue&quot;, &quot;white&quot;, 0.3),
            border = NA)
    
    # Plot 3: Histogram in third panel
    par(mar = c(5, 4, 4, 2) + 0.1)
    hist_data &lt;- data.frame(x = rnorm(1000))
    create_custom_plot(hist_data, &quot;histogram&quot;,
                      custom_params = list(
                        main = &quot;Normal Distribution&quot;,
                        xlab = &quot;Value&quot;,
                        ylab = &quot;Density&quot;,
                        col = colors$palettes$sequential
                      ))
    
    # Add density curve
    curve(dnorm(x), add = TRUE, col = &quot;red&quot;, lwd = 3)
    
    # Add statistical annotation
    text(0, 0.3, expression(paste(mu, &quot; = 0, &quot;, sigma, &quot; = 1&quot;)),
         cex = 1.2, col = &quot;darkgreen&quot;)
    
    # Add box with summary stats
    box_stats &lt;- boxplot(hist_data$x, plot = FALSE)$stats
    rect(2, 0.2, 3.5, 0.4, col = &quot;white&quot;, border = &quot;black&quot;)
    text(2.75, 0.35, &quot;Summary:&quot;, font = 2, cex = 0.8)
    text(2.75, 0.3, paste(&quot;Mean =&quot;, round(mean(hist_data$x), 3)), 
         cex = 0.8, pos = 4)
    text(2.75, 0.25, paste(&quot;SD =&quot;, round(sd(hist_data$x), 3)), 
         cex = 0.8, pos = 4)
    
    # Plot 4: Empty plot for custom drawing
    par(mar = c(5, 4, 4, 2) + 0.1)
    plot(0, 0, type = &quot;n&quot;, 
         xlim = c(-1, 1), ylim = c(-1, 1),
         main = &quot;Interactive Elements Demo&quot;,
         xlab = &quot;&quot;, ylab = &quot;&quot;, axes = FALSE)
    box()
    
    # Draw some shapes
    symbols(0, 0, circles = 0.8, inches = FALSE, add = TRUE,
            bg = colors$functions$adjust_brightness(&quot;blue&quot;, 0.7),
            fg = &quot;darkblue&quot;, lwd = 2)
    
    # Add text at various angles
    angles &lt;- seq(0, 2*pi, length.out = 8)
    for (i in 1:8) {
      x_text &lt;- 0.6 * cos(angles[i])
      y_text &lt;- 0.6 * sin(angles[i])
      text(x_text, y_text, paste(&quot;Point&quot;, i), 
           srt = angles[i] * 180/pi,
           col = colors$palettes$qualitative[i],
           font = 2)
    }
    
    # Add a color wheel
    n_colors &lt;- 36
    color_wheel &lt;- rainbow(n_colors)
    for (i in 1:n_colors) {
      theta &lt;- (i-1) * 2 * pi / n_colors
      x1 &lt;- 0.3 * cos(theta)
      y1 &lt;- 0.3 * sin(theta)
      x2 &lt;- 0.4 * cos(theta)
      y2 &lt;- 0.4 * sin(theta)
      segments(x1, y1, x2, y2, 
               col = color_wheel[i], 
               lwd = 3)
    }
    
    # Reset parameters
    par(old_par)
    
    # Return the color system for further use
    return(colors)
  }
  
  # 7. Return the complete framework
  return(list(
    create_custom_plot = create_custom_plot,
    color_system = color_system(),
    text_customization = text_customization(),
    layout_system = layout_system(),
    interactive_elements = interactive_elements(),
    demonstration = demonstrate_custom_plot()
  ))
}

# Create and demonstrate the advanced graphics framework
graphics_framework &lt;- advanced_graphics_framework()</code></pre>
            </div>
            
</section>

            <section class="content-section" id="b-plotting-regions-and-margins">
                <h3 class="section-heading"><strong>B. Plotting Regions and Margins</strong></h3>
            

            <div class="code-block">
                <pre><code class="language-r"># Detailed margin and region management
margin_region_management &lt;- function() {
  
  # 1. Understanding Plot Regions
  explain_plot_regions &lt;- function() {
    cat(&quot;PLOT REGIONS IN R\n&quot;)
    cat(&quot;================\n\n&quot;)
    
    cat(&quot;1. FIGURE REGION: Entire graphics device\n&quot;)
    cat(&quot;   - Controlled by &#x27;fig&#x27; parameter\n&quot;)
    cat(&quot;   - Coordinates: [0,1] x [0,1]\n&quot;)
    cat(&quot;   - Bottom-left: (0,0), Top-right: (1,1)\n\n&quot;)
    
    cat(&quot;2. PLOT REGION: Where data is plotted\n&quot;)
    cat(&quot;   - Controlled by &#x27;plt&#x27; parameter\n&quot;)
    cat(&quot;   - Subset of figure region\n&quot;)
    cat(&quot;   - Contains axes, titles, data points\n\n&quot;)
    
    cat(&quot;3. MARGIN REGION: Outside plot region\n&quot;)
    cat(&quot;   - Controlled by &#x27;mar&#x27; parameter\n&quot;)
    cat(&quot;   - Contains axis labels, main title\n&quot;)
    cat(&quot;   - Four components: bottom, left, top, right\n\n&quot;)
    
    cat(&quot;4. OUTER MARGIN: Outside figure region\n&quot;)
    cat(&quot;   - Controlled by &#x27;oma&#x27; parameter\n&quot;)
    cat(&quot;   - For multiple plot arrangements\n\n&quot;)
  }
  
  # 2. Visual Demonstration of Regions
  visualize_regions &lt;- function() {
    old_par &lt;- par(no.readonly = TRUE)
    
    # Setup 2x2 layout
    layout(matrix(1:4, nrow = 2))
    
    # Plot 1: Default margins
    par(mar = c(5, 4, 4, 2) + 0.1)
    plot(1:10, 1:10, type = &quot;n&quot;, 
         main = &quot;Default Margins\nmar = c(5,4,4,2)+0.1&quot;,
         xlab = &quot;X-axis&quot;, ylab = &quot;Y-axis&quot;)
    grid()
    box(&quot;plot&quot;, col = &quot;blue&quot;, lwd = 2)
    box(&quot;figure&quot;, col = &quot;red&quot;, lwd = 2)
    mtext(&quot;Figure Region&quot;, side = 3, line = -1, col = &quot;red&quot;)
    mtext(&quot;Plot Region&quot;, side = 3, line = -2, col = &quot;blue&quot;)
    
    # Plot 2: Small margins
    par(mar = c(2, 2, 1, 1))
    plot(1:10, 1:10, type = &quot;n&quot;,
         main = &quot;Small Margins\nmar = c(2,2,1,1)&quot;,
         xlab = &quot;&quot;, ylab = &quot;&quot;)
    grid()
    box(&quot;plot&quot;, col = &quot;blue&quot;, lwd = 2)
    box(&quot;figure&quot;, col = &quot;red&quot;, lwd = 2)
    
    # Plot 3: Large margins
    par(mar = c(7, 6, 5, 4))
    plot(1:10, 1:10, type = &quot;n&quot;,
         main = &quot;Large Margins\nmar = c(7,6,5,4)&quot;,
         xlab = &quot;Long X-axis Label&quot;, 
         ylab = &quot;Long Y-axis Label&quot;)
    grid()
    box(&quot;plot&quot;, col = &quot;blue&quot;, lwd = 2)
    box(&quot;figure&quot;, col = &quot;red&quot;, lwd = 2)
    
    # Plot 4: Asymmetric margins
    par(mar = c(8, 3, 3, 8))
    plot(1:10, 1:10, type = &quot;n&quot;,
         main = &quot;Asymmetric Margins\nmar = c(8,3,3,8)&quot;,
         xlab = &quot;&quot;, ylab = &quot;&quot;)
    grid()
    box(&quot;plot&quot;, col = &quot;blue&quot;, lwd = 2)
    box(&quot;figure&quot;, col = &quot;red&quot;, lwd = 2)
    mtext(&quot;Bottom Margin = 8&quot;, side = 1, line = 6, col = &quot;darkgreen&quot;)
    mtext(&quot;Right Margin = 8&quot;, side = 4, line = 6, col = &quot;darkgreen&quot;)
    
    par(old_par)
  }
  
  # 3. Margin Calculator Tool
  margin_calculator &lt;- function(plot_type = &quot;default&quot;, 
                               text_size = 1,
                               has_legend = FALSE,
                               has_title = TRUE,
                               has_labels = TRUE) {
    
    base_margins &lt;- list(
      default = c(bottom = 5.1, left = 4.1, top = 4.1, right = 2.1),
      minimal = c(1, 1, 1, 1),
      publication = c(5, 6, 4, 2),
      presentation = c(4, 4, 3, 2),
      poster = c(6, 6, 5, 4)
    )
    
    # Get base margins
    margins &lt;- base_margins[[plot_type]]
    if (is.null(margins)) margins &lt;- base_margins$default
    
    # Adjust for text size
    margins &lt;- margins * text_size
    
    # Additional adjustments
    if (has_legend) margins[4] &lt;- margins[4] + 2  # Add space for legend
    if (!has_title) margins[3] &lt;- margins[3] - 1
    if (!has_labels) {
      margins[1] &lt;- margins[1] - 2  # Bottom
      margins[2] &lt;- margins[2] - 2  # Left
    }
    
    # Round to nearest 0.1
    margins &lt;- round(margins, 1)
    
    return(as.numeric(margins))
  }
  
  # 4. Dynamic Margin Adjustment
  dynamic_margin_adjustment &lt;- function() {
    cat(&quot;DYNAMIC MARGIN ADJUSTMENT\n&quot;)
    cat(&quot;=========================\n\n&quot;)
    
    # Example: Adjust margins based on text length
    adjust_for_long_labels &lt;- function(x_label, y_label, title) {
      # Calculate required space based on text length
      x_len &lt;- nchar(x_label)
      y_len &lt;- nchar(y_label)
      title_len &lt;- nchar(title)
      
      # Base margins
      margins &lt;- c(5, 4, 4, 2) + 0.1
      
      # Adjust based on text length
      margins[1] &lt;- margins[1] + x_len * 0.1  # Bottom
      margins[2] &lt;- margins[2] + y_len * 0.15  # Left
      margins[3] &lt;- margins[3] + title_len * 0.05  # Top
      
      return(round(margins, 1))
    }
    
    # Test cases
    test_cases &lt;- list(
      short = list(x = &quot;X&quot;, y = &quot;Y&quot;, title = &quot;Plot&quot;),
      medium = list(x = &quot;Time (seconds)&quot;, y = &quot;Distance (meters)&quot;, 
                   title = &quot;Distance vs Time&quot;),
      long = list(x = &quot;Highly descriptive X-axis label with units&quot;, 
                 y = &quot;Equally descriptive Y-axis label with proper units&quot;,
                 title = &quot;Very Long and Descriptive Plot Title That Explains Everything&quot;)
    )
    
    for (name in names(test_cases)) {
      tc &lt;- test_cases[[name]]
      margins &lt;- adjust_for_long_labels(tc$x, tc$y, tc$title)
      cat(name, &quot;labels:\n&quot;)
      cat(&quot;  X-label:&quot;, tc$x, &quot;\n&quot;)
      cat(&quot;  Y-label:&quot;, tc$y, &quot;\n&quot;)
      cat(&quot;  Title:&quot;, tc$title, &quot;\n&quot;)
      cat(&quot;  Recommended margins:&quot;, paste(margins, collapse = &quot;, &quot;), &quot;\n\n&quot;)
    }
  }
  
  # 5. Multiple Plot Arrangements with Custom Margins
  multiple_plot_arrangements &lt;- function() {
    old_par &lt;- par(no.readonly = TRUE)
    
    # Create sample data
    set.seed(123)
    data_sets &lt;- list(
      linear = data.frame(x = 1:100, y = 1:100 + rnorm(100, sd = 10)),
      quadratic = data.frame(x = 1:100, y = (1:100)^2 / 100 + rnorm(100, sd = 20)),
      exponential = data.frame(x = 1:100, y = exp((1:100)/30) + rnorm(100, sd = 5)),
      sinusoidal = data.frame(x = 1:100, y = 50 * sin((1:100)/10) + rnorm(100, sd = 8))
    )
    
    # Method 1: Using par(mfrow) with individual margins
    cat(&quot;METHOD 1: Using par(mfrow)\n&quot;)
    par(mfrow = c(2, 2))
    
    for (i in 1:4) {
      data_name &lt;- names(data_sets)[i]
      data &lt;- data_sets[[i]]
      
      # Set margins for this specific plot
      if (i %% 2 == 1) {
        # Left column: larger left margin for y-label
        par(mar = c(4, 5, 3, 2))
      } else {
        # Right column: smaller left margin
        par(mar = c(4, 3, 3, 2))
      }
      
      plot(data$x, data$y, type = &quot;l&quot;, lwd = 2,
           main = paste(&quot;Data:&quot;, data_name),
           xlab = &quot;Index&quot;,
           ylab = if (i %% 2 == 1) &quot;Value&quot; else &quot;&quot;,
           col = i + 1)
      
      # Add grid
      grid(col = &quot;gray80&quot;)
    }
    
    # Method 2: Using layout() with custom widths/heights
    cat(&quot;\nMETHOD 2: Using layout()\n&quot;)
    
    # Reset plot
    par(old_par)
    
    # Define layout with different panel sizes
    layout_matrix &lt;- matrix(c(1, 1, 2, 3, 4, 4), nrow = 3, byrow = TRUE)
    layout(layout_matrix, 
           widths = c(1, 1), 
           heights = c(1, 1, 0.5))
    
    # Plot 1: Large top plot
    par(mar = c(0, 5, 4, 2))
    plot(data_sets$linear$x, data_sets$linear$y, type = &quot;l&quot;,
         main = &quot;Large Plot: Linear Data&quot;,
         xlab = &quot;&quot;, xaxt = &quot;n&quot;,
         ylab = &quot;Value&quot;, col = &quot;blue&quot;, lwd = 2)
    grid()
    
    # Plot 2: Middle left
    par(mar = c(4, 5, 0, 1))
    plot(data_sets$quadratic$x, data_sets$quadratic$y, type = &quot;l&quot;,
         xlab = &quot;Index&quot;, ylab = &quot;Value&quot;,
         col = &quot;red&quot;, lwd = 2)
    grid()
    
    # Plot 3: Middle right
    par(mar = c(4, 3, 0, 3))
    plot(data_sets$exponential$x, data_sets$exponential$y, type = &quot;l&quot;,
         xlab = &quot;Index&quot;, ylab = &quot;&quot;,
         col = &quot;green&quot;, lwd = 2)
    grid()
    
    # Plot 4: Bottom plot (wide)
    par(mar = c(4, 5, 0, 2))
    plot(data_sets$sinusoidal$x, data_sets$sinusoidal$y, type = &quot;l&quot;,
         xlab = &quot;Index&quot;, ylab = &quot;Value&quot;,
         col = &quot;purple&quot;, lwd = 2)
    grid()
    
    # Method 3: Using par(fig) for precise positioning
    cat(&quot;\nMETHOD 3: Using par(fig) for precise control\n&quot;)
    
    # Reset plot
    par(old_par)
    
    # Create a complex arrangement
    # Main plot (75% of width, 70% of height)
    par(fig = c(0, 0.75, 0.3, 1))
    par(mar = c(0, 5, 4, 2))
    plot(data_sets$linear$x, data_sets$linear$y, type = &quot;l&quot;,
         main = &quot;Main Plot with Side Panels&quot;,
         xlab = &quot;&quot;, xaxt = &quot;n&quot;,
         ylab = &quot;Main Y-axis&quot;, col = &quot;blue&quot;, lwd = 2)
    grid()
    
    # Right panel (25% of width, 70% of height)
    par(fig = c(0.75, 1, 0.3, 1), new = TRUE)
    par(mar = c(0, 3, 4, 2))
    boxplot(data_sets$linear$y,
            main = &quot;Distribution&quot;,
            ylab = &quot;&quot;, horizontal = TRUE,
            col = &quot;lightblue&quot;)
    
    # Bottom panel (75% of width, 30% of height)
    par(fig = c(0, 0.75, 0, 0.3), new = TRUE)
    par(mar = c(5, 5, 0, 2))
    hist(data_sets$linear$y, breaks = 20,
         main = &quot;&quot;, xlab = &quot;Value&quot;, ylab = &quot;Frequency&quot;,
         col = &quot;lightgreen&quot;, border = &quot;darkgreen&quot;)
    
    # Reset parameters
    par(old_par)
  }
  
  # 6. Interactive Margin Explorer
  interactive_margin_explorer &lt;- function() {
    cat(&quot;INTERACTIVE MARGIN EXPLORER\n&quot;)
    cat(&quot;===========================\n&quot;)
    cat(&quot;Click on the plot to see margin coordinates\n&quot;)
    cat(&quot;Press ESC to exit\n\n&quot;)
    
    # Create a test plot
    plot(1:10, 1:10, type = &quot;n&quot;,
         main = &quot;Interactive Margin Explorer\nClick anywhere on the plot&quot;,
         xlab = &quot;X-axis&quot;, ylab = &quot;Y-axis&quot;)
    grid()
    
    # Draw region boundaries
    box(&quot;plot&quot;, col = &quot;blue&quot;, lwd = 2)
    box(&quot;figure&quot;, col = &quot;red&quot;, lwd = 2)
    box(&quot;inner&quot;, col = &quot;green&quot;, lwd = 2, lty = 2)
    box(&quot;outer&quot;, col = &quot;purple&quot;, lwd = 2, lty = 2)
    
    legend(&quot;bottomright&quot;,
           legend = c(&quot;Plot Region&quot;, &quot;Figure Region&quot;, &quot;Inner Margin&quot;, &quot;Outer Margin&quot;),
           col = c(&quot;blue&quot;, &quot;red&quot;, &quot;green&quot;, &quot;purple&quot;),
           lty = c(1, 1, 2, 2),
           lwd = 2,
           bg = &quot;white&quot;)
    
    # Interactive exploration
    cat(&quot;Current graphical parameters:\n&quot;)
    cat(&quot;mar:&quot;, par(&quot;mar&quot;), &quot;\n&quot;)
    cat(&quot;oma:&quot;, par(&quot;oma&quot;), &quot;\n&quot;)
    cat(&quot;fig:&quot;, par(&quot;fig&quot;), &quot;\n&quot;)
    cat(&quot;plt:&quot;, par(&quot;plt&quot;), &quot;\n\n&quot;)
    
    cat(&quot;Click on the plot window to see coordinates...\n&quot;)
    
    # Get user clicks
    points_clicked &lt;- 0
    while(points_clicked &lt; 5) {
      coords &lt;- locator(1)
      if (is.null(coords)) break
      
      points_clicked &lt;- points_clicked + 1
      
      # Plot the clicked point
      points(coords$x, coords$y, pch = 19, col = &quot;red&quot;, cex = 2)
      
      # Calculate relative positions
      x_plt &lt;- (coords$x - par(&quot;usr&quot;)[1]) / (par(&quot;usr&quot;)[2] - par(&quot;usr&quot;)[1])
      y_plt &lt;- (coords$y - par(&quot;usr&quot;)[3]) / (par(&quot;usr&quot;)[4] - par(&quot;usr&quot;)[3])
      
      cat(sprintf(&quot;Click %d:\n&quot;, points_clicked))
      cat(sprintf(&quot;  Data coordinates: (%.2f, %.2f)\n&quot;, coords$x, coords$y))
      cat(sprintf(&quot;  Plot coordinates: (%.3f, %.3f)\n&quot;, x_plt, y_plt))
      cat(sprintf(&quot;  Figure coordinates: (%.3f, %.3f)\n\n&quot;, 
                  grconvertX(coords$x, &quot;user&quot;, &quot;ndc&quot;),
                  grconvertY(coords$y, &quot;user&quot;, &quot;ndc&quot;)))
    }
    
    cat(&quot;Interactive exploration complete.\n&quot;)
  }
  
  # 7. Return all functions and demonstrations
  return(list(
    explain_regions = explain_plot_regions,
    visualize_regions = visualize_regions,
    margin_calculator = margin_calculator,
    dynamic_adjustment = dynamic_margin_adjustment,
    multiple_arrangements = multiple_plot_arrangements,
    interactive_explorer = interactive_margin_explorer
  ))
}

# Create margin management system
margin_system &lt;- margin_region_management()

# Run demonstrations
margin_system$explain_regions()
margin_system$visualize_regions()</code></pre>
            </div>
            
</section>

            <section class="content-section" id="c-point-and-click-coordinate-interaction">
                <h3 class="section-heading"><strong>C. Point and Click Coordinate Interaction</strong></h3>
            

            <div class="code-block">
                <pre><code class="language-r"># Interactive Coordinate System
interactive_coordinate_system &lt;- function() {
  
  # 1. Basic Interactive Functions
  basic_interactive_functions &lt;- function() {
    interactive_tools &lt;- list(
      
      # Identify points with labels
      identify_with_labels = function(x, y, labels = NULL, 
                                     n = length(x),
                                     tolerance = 0.5,
                                     plot = TRUE) {
        if (is.null(labels)) labels &lt;- 1:length(x)
        
        cat(&quot;Click near points to identify them.\n&quot;)
        cat(&quot;Press ESC or right-click to exit.\n\n&quot;)
        
        identified &lt;- identify(x, y, labels = labels, 
                              n = n, tolerance = tolerance,
                              plot = plot)
        
        if (length(identified) &gt; 0) {
          cat(&quot;Identified points:\n&quot;)
          for (i in identified) {
            cat(sprintf(&quot;  Point %d: (%g, %g) - Label: %s\n&quot;, 
                       i, x[i], y[i], labels[i]))
          }
        } else {
          cat(&quot;No points identified.\n&quot;)
        }
        
        return(identified)
      },
      
      # Get coordinates with transformation
      get_transformed_coordinates = function(n = 1, 
                                            type = &quot;p&quot;,
                                            transform = NULL) {
        coords &lt;- locator(n = n, type = type)
        
        if (!is.null(coords) &amp;&amp; !is.null(transform)) {
          if (is.function(transform)) {
            coords_transformed &lt;- transform(coords)
            return(list(original = coords, transformed = coords_transformed))
          }
        }
        
        return(coords)
      },
      
      # Draw and measure line
      draw_and_measure_line = function(col = &quot;red&quot;, 
                                      lwd = 2,
                                      show_stats = TRUE) {
        cat(&quot;Click two points to draw a line.\n&quot;)
        coords &lt;- locator(2)
        
        if (length(coords$x) == 2) {
          # Draw the line
          lines(coords$x, coords$y, col = col, lwd = lwd)
          
          # Calculate statistics
          dx &lt;- coords$x[2] - coords$x[1]
          dy &lt;- coords$y[2] - coords$y[1]
          length &lt;- sqrt(dx^2 + dy^2)
          slope &lt;- dy / dx
          angle &lt;- atan2(dy, dx) * 180 / pi
          
          if (show_stats) {
            cat(&quot;\nLine Statistics:\n&quot;)
            cat(sprintf(&quot;  Start: (%.3f, %.3f)\n&quot;, coords$x[1], coords$y[1]))
            cat(sprintf(&quot;  End: (%.3f, %.3f)\n&quot;, coords$x[2], coords$y[2]))
            cat(sprintf(&quot;  Length: %.3f\n&quot;, length))
            cat(sprintf(&quot;  Slope: %.3f\n&quot;, slope))
            cat(sprintf(&quot;  Angle: %.1f degrees\n&quot;, angle))
          }
          
          # Add midpoint and annotation
          mid_x &lt;- mean(coords$x)
          mid_y &lt;- mean(coords$y)
          points(mid_x, mid_y, pch = 19, col = &quot;blue&quot;, cex = 1.5)
          text(mid_x, mid_y, 
               sprintf(&quot;L=%.2f&quot;, length),
               pos = 3, col = &quot;darkblue&quot;, font = 2)
          
          return(list(coords = coords, 
                     stats = list(length = length, 
                                  slope = slope, 
                                  angle = angle)))
        }
        return(NULL)
      },
      
      # Create interactive polygon
      create_interactive_polygon = function(fill = TRUE,
                                           col = &quot;blue&quot;,
                                           border = &quot;darkblue&quot;,
                                           alpha = 0.3,
                                           calculate_area = TRUE) {
        cat(&quot;Click points to create polygon.\n&quot;)
        cat(&quot;Right-click or press ESC to finish.\n&quot;)
        
        coords &lt;- locator(type = &quot;p&quot;)
        
        if (length(coords$x) &gt; 2) {
          # Close the polygon
          coords$x &lt;- c(coords$x, coords$x[1])
          coords$y &lt;- c(coords$y, coords$y[1])
          
          # Draw polygon
          if (fill) {
            polygon(coords$x, coords$y, 
                    col = adjustcolor(col, alpha.f = alpha),
                    border = border, lwd = 2)
          } else {
            lines(coords$x, coords$y, col = border, lwd = 2)
          }
          
          # Mark vertices
          points(coords$x[-length(coords$x)], 
                 coords$y[-length(coords$y)], 
                 pch = 19, col = &quot;red&quot;, cex = 1.2)
          
          # Calculate area if requested
          if (calculate_area &amp;&amp; length(coords$x) &gt; 3) {
            area &lt;- polyarea(coords$x[-length(coords$x)], 
                            coords$y[-length(coords$y)])
            centroid_x &lt;- mean(coords$x[-length(coords$x)])
            centroid_y &lt;- mean(coords$y[-length(coords$y)])
            
            cat(&quot;\nPolygon Statistics:\n&quot;)
            cat(sprintf(&quot;  Vertices: %d\n&quot;, length(coords$x) - 1))
            cat(sprintf(&quot;  Area: %.3f\n&quot;, area))
            cat(sprintf(&quot;  Centroid: (%.3f, %.3f)\n&quot;, centroid_x, centroid_y))
            
            # Mark centroid
            points(centroid_x, centroid_y, pch = 17, col = &quot;green&quot;, cex = 2)
            text(centroid_x, centroid_y, &quot;Centroid&quot;, pos = 3, col = &quot;darkgreen&quot;)
            
            return(list(coords = coords,
                       stats = list(vertices = length(coords$x) - 1,
                                   area = area,
                                   centroid = c(centroid_x, centroid_y))))
          }
          
          return(coords)
        }
        return(NULL)
      },
      
      # Interactive text placement with formatting
      place_formatted_text = function(default_text = &quot;Label&quot;,
                                     col = &quot;black&quot;,
                                     cex = 1,
                                     font = 1,
                                     pos = NULL,
                                     show_box = FALSE) {
        cat(&quot;Click where you want to place text.\n&quot;)
        coords &lt;- locator(1)
        
        if (!is.null(coords)) {
          # Get text from user
          text_input &lt;- readline(paste(&quot;Enter text [&quot;, default_text, &quot;]: &quot;))
          if (text_input == &quot;&quot;) text_input &lt;- default_text
          
          # Place text
          text(coords$x, coords$y, text_input,
               col = col, cex = cex, font = font, pos = pos)
          
          # Optional box
          if (show_box) {
            text_width &lt;- strwidth(text_input, cex = cex)
            text_height &lt;- strheight(text_input, cex = cex)
            rect(coords$x - text_width/2, coords$y - text_height/2,
                 coords$x + text_width/2, coords$y + text_height/2,
                 border = col, lty = 2)
          }
          
          return(list(coords = coords, text = text_input))
        }
        return(NULL)
      }
    )
    
    return(interactive_tools)
  }
  
  # 2. Coordinate Transformation System
  coordinate_transformations &lt;- function() {
    transformations &lt;- list(
      
      # Linear transformations
      scale = function(x, y, scale_x = 1, scale_y = 1) {
        list(x = x * scale_x, y = y * scale_y)
      },
      
      translate = function(x, y, dx = 0, dy = 0) {
        list(x = x + dx, y = y + dy)
      },
      
      rotate = function(x, y, angle_degrees, center_x = 0, center_y = 0) {
        angle &lt;- angle_degrees * pi / 180
        x_centered &lt;- x - center_x
        y_centered &lt;- y - center_y
        
        x_rot &lt;- center_x + x_centered * cos(angle) - y_centered * sin(angle)
        y_rot &lt;- center_y + x_centered * sin(angle) + y_centered * cos(angle)
        
        list(x = x_rot, y = y_rot)
      },
      
      # Non-linear transformations
      log_transform = function(x, y, base = exp(1)) {
        list(x = ifelse(x &gt; 0, log(x, base), NA),
             y = ifelse(y &gt; 0, log(y, base), NA))
      },
      
      power_transform = function(x, y, power = 2) {
        list(x = x^power, y = y^power)
      },
      
      # Coordinate system conversions
      polar_to_cartesian = function(r, theta_degrees) {
        theta &lt;- theta_degrees * pi / 180
        list(x = r * cos(theta), y = r * sin(theta))
      },
      
      cartesian_to_polar = function(x, y) {
        r &lt;- sqrt(x^2 + y^2)
        theta &lt;- atan2(y, x) * 180 / pi
        list(r = r, theta = theta)
      },
      
      # Data to normalized device coordinates
      user_to_ndc = function(x, y) {
        list(x = grconvertX(x, &quot;user&quot;, &quot;ndc&quot;),
             y = grconvertY(y, &quot;user&quot;, &quot;ndc&quot;))
      },
      
      ndc_to_user = function(x_ndc, y_ndc) {
        list(x = grconvertX(x_ndc, &quot;ndc&quot;, &quot;user&quot;),
             y = grconvertY(y_ndc, &quot;ndc&quot;, &quot;user&quot;))
      }
    )
    
    return(transformations)
  }
  
  # 3. Interactive Selection and Measurement Tools
  selection_measurement_tools &lt;- function() {
    tools &lt;- list(
      
      # Select points within a rectangle
      select_rectangle = function() {
        cat(&quot;Click two points to define rectangle.\n&quot;)
        corners &lt;- locator(2)
        
        if (length(corners$x) == 2) {
          # Draw rectangle
          x_min &lt;- min(corners$x); x_max &lt;- max(corners$x)
          y_min &lt;- min(corners$y); y_max &lt;- max(corners$y)
          
          rect(x_min, y_min, x_max, y_max,
               border = &quot;red&quot;, lwd = 2, lty = 2,
               col = adjustcolor(&quot;red&quot;, alpha.f = 0.1))
          
          cat(sprintf(&quot;Rectangle: x=[%.3f, %.3f], y=[%.3f, %.3f]\n&quot;,
                     x_min, x_max, y_min, y_max))
          
          return(list(xlim = c(x_min, x_max), ylim = c(y_min, y_max)))
        }
        return(NULL)
      },
      
      # Select points within a circle
      select_circle = function() {
        cat(&quot;Click center, then edge to define circle.\n&quot;)
        center &lt;- locator(1)
        edge &lt;- locator(1)
        
        if (!is.null(center) &amp;&amp; !is.null(edge)) {
          radius &lt;- sqrt((edge$x - center$x)^2 + (edge$y - center$y)^2)
          
          # Draw circle
          symbols(center$x, center$y, circles = radius, inches = FALSE,
                  add = TRUE, fg = &quot;blue&quot;, lwd = 2, lty = 2,
                  bg = adjustcolor(&quot;blue&quot;, alpha.f = 0.1))
          
          cat(sprintf(&quot;Circle: Center (%.3f, %.3f), Radius = %.3f\n&quot;,
                     center$x, center$y, radius))
          
          return(list(center = center, radius = radius))
        }
        return(NULL)
      },
      
      # Measure distance between multiple points
      measure_path = function() {
        cat(&quot;Click points to measure path distance.\n&quot;)
        cat(&quot;Right-click or ESC to finish.\n&quot;)
        
        points &lt;- locator(type = &quot;p&quot;)
        
        if (length(points$x) &gt; 1) {
          # Draw path
          lines(points$x, points$y, col = &quot;green&quot;, lwd = 2, type = &quot;b&quot;, pch = 19)
          
          # Calculate distances
          n &lt;- length(points$x)
          segment_lengths &lt;- numeric(n - 1)
          cumulative_lengths &lt;- numeric(n)
          
          for (i in 1:(n - 1)) {
            dx &lt;- points$x[i + 1] - points$x[i]
            dy &lt;- points$y[i + 1] - points$y[i]
            segment_lengths[i] &lt;- sqrt(dx^2 + dy^2)
            cumulative_lengths[i + 1] &lt;- cumulative_lengths[i] + segment_lengths[i]
          }
          
          total_length &lt;- cumulative_lengths[n]
          
          # Display statistics
          cat(&quot;\nPath Statistics:\n&quot;)
          cat(sprintf(&quot;  Points: %d\n&quot;, n))
          cat(sprintf(&quot;  Segments: %d\n&quot;, n - 1))
          cat(sprintf(&quot;  Total length: %.3f\n&quot;, total_length))
          cat(&quot;  Segment lengths:&quot;, round(segment_lengths, 3), &quot;\n&quot;)
          
          # Label segments
          for (i in 1:(n - 1)) {
            mid_x &lt;- (points$x[i] + points$x[i + 1]) / 2
            mid_y &lt;- (points$y[i] + points$y[i + 1]) / 2
            text(mid_x, mid_y, 
                 sprintf(&quot;%.2f&quot;, segment_lengths[i]),
                 cex = 0.8, col = &quot;darkgreen&quot;, font = 2)
          }
          
          return(list(points = points,
                     segment_lengths = segment_lengths,
                     total_length = total_length,
                     cumulative_lengths = cumulative_lengths))
        }
        return(NULL)
      },
      
      # Area measurement using polygon
      measure_area = function() {
        cat(&quot;Click points to define area polygon.\n&quot;)
        cat(&quot;Right-click or ESC to finish.\n&quot;)
        
        polygon_coords &lt;- locator(type = &quot;p&quot;)
        
        if (length(polygon_coords$x) &gt; 2) {
          # Close polygon
          polygon_coords$x &lt;- c(polygon_coords$x, polygon_coords$x[1])
          polygon_coords$y &lt;- c(polygon_coords$y, polygon_coords$y[1])
          
          # Draw polygon
          polygon(polygon_coords$x, polygon_coords$y,
                  col = adjustcolor(&quot;orange&quot;, alpha.f = 0.3),
                  border = &quot;orange&quot;, lwd = 2)
          
          # Calculate area using shoelace formula
          x &lt;- polygon_coords$x
          y &lt;- polygon_coords$y
          n &lt;- length(x)
          
          area &lt;- 0
          for (i in 1:(n - 1)) {
            area &lt;- area + (x[i] * y[i + 1] - x[i + 1] * y[i])
          }
          area &lt;- abs(area) / 2
          
          # Calculate centroid
          centroid_x &lt;- 0
          centroid_y &lt;- 0
          for (i in 1:(n - 1)) {
            cross &lt;- x[i] * y[i + 1] - x[i + 1] * y[i]
            centroid_x &lt;- centroid_x + (x[i] + x[i + 1]) * cross
            centroid_y &lt;- centroid_y + (y[i] + y[i + 1]) * cross
          }
          centroid_x &lt;- centroid_x / (6 * area)
          centroid_y &lt;- centroid_y / (6 * area)
          
          cat(&quot;\nArea Measurement:\n&quot;)
          cat(sprintf(&quot;  Vertices: %d\n&quot;, n - 1))
          cat(sprintf(&quot;  Area: %.3f square units\n&quot;, area))
          cat(sprintf(&quot;  Centroid: (%.3f, %.3f)\n&quot;, centroid_x, centroid_y))
          
          # Mark centroid
          points(centroid_x, centroid_y, pch = 17, col = &quot;red&quot;, cex = 2)
          text(centroid_x, centroid_y, &quot;Centroid&quot;, pos = 3, col = &quot;red&quot;)
          
          return(list(coords = polygon_coords,
                     area = area,
                     centroid = c(centroid_x, centroid_y)))
        }
        return(NULL)
      }
    )
    
    return(tools)
  }
  
  # 4. Interactive Plot Customization
  interactive_plot_customization &lt;- function() {
    customization &lt;- list(
      
      # Change point properties interactively
      customize_points = function(x, y, 
                                 default_color = &quot;blue&quot;,
                                 default_size = 1,
                                 default_shape = 19) {
        cat(&quot;Interactive Point Customization\n&quot;)
        cat(&quot;Click on points to select them.\n&quot;)
        cat(&quot;Right-click or ESC when finished.\n\n&quot;)
        
        n &lt;- length(x)
        colors &lt;- rep(default_color, n)
        sizes &lt;- rep(default_size, n)
        shapes &lt;- rep(default_shape, n)
        
        # Initial plot
        plot(x, y, pch = shapes, col = colors, cex = sizes,
             main = &quot;Click points to customize\nRight-click to finish&quot;,
             xlab = &quot;X&quot;, ylab = &quot;Y&quot;)
        
        selected_points &lt;- c()
        
        while (TRUE) {
          cat(&quot;\nOptions:\n&quot;)
          cat(&quot;1. Click point to select\n&quot;)
          cat(&quot;2. Type &#x27;c&#x27; to change color\n&quot;)
          cat(&quot;3. Type &#x27;s&#x27; to change size\n&quot;)
          cat(&quot;4. Type &#x27;p&#x27; to change shape\n&quot;)
          cat(&quot;5. Type &#x27;d&#x27; to deselect all\n&quot;)
          cat(&quot;6. Type &#x27;q&#x27; to quit\n&quot;)
          
          # Get point selection
          selected &lt;- identify(x, y, n = 1, plot = FALSE)
          
          if (length(selected) == 0) {
            command &lt;- readline(&quot;Enter command: &quot;)
            
            if (command == &quot;q&quot;) break
            if (command == &quot;d&quot;) {
              selected_points &lt;- c()
              colors &lt;- rep(default_color, n)
              sizes &lt;- rep(default_size, n)
              shapes &lt;- rep(default_shape, n)
            } else if (command == &quot;c&quot; &amp;&amp; length(selected_points) &gt; 0) {
              new_color &lt;- readline(&quot;Enter color name: &quot;)
              colors[selected_points] &lt;- new_color
            } else if (command == &quot;s&quot; &amp;&amp; length(selected_points) &gt; 0) {
              new_size &lt;- as.numeric(readline(&quot;Enter size: &quot;))
              sizes[selected_points] &lt;- new_size
            } else if (command == &quot;p&quot; &amp;&amp; length(selected_points) &gt; 0) {
              new_shape &lt;- as.numeric(readline(&quot;Enter shape code: &quot;))
              shapes[selected_points] &lt;- new_shape
            }
          } else {
            selected_points &lt;- c(selected_points, selected)
            colors[selected] &lt;- &quot;red&quot;  # Highlight selected
            sizes[selected] &lt;- default_size * 1.5
          }
          
          # Redraw plot
          plot(x, y, pch = shapes, col = colors, cex = sizes,
               main = &quot;Click points to customize\nRight-click to finish&quot;,
               xlab = &quot;X&quot;, ylab = &quot;Y&quot;)
          
          if (length(selected_points) &gt; 0) {
            points(x[selected_points], y[selected_points],
                   pch = shapes[selected_points],
                   col = colors[selected_points],
                   cex = sizes[selected_points])
          }
        }
        
        return(list(x = x, y = y,
                   colors = colors,
                   sizes = sizes,
                   shapes = shapes,
                   selected = selected_points))
      },
      
      # Add annotations interactively
      add_interactive_annotations = function() {
        cat(&quot;Interactive Annotation Tool\n&quot;)
        cat(&quot;Commands:\n&quot;)
        cat(&quot;  Click: Place text\n&quot;)
        cat(&quot;  &#x27;l&#x27;: Draw line\n&quot;)
        cat(&quot;  &#x27;a&#x27;: Draw arrow\n&quot;)
        cat(&quot;  &#x27;r&#x27;: Draw rectangle\n&quot;)
        cat(&quot;  &#x27;c&#x27;: Draw circle\n&quot;)
        cat(&quot;  &#x27;p&#x27;: Draw polygon\n&quot;)
        cat(&quot;  &#x27;q&#x27;: Quit\n\n&quot;)
        
        annotations &lt;- list()
        
        while (TRUE) {
          command &lt;- readline(&quot;Enter command (or click for text): &quot;)
          
          if (command == &quot;q&quot;) break
          
          if (command == &quot;&quot;) {
            # Text annotation
            coords &lt;- locator(1)
            if (!is.null(coords)) {
              text_input &lt;- readline(&quot;Enter text: &quot;)
              text(coords$x, coords$y, text_input, col = &quot;blue&quot;)
              annotations &lt;- c(annotations, 
                              list(type = &quot;text&quot;,
                                   coords = coords,
                                   text = text_input))
            }
          } else if (command == &quot;l&quot;) {
            # Line
            cat(&quot;Click two points for line\n&quot;)
            coords &lt;- locator(2)
            if (length(coords$x) == 2) {
              lines(coords$x, coords$y, col = &quot;red&quot;, lwd = 2)
              annotations &lt;- c(annotations,
                              list(type = &quot;line&quot;,
                                   coords = coords))
            }
          } else if (command == &quot;a&quot;) {
            # Arrow
            cat(&quot;Click start and end points for arrow\n&quot;)
            coords &lt;- locator(2)
            if (length(coords$x) == 2) {
              arrows(coords$x[1], coords$y[1],
                     coords$x[2], coords$y[2],
                     col = &quot;green&quot;, lwd = 2, length = 0.1)
              annotations &lt;- c(annotations,
                              list(type = &quot;arrow&quot;,
                                   coords = coords))
            }
          } else if (command == &quot;r&quot;) {
            # Rectangle
            cat(&quot;Click two corners for rectangle\n&quot;)
            coords &lt;- locator(2)
            if (length(coords$x) == 2) {
              rect(min(coords$x), min(coords$y),
                   max(coords$x), max(coords$y),
                   border = &quot;purple&quot;, lwd = 2)
              annotations &lt;- c(annotations,
                              list(type = &quot;rectangle&quot;,
                                   coords = coords))
            }
          } else if (command == &quot;c&quot;) {
            # Circle
            cat(&quot;Click center, then edge for circle\n&quot;)
            center &lt;- locator(1)
            edge &lt;- locator(1)
            if (!is.null(center) &amp;&amp; !is.null(edge)) {
              radius &lt;- sqrt((edge$x - center$x)^2 + (edge$y - center$y)^2)
              symbols(center$x, center$y, circles = radius, inches = FALSE,
                      add = TRUE, fg = &quot;orange&quot;, lwd = 2)
              annotations &lt;- c(annotations,
                              list(type = &quot;circle&quot;,
                                   center = center,
                                   radius = radius))
            }
          } else if (command == &quot;p&quot;) {
            # Polygon
            cat(&quot;Click points for polygon\n&quot;)
            coords &lt;- locator(type = &quot;p&quot;)
            if (length(coords$x) &gt; 2) {
              polygon(coords$x, coords$y,
                      border = &quot;brown&quot;, lwd = 2)
              annotations &lt;- c(annotations,
                              list(type = &quot;polygon&quot;,
                                   coords = coords))
            }
          }
        }
        
        return(annotations)
      }
    )
    
    return(customization)
  }
  
  # 5. Demonstration Application
  demonstrate_interactive_system &lt;- function() {
    cat(&quot;INTERACTIVE COORDINATE SYSTEM DEMONSTRATION\n&quot;)
    cat(&quot;===========================================\n\n&quot;)
    
    # Create sample data
    set.seed(123)
    n &lt;- 50
    x &lt;- rnorm(n, mean = 0, sd = 2)
    y &lt;- x + rnorm(n, mean = 0, sd = 1)
    labels &lt;- paste0(&quot;P&quot;, 1:n)
    
    # Create the plot
    plot(x, y, pch = 19, col = &quot;blue&quot;, cex = 1.2,
         main = &quot;Interactive Coordinate System Demo&quot;,
         xlab = &quot;X Variable&quot;, ylab = &quot;Y Variable&quot;)
    grid()
    
    # Get interactive tools
    tools &lt;- basic_interactive_functions()
    transforms &lt;- coordinate_transformations()
    selection &lt;- selection_measurement_tools()
    custom &lt;- interactive_plot_customization()
    
    # Menu system
    while (TRUE) {
      cat(&quot;\nINTERACTIVE MENU\n&quot;)
      cat(&quot;================\n&quot;)
      cat(&quot;1. Identify points\n&quot;)
      cat(&quot;2. Draw and measure line\n&quot;)
      cat(&quot;3. Create polygon\n&quot;)
      cat(&quot;4. Place formatted text\n&quot;)
      cat(&quot;5. Select rectangle area\n&quot;)
      cat(&quot;6. Measure path distance\n&quot;)
      cat(&quot;7. Measure area\n&quot;)
      cat(&quot;8. Customize points\n&quot;)
      cat(&quot;9. Add annotations\n&quot;)
      cat(&quot;0. Exit\n&quot;)
      
      choice &lt;- as.numeric(readline(&quot;Enter choice: &quot;))
      
      if (choice == 0) break
      
      switch(choice,
             # 1. Identify points
             {
               cat(&quot;\n=== IDENTIFY POINTS ===\n&quot;)
               identified &lt;- tools$identify_with_labels(x, y, labels)
             },
             
             # 2. Draw and measure line
             {
               cat(&quot;\n=== DRAW AND MEASURE LINE ===\n&quot;)
               line_result &lt;- tools$draw_and_measure_line()
             },
             
             # 3. Create polygon
             {
               cat(&quot;\n=== CREATE POLYGON ===\n&quot;)
               polygon_result &lt;- tools$create_interactive_polygon()
             },
             
             # 4. Place formatted text
             {
               cat(&quot;\n=== PLACE FORMATTED TEXT ===\n&quot;)
               text_result &lt;- tools$place_formatted_text(show_box = TRUE)
             },
             
             # 5. Select rectangle area
             {
               cat(&quot;\n=== SELECT RECTANGLE AREA ===\n&quot;)
               rect_result &lt;- selection$select_rectangle()
               
               if (!is.null(rect_result)) {
                 # Find points within rectangle
                 inside &lt;- x &gt;= rect_result$xlim[1] &amp; x &lt;= rect_result$xlim[2] &amp;
                           y &gt;= rect_result$ylim[1] &amp; y &lt;= rect_result$ylim[2]
                 
                 if (any(inside)) {
                   cat(&quot;Points inside rectangle:\n&quot;)
                   print(data.frame(Index = which(inside),
                                   X = x[inside],
                                   Y = y[inside]))
                 } else {
                   cat(&quot;No points inside rectangle.\n&quot;)
                 }
               }
             },
             
             # 6. Measure path distance
             {
               cat(&quot;\n=== MEASURE PATH DISTANCE ===\n&quot;)
               path_result &lt;- selection$measure_path()
             },
             
             # 7. Measure area
             {
               cat(&quot;\n=== MEASURE AREA ===\n&quot;)
               area_result &lt;- selection$measure_area()
             },
             
             # 8. Customize points
             {
               cat(&quot;\n=== CUSTOMIZE POINTS ===\n&quot;)
               # Replot for customization
               plot(x, y, pch = 19, col = &quot;blue&quot;, cex = 1.2,
                    main = &quot;Point Customization&quot;,
                    xlab = &quot;X&quot;, ylab = &quot;Y&quot;)
               grid()
               
               custom_result &lt;- custom$customize_points(x, y)
             },
             
             # 9. Add annotations
             {
               cat(&quot;\n=== ADD ANNOTATIONS ===\n&quot;)
               annotation_result &lt;- custom$add_interactive_annotations()
             },
             
             # Default
             {
               cat(&quot;Invalid choice. Please try again.\n&quot;)
             }
      )
      
      # Ask to continue
      continue &lt;- readline(&quot;\nContinue? (y/n): &quot;)
      if (tolower(continue) != &quot;y&quot;) break
    }
    
    cat(&quot;\nInteractive demonstration complete.\n&quot;)
  }
  
  # 6. Return the complete interactive system
  return(list(
    basic_functions = basic_interactive_functions(),
    transformations = coordinate_transformations(),
    selection_tools = selection_measurement_tools(),
    plot_customization = interactive_plot_customization(),
    demonstration = demonstrate_interactive_system
  ))
}

# Create interactive coordinate system
interactive_system &lt;- interactive_coordinate_system()

# Run the demonstration (uncomment to run)
# interactive_system$demonstration()</code></pre>
            </div>
            
</section>

            <section class="content-section" id="d-customizing-traditional-r-plots">
                <h3 class="section-heading"><strong>D. Customizing Traditional R Plots</strong></h3>
            

            <div class="code-block">
                <pre><code class="language-r"># Advanced Customization of Traditional R Plots
traditional_plot_customization &lt;- function() {
  
  # 1. Axis Customization System
  axis_customization &lt;- function() {
    axis_functions &lt;- list(
      
      # Custom axis with breaks and labels
      custom_axis = function(side = 1, 
                            at = NULL,
                            labels = TRUE,
                            line = 0,
                            pos = NA,
                            outer = FALSE,
                            font = NA,
                            lty = &quot;solid&quot;,
                            lwd = 1,
                            lwd.ticks = lwd,
                            col = NULL,
                            col.ticks = NULL,
                            hadj = NA,
                            padj = NA,
                            gap.axis = NA,
                            ...) {
        
        # If &#x27;at&#x27; is not provided, use pretty locations
        if (is.null(at)) {
          usr &lt;- par(&quot;usr&quot;)
          if (side %in% c(1, 3)) {  # x-axis
            at &lt;- pretty(usr[1:2])
          } else {  # y-axis
            at &lt;- pretty(usr[3:4])
          }
        }
        
        # Create custom labels if provided as function
        if (is.function(labels)) {
          labels &lt;- labels(at)
        }
        
        # Draw the axis
        axis(side = side, at = at, labels = labels,
             line = line, pos = pos, outer = outer,
             font = font, lty = lty, lwd = lwd,
             lwd.ticks = lwd.ticks, col = col,
             col.ticks = col.ticks, hadj = hadj,
             padj = padj, gap.axis = gap.axis, ...)
        
        return(list(at = at, labels = labels))
      },
      
      # Logarithmic axis with formatted labels
      log_axis = function(side = 1, base = 10, 
                         scientific = FALSE,
                         minor = TRUE,
                         ...) {
        
        # Get data range
        usr &lt;- par(&quot;usr&quot;)
        if (side %in% c(1, 3)) {  # x-axis
          data_range &lt;- usr[1:2]
        } else {  # y-axis
          data_range &lt;- usr[3:4]
        }
        
        # Calculate major ticks
        log_range &lt;- log(data_range, base)
        min_power &lt;- floor(min(log_range))
        max_power &lt;- ceiling(max(log_range))
        
        major_ticks &lt;- base^(min_power:max_power)
        major_labels &lt;- if (scientific) {
          sapply(min_power:max_power, function(p) {
            if (base == 10) {
              expression(10^{
                .(p)
              })
            } else {
              paste0(base, &quot;^&quot;, p)
            }
          })
        } else {
          format(major_ticks, scientific = FALSE)
        }
        
        # Draw major ticks
        axis(side = side, at = major_ticks, labels = major_labels, ...)
        
        # Add minor ticks if requested
        if (minor) {
          minor_values &lt;- c()
          for (i in min_power:(max_power - 1)) {
            minor_values &lt;- c(minor_values, 
                             seq(base^i, base^(i + 1), length.out = base + 1)[2:base])
          }
          axis(side = side, at = minor_values, labels = FALSE, tcl = -0.3)
        }
        
        return(list(major_ticks = major_ticks,
                   minor_ticks = if (minor) minor_values else NULL))
      },
      
      # Time series axis with date formatting
      date_axis = function(side = 1,
                          dates,
                          format = &quot;%Y-%m-%d&quot;,
                          at = NULL,
                          labels = NULL,
                          every_n = 1,
                          angle = 0,
                          ...) {
        
        if (is.null(at)) {
          # Automatic tick placement
          n_dates &lt;- length(dates)
          seq_indices &lt;- seq(1, n_dates, by = every_n)
          at &lt;- seq_indices
        }
        
        if (is.null(labels)) {
          if (inherits(dates, &quot;Date&quot;) || inherits(dates, &quot;POSIXt&quot;)) {
            labels &lt;- format(dates[at], format = format)
          } else {
            labels &lt;- as.character(dates[at])
          }
        }
        
        # Draw axis
        axis(side = side, at = at, labels = labels, ...)
        
        # Rotate labels if requested
        if (angle != 0) {
          # This requires setting xaxt = &quot;n&quot; in main plot and using text()
          warning(&quot;For rotated labels, use text() instead of axis() with xaxt=&#x27;n&#x27;&quot;)
        }
        
        return(list(at = at, labels = labels))
      },
      
      # Dual axis system
      dual_axis = function(x, y1, y2,
                          y1_label = &quot;Primary Axis&quot;,
                          y2_label = &quot;Secondary Axis&quot;,
                          y1_col = &quot;blue&quot;,
                          y2_col = &quot;red&quot;) {
        
        # Plot primary data
        plot(x, y1, type = &quot;l&quot;, col = y1_col, lwd = 2,
             xlab = &quot;X&quot;, ylab = y1_label,
             ylim = range(y1, na.rm = TRUE))
        axis(2, col = y1_col, col.axis = y1_col, lwd = 2)
        
        # Allow second plot on same graph
        par(new = TRUE)
        
        # Plot secondary data
        plot(x, y2, type = &quot;l&quot;, col = y2_col, lwd = 2,
             axes = FALSE, xlab = &quot;&quot;, ylab = &quot;&quot;,
             ylim = range(y2, na.rm = TRUE))
        axis(4, col = y2_col, col.axis = y2_col, lwd = 2)
        mtext(y2_label, side = 4, line = 3, col = y2_col)
        
        # Add legend
        legend(&quot;topleft&quot;,
               legend = c(y1_label, y2_label),
               col = c(y1_col, y2_col),
               lwd = 2,
               bg = &quot;white&quot;)
      },
      
      # Polar coordinate axis
      polar_axis = function(radius = 1,
                           n_sectors = 12,
                           labels = NULL,
                           radial_lines = TRUE,
                           radial_col = &quot;gray70&quot;,
                           radial_lty = 3) {
        
        # Create circle
        angles &lt;- seq(0, 2 * pi, length.out = 100)
        x_circle &lt;- radius * cos(angles)
        y_circle &lt;- radius * sin(angles)
        
        plot(x_circle, y_circle, type = &quot;l&quot;, 
             asp = 1, axes = FALSE,
             xlab = &quot;&quot;, ylab = &quot;&quot;,
             xlim = c(-radius * 1.1, radius * 1.1),
             ylim = c(-radius * 1.1, radius * 1.1))
        
        # Add center point
        points(0, 0, pch = 19, col = &quot;red&quot;, cex = 1.5)
        
        # Add radial lines
        if (radial_lines) {
          sector_angles &lt;- seq(0, 2 * pi, length.out = n_sectors + 1)[1:n_sectors]
          for (angle in sector_angles) {
            x_end &lt;- radius * cos(angle)
            y_end &lt;- radius * sin(angle)
            segments(0, 0, x_end, y_end, 
                     col = radial_col, lty = radial_lty)
          }
        }
        
        # Add angle labels
        if (is.null(labels)) {
          labels &lt;- paste0(seq(0, 360 - 360/n_sectors, length.out = n_sectors), &quot;°&quot;)
        }
        
        label_angles &lt;- seq(0, 2 * pi, length.out = n_sectors + 1)[1:n_sectors]
        label_radius &lt;- radius * 1.05
        
        for (i in 1:n_sectors) {
          x_label &lt;- label_radius * cos(label_angles[i])
          y_label &lt;- label_radius * sin(label_angles[i])
          text(x_label, y_label, labels[i], 
               adj = c(0.5, 0.5), col = &quot;darkblue&quot;)
        }
        
        # Add concentric circles
        n_circles &lt;- 4
        for (r in seq(radius/n_circles, radius, length.out = n_circles)) {
          x_circle &lt;- r * cos(angles)
          y_circle &lt;- r * sin(angles)
          lines(x_circle, y_circle, col = &quot;gray50&quot;, lty = 2)
          text(0, r, sprintf(&quot;%.1f&quot;, r), pos = 3, col = &quot;darkgreen&quot;)
        }
      }
    )
    
    return(axis_functions)
  }
  
  # 2. Legend Customization System
  legend_customization &lt;- function() {
    legend_functions &lt;- list(
      
      # Custom legend with formatting
      custom_legend = function(position = &quot;topright&quot;,
                              legend,
                              col,
                              lty = 1,
                              lwd = 1,
                              pch = NULL,
                              bg = &quot;white&quot;,
                              box.col = &quot;black&quot;,
                              box.lty = 1,
                              box.lwd = 1,
                              title = NULL,
                              title.col = &quot;black&quot;,
                              title.font = 2,
                              text.col = &quot;black&quot;,
                              text.font = 1,
                              text.width = NULL,
                              horiz = FALSE,
                              ncol = 1,
                              inset = 0.05,
                              x.intersp = 1,
                              y.intersp = 1,
                              seg.len = 2,
                              ...) {
        
        legend(position,
               legend = legend,
               col = col,
               lty = lty,
               lwd = lwd,
               pch = pch,
               bg = bg,
               box.col = box.col,
               box.lty = box.lty,
               box.lwd = box.lwd,
               title = title,
               title.col = title.col,
               title.font = title.font,
               text.col = text.col,
               text.font = text.font,
               text.width = text.width,
               horiz = horiz,
               ncol = ncol,
               inset = inset,
               x.intersp = x.intersp,
               y.intersp = y.intersp,
               seg.len = seg.len,
               ...)
      },
      
      # Gradient legend for continuous variables
      gradient_legend = function(col = heat.colors(100),
                                breaks = NULL,
                                title = &quot;Value&quot;,
                                horizontal = TRUE,
                                size = c(0.1, 0.03),
                                offset = c(0.05, 0.05)) {
        
        # Get plot coordinates
        usr &lt;- par(&quot;usr&quot;)
        xlim &lt;- usr[1:2]
        ylim &lt;- usr[3:4]
        
        # Calculate legend position
        if (horizontal) {
          # Horizontal legend at bottom
          x_left &lt;- xlim[1] + diff(xlim) * offset[1]
          x_right &lt;- xlim[2] - diff(xlim) * offset[1]
          y_bottom &lt;- ylim[1] + diff(ylim) * offset[2]
          y_top &lt;- y_bottom + diff(ylim) * size[2]
        } else {
          # Vertical legend at right
          x_left &lt;- xlim[2] - diff(xlim) * size[1]
          x_right &lt;- xlim[2] - diff(xlim) * offset[1]
          y_bottom &lt;- ylim[1] + diff(ylim) * offset[2]
          y_top &lt;- ylim[2] - diff(ylim) * offset[2]
        }
        
        # Create color gradient
        n_colors &lt;- length(col)
        
        if (horizontal) {
          # Horizontal gradient
          x_seq &lt;- seq(x_left, x_right, length.out = n_colors + 1)
          for (i in 1:n_colors) {
            rect(x_seq[i], y_bottom, x_seq[i + 1], y_top,
                 col = col[i], border = NA)
          }
          # Add border
          rect(x_left, y_bottom, x_right, y_top, border = &quot;black&quot;)
          
          # Add labels
          if (!is.null(breaks)) {
            x_breaks &lt;- seq(x_left, x_right, length.out = length(breaks))
            axis(1, at = x_breaks, labels = breaks, 
                 pos = y_top, tick = FALSE, line = -1)
          }
          
          # Add title
          text(mean(c(x_left, x_right)), y_top, title,
               pos = 3, font = 2)
        } else {
          # Vertical gradient
          y_seq &lt;- seq(y_bottom, y_top, length.out = n_colors + 1)
          for (i in 1:n_colors) {
            rect(x_left, y_seq[i], x_right, y_seq[i + 1],
                 col = col[i], border = NA)
          }
          # Add border
          rect(x_left, y_bottom, x_right, y_top, border = &quot;black&quot;)
          
          # Add labels
          if (!is.null(breaks)) {
            y_breaks &lt;- seq(y_bottom, y_top, length.out = length(breaks))
            axis(4, at = y_breaks, labels = breaks,
                 pos = x_right, tick = FALSE, line = -1, las = 1)
          }
          
          # Add title
          text(x_right, y_top, title, pos = 3, font = 2, srt = -90)
        }
      },
      
      # Interactive legend placement
      interactive_legend = function(legend, col, pch = 19, ...) {
        cat(&quot;Click where you want to place the legend.\n&quot;)
        coords &lt;- locator(1)
        
        if (!is.null(coords)) {
          legend(coords$x, coords$y,
                 legend = legend,
                 col = col,
                 pch = pch,
                 ...)
          return(coords)
        }
        return(NULL)
      },
      
      # Legend with mathematical expressions
      math_legend = function(position = &quot;topright&quot;,
                            expressions,
                            col,
                            ...) {
        
        # Convert expressions to character for legend
        expr_text &lt;- sapply(expressions, function(expr) {
          as.expression(expr)
        })
        
        legend(position,
               legend = expr_text,
               col = col,
               ...)
      },
      
      # Multiple legends in one plot
      multiple_legends = function(legend_specs) {
        # legend_specs: list of lists with legend parameters
        
        for (spec in legend_specs) {
          do.call(legend, spec)
        }
      }
    )
    
    return(legend_functions)
  }
  
  # 3. Complete Traditional Plot Customization Demonstration
  demonstrate_traditional_customization &lt;- function() {
    cat(&quot;TRADITIONAL R PLOT CUSTOMIZATION DEMONSTRATION\n&quot;)
    cat(&quot;==============================================\n\n&quot;)
    
    # Create sample data
    set.seed(123)
    n &lt;- 100
    
    # Time series data
    dates &lt;- seq(as.Date(&quot;2023-01-01&quot;), by = &quot;day&quot;, length.out = n)
    ts_data &lt;- cumsum(rnorm(n))
    
    # Multiple series data
    x &lt;- 1:n
    y1 &lt;- sin(x/10) + rnorm(n, sd = 0.2)
    y2 &lt;- cos(x/10) + rnorm(n, sd = 0.2)
    y3 &lt;- tan(x/20) + rnorm(n, sd = 0.1)
    
    # Continuous data for gradient
    x_cont &lt;- seq(-3, 3, length.out = 50)
    y_cont &lt;- seq(-3, 3, length.out = 50)
    z &lt;- outer(x_cont, y_cont, function(x, y) x^2 + y^2)
    
    # Get customization functions
    axis_funcs &lt;- axis_customization()
    legend_funcs &lt;- legend_customization()
    
    # Setup multi-panel plot
    old_par &lt;- par(no.readonly = TRUE)
    layout(matrix(1:4, nrow = 2, byrow = TRUE))
    
    # Plot 1: Custom axes with date formatting
    par(mar = c(5, 4, 4, 2) + 0.1)
    plot(1:n, ts_data, type = &quot;l&quot;, lwd = 2, col = &quot;blue&quot;,
         xaxt = &quot;n&quot;,  # Suppress default x-axis
         main = &quot;Custom Date Axis&quot;,
         xlab = &quot;Date&quot;, ylab = &quot;Value&quot;)
    
    # Add custom date axis
    axis_funcs$date_axis(side = 1, dates = dates, 
                        format = &quot;%b %d&quot;, every_n = 10)
    grid()
    
    # Add secondary y-axis
    par(new = TRUE)
    plot(1:n, ts_data * 100, type = &quot;l&quot;, lwd = 2, col = &quot;red&quot;,
         axes = FALSE, xlab = &quot;&quot;, ylab = &quot;&quot;)
    axis(4, col = &quot;red&quot;, col.axis = &quot;red&quot;, lwd = 2)
    mtext(&quot;Scaled Value (x100)&quot;, side = 4, line = 3, col = &quot;red&quot;)
    
    # Plot 2: Logarithmic axes
    par(mar = c(5, 4, 4, 2) + 0.1)
    x_log &lt;- 10^seq(0, 3, length.out = n)
    y_log &lt;- x_log^1.5 + rnorm(n, sd = 100)
    
    plot(x_log, y_log, log = &quot;xy&quot;,  # Both axes logarithmic
         pch = 19, col = &quot;darkgreen&quot;,
         main = &quot;Logarithmic Axes&quot;,
         xlab = &quot;X (log scale)&quot;, ylab = &quot;Y (log scale)&quot;)
    
    # Add custom grid for log scale
    grid(equilogs = FALSE)
    
    # Add custom legend with expressions
    legend_funcs$math_legend(
      position = &quot;bottomright&quot;,
      expressions = list(
        expression(y == x^{1.5}),
        expression(log(y) == 1.5 %.% log(x))
      ),
      col = c(&quot;darkgreen&quot;, NA),
      pch = c(19, NA),
      lty = c(NA, 1),
      lwd = c(NA, 2),
      bg = &quot;white&quot;
    )
    
    # Plot 3: Multiple series with custom legend
    par(mar = c(5, 4, 4, 2) + 0.1)
    matplot(x, cbind(y1, y2, y3), type = &quot;l&quot;, lwd = 2,
            col = c(&quot;blue&quot;, &quot;red&quot;, &quot;green&quot;),
            lty = c(1, 2, 3),
            main = &quot;Multiple Series with Custom Legend&quot;,
            xlab = &quot;Index&quot;, ylab = &quot;Value&quot;)
    grid()
    
    # Add custom legend
    legend_funcs$custom_legend(
      position = &quot;topright&quot;,
      legend = c(&quot;Sine&quot;, &quot;Cosine&quot;, &quot;Tangent&quot;),
      col = c(&quot;blue&quot;, &quot;red&quot;, &quot;green&quot;),
      lty = c(1, 2, 3),
      lwd = 2,
      title = &quot;Trigonometric Functions&quot;,
      title.col = &quot;darkblue&quot;,
      bg = &quot;gray95&quot;,
      box.col = &quot;blue&quot;,
      box.lwd = 2
    )
    
    # Plot 4: Gradient plot with color legend
    par(mar = c(5, 4, 4, 2) + 0.1)
    # Create heatmap
    image(x_cont, y_cont, z,
          col = heat.colors(50),
          main = &quot;Heatmap with Gradient Legend&quot;,
          xlab = &quot;X&quot;, ylab = &quot;Y&quot;)
    
    # Add contour lines
    contour(x_cont, y_cont, z, add = TRUE, col = &quot;white&quot;)
    
    # Add gradient legend
    legend_funcs$gradient_legend(
      col = heat.colors(100),
      breaks = seq(min(z), max(z), length.out = 5),
      title = expression(z == x^2 + y^2),
      horizontal = TRUE,
      size = c(0.8, 0.05),
      offset = c(0.1, 0.1)
    )
    
    # Additional: Polar plot demonstration
    cat(&quot;\nCreating polar coordinate plot...\n&quot;)
    dev.new()  # Open new device for polar plot
    
    axis_funcs$polar_axis(
      radius = 10,
      n_sectors = 8,
      labels = c(&quot;N&quot;, &quot;NE&quot;, &quot;E&quot;, &quot;SE&quot;, &quot;S&quot;, &quot;SW&quot;, &quot;W&quot;, &quot;NW&quot;),
      radial_lines = TRUE
    )
    
    # Add some data points in polar coordinates
    n_points &lt;- 20
    r_points &lt;- runif(n_points, 0, 10)
    theta_points &lt;- runif(n_points, 0, 2 * pi)
    x_points &lt;- r_points * cos(theta_points)
    y_points &lt;- r_points * sin(theta_points)
    
    points(x_points, y_points, pch = 19, col = &quot;red&quot;, cex = 1.5)
    
    # Add legend
    legend(&quot;bottomleft&quot;,
           legend = c(&quot;Radial Lines&quot;, &quot;Data Points&quot;),
           col = c(&quot;gray70&quot;, &quot;red&quot;),
           lty = c(3, NA),
           pch = c(NA, 19),
           bg = &quot;white&quot;)
    
    # Reset parameters
    par(old_par)
    
    cat(&quot;\nDemonstration complete.\n&quot;)
  }
  
  # 4. Advanced Grid and Background Customization
  grid_background_customization &lt;- function() {
    customization &lt;- list(
      
      # Custom grid system
      custom_grid = function(x = NULL, y = NULL,
                            col = &quot;gray&quot;,
                            lty = 2,
                            lwd = 0.5,
                            equilogs = TRUE,
                            nx = NULL, ny = NULL) {
        
        # Get plot limits
        usr &lt;- par(&quot;usr&quot;)
        
        # Determine grid lines
        if (is.null(x)) {
          x &lt;- axTicks(1)
        }
        if (is.null(y)) {
          y &lt;- axTicks(2)
        }
        
        # Draw vertical grid lines
        abline(v = x, col = col, lty = lty, lwd = lwd)
        
        # Draw horizontal grid lines
        abline(h = y, col = col, lty = lty, lwd = lwd)
        
        # Return grid coordinates
        return(list(x = x, y = y))
      },
      
      # Background gradient
      gradient_background = function(cols = c(&quot;white&quot;, &quot;lightblue&quot;, &quot;darkblue&quot;),
                                    direction = &quot;vertical&quot;,
                                    n = 100) {
        
        usr &lt;- par(&quot;usr&quot;)
        
        # Create gradient colors
        gradient_cols &lt;- colorRampPalette(cols)(n)
        
        if (direction == &quot;vertical&quot;) {
          # Vertical gradient
          y_seq &lt;- seq(usr[3], usr[4], length.out = n + 1)
          for (i in 1:n) {
            rect(usr[1], y_seq[i], usr[2], y_seq[i + 1],
                 col = gradient_cols[i], border = NA)
          }
        } else {
          # Horizontal gradient
          x_seq &lt;- seq(usr[1], usr[2], length.out = n + 1)
          for (i in 1:n) {
            rect(x_seq[i], usr[3], x_seq[i + 1], usr[4],
                 col = gradient_cols[i], border = NA)
          }
        }
      },
      
      # Checkerboard background
      checkerboard_background = function(size = 1,
                                        col1 = &quot;white&quot;,
                                        col2 = &quot;gray90&quot;) {
        
        usr &lt;- par(&quot;usr&quot;)
        
        # Calculate number of squares
        x_range &lt;- diff(usr[1:2])
        y_range &lt;- diff(usr[3:4])
        
        n_x &lt;- ceiling(x_range / size)
        n_y &lt;- ceiling(y_range / size)
        
        # Draw checkerboard
        for (i in 0:(n_x - 1)) {
          for (j in 0:(n_y - 1)) {
            x_left &lt;- usr[1] + i * size
            x_right &lt;- min(x_left + size, usr[2])
            y_bottom &lt;- usr[3] + j * size
            y_top &lt;- min(y_bottom + size, usr[4])
            
            fill_col &lt;- if ((i + j) %% 2 == 0) col1 else col2
            rect(x_left, y_bottom, x_right, y_top,
                 col = fill_col, border = NA)
          }
        }
      },
      
      # Watermark
      add_watermark = function(text = &quot;DRAFT&quot;,
                              col = rgb(0, 0, 0, 0.1),
                              cex = 3,
                              angle = 45) {
        
        usr &lt;- par(&quot;usr&quot;)
        center_x &lt;- mean(usr[1:2])
        center_y &lt;- mean(usr[3:4])
        
        text(center_x, center_y, text,
             col = col, cex = cex, font = 2,
             srt = angle)
      }
    )
    
    return(customization)
  }
  
  # 5. Return complete customization system
  return(list(
    axis_customization = axis_customization(),
    legend_customization = legend_customization(),
    grid_background = grid_background_customization(),
    demonstration = demonstrate_traditional_customization
  ))
}

# Create traditional plot customization system
traditional_customization &lt;- traditional_plot_customization()

# Run demonstration
traditional_customization$demonstration()</code></pre>
            </div>
            
</section>

            <section class="content-section" id="e-specialized-text-and-label-notation">
                <h3 class="section-heading"><strong>E. Specialized Text and Label Notation</strong></h3>
            

            <div class="code-block">
                <pre><code class="language-r"># Advanced Text and Mathematical Notation
advanced_text_notation &lt;- function() {
  
  # 1. Mathematical Expressions System
  mathematical_expressions &lt;- function() {
    expressions &lt;- list(
      
      # Basic mathematical symbols
      symbols = list(
        alpha = expression(alpha),
        beta = expression(beta),
        gamma = expression(gamma),
        delta = expression(delta),
        epsilon = expression(epsilon),
        theta = expression(theta),
        pi = expression(pi),
        sigma = expression(sigma),
        mu = expression(mu),
        infinity = expression(infinity),
        partial = expression(partialdiff),
        integral = expression(integral()),
        sum = expression(sum()),
        product = expression(prod())
      ),
      
      # Fractions and division
      fractions = function(numerator, denominator) {
        expression(frac(.(numerator), .(denominator)))
      },
      
      # Superscripts and subscripts
      superscript = function(base, exponent) {
        expression(.(base)^{
          .(exponent)
        })
      },
      
      subscript = function(base, index) {
        expression(.(base)[
          .(index)
        ])
      },
      
      # Combined superscript and subscript
      both_scripts = function(base, sup, sub) {
        expression(.(base)[
          .(sub)
        ]^{
          .(sup)
        })
      },
      
      # Square roots
      sqrt_expr = function(expr) {
        expression(sqrt(.(expr)))
      },
      
      nth_root = function(expr, n) {
        expression(root(.(n))(.(expr)))
      },
      
      # Logarithms
      log_expr = function(expr, base = NULL) {
        if (is.null(base)) {
          expression(log(.(expr)))
        } else if (base == exp(1)) {
          expression(ln(.(expr)))
        } else if (base == 10) {
          expression(log[10](.(expr)))
        } else {
          expression(log[.(base)](.(expr)))
        }
      },
      
      # Trigonometric functions
      trig = list(
        sin = expression(sin(theta)),
        cos = expression(cos(theta)),
        tan = expression(tan(theta)),
        arcsin = expression(arcsin(x)),
        arccos = expression(arccos(x)),
        arctan = expression(arctan(x))
      ),
      
      # Statistical expressions
      statistics = list(
        mean = expression(bar(x)),
        variance = expression(s^{
          2
        }),
        std_dev = expression(s),
        correlation = expression(r),
        regression = expression(hat(y) == beta[0] + beta[1] * x),
        normal_dist = expression(N(mu, sigma^{
          2
        }))
      ),
      
      # Chemical and physical notations
      scientific = list(
        water = expression(H[2] * O),
        carbon_dioxide = expression(CO[2]),
        energy = expression(E == mc^{
          2
        }),
        planck = expression(E == h * nu),
        avogadro = expression(N[A] == 6.022 %*% 10^{
          23
        })
      ),
      
      # Create custom expression from string
      parse_expression = function(expr_string) {
        parse(text = expr_string)
      },
      
      # Display multiple expressions
      multi_expression = function(expr_list) {
        lapply(expr_list, function(x) parse(text = x))
      }
    )
    
    return(expressions)
  }
  
  # 2. Unicode and Special Characters
  unicode_characters &lt;- function() {
    characters &lt;- list(
      
      # Greek letters
      greek = list(
        Alpha = &quot;\u0391&quot;,
        alpha = &quot;\u03B1&quot;,
        Beta = &quot;\u0392&quot;,
        beta = &quot;\u03B2&quot;,
        Gamma = &quot;\u0393&quot;,
        gamma = &quot;\u03B3&quot;,
        Delta = &quot;\u0394&quot;,
        delta = &quot;\u03B4&quot;,
        Epsilon = &quot;\u0395&quot;,
        epsilon = &quot;\u03B5&quot;,
        Theta = &quot;\u0398&quot;,
        theta = &quot;\u03B8&quot;,
        Pi = &quot;\u03A0&quot;,
        pi = &quot;\u03C0&quot;,
        Sigma = &quot;\u03A3&quot;,
        sigma = &quot;\u03C3&quot;,
        Omega = &quot;\u03A9&quot;,
        omega = &quot;\u03C9&quot;
      ),
      
      # Mathematical symbols
      math = list(
        plus_minus = &quot;\u00B1&quot;,
        multiply = &quot;\u00D7&quot;,
        divide = &quot;\u00F7&quot;,
        not_equal = &quot;\u2260&quot;,
        less_equal = &quot;\u2264&quot;,
        greater_equal = &quot;\u2265&quot;,
        approx_equal = &quot;\u2248&quot;,
        proportional = &quot;\u221D&quot;,
        infinity = &quot;\u221E&quot;,
        degree = &quot;\u00B0&quot;,
        partial = &quot;\u2202&quot;,
        integral = &quot;\u222B&quot;,
        square_root = &quot;\u221A&quot;,
        dot_operator = &quot;\u22C5&quot;
      ),
      
      # Arrows
      arrows = list(
        left = &quot;\u2190&quot;,
        right = &quot;\u2192&quot;,
        up = &quot;\u2191&quot;,
        down = &quot;\u2193&quot;,
        left_right = &quot;\u2194&quot;,
        up_down = &quot;\u2195&quot;,
        left_arrow = &quot;\u27F5&quot;,
        right_arrow = &quot;\u27F6&quot;
      ),
      
      # Currency symbols
      currency = list(
        dollar = &quot;$&quot;,
        euro = &quot;\u20AC&quot;,
        pound = &quot;\u00A3&quot;,
        yen = &quot;\u00A5&quot;,
        rupee = &quot;\u20B9&quot;,
        bitcoin = &quot;\u20BF&quot;
      ),
      
      # Check and cross marks
      marks = list(
        check = &quot;\u2713&quot;,
        cross = &quot;\u2717&quot;,
        check_box = &quot;\u2611&quot;,
        ballot_box = &quot;\u2610&quot;
      ),
      
      # Stars and symbols
      stars = list(
        star = &quot;\u2605&quot;,
        hollow_star = &quot;\u2606&quot;,
        sun = &quot;\u2600&quot;,
        cloud = &quot;\u2601&quot;,
        snowflake = &quot;\u2744&quot;,
        heart = &quot;\u2764&quot;,
        spade = &quot;\u2660&quot;,
        club = &quot;\u2663&quot;,
        diamond = &quot;\u2666&quot;
      ),
      
      # Utility functions
      utilities = list(
        # Check if system supports Unicode
        supports_unicode = function() {
          l10n_info()$`UTF-8`
        },
        
        # Convert character code to Unicode
        code_to_unicode = function(code) {
          intToUtf8(code)
        },
        
        # Get Unicode character by name
        get_by_name = function(name) {
          # This would typically use a lookup table
          switch(name,
                 &quot;alpha&quot; = &quot;\u03B1&quot;,
                 &quot;beta&quot; = &quot;\u03B2&quot;,
                 &quot;gamma&quot; = &quot;\u03B3&quot;,
                 NA)
        },
        
        # Display Unicode table
        show_table = function(start = 0x2500, end = 0x2600) {
          cat(&quot;Unicode Characters from&quot;, sprintf(&quot;U+%04X&quot;, start),
              &quot;to&quot;, sprintf(&quot;U+%04X&quot;, end), &quot;\n&quot;)
          cat(rep(&quot;-&quot;, 60), &quot;\n&quot;, sep = &quot;&quot;)
          
          for (code in seq(start, end, by = 16)) {
            line_codes &lt;- code:(code + 15)
            line_chars &lt;- sapply(line_codes, function(c) {
              tryCatch({
                intToUtf8(c)
              }, error = function(e) &quot; &quot;)
            })
            
            code_str &lt;- paste(sprintf(&quot;U+%04X&quot;, line_codes), collapse = &quot; &quot;)
            char_str &lt;- paste(line_chars, collapse = &quot; &quot;)
            
            cat(code_str, &quot;\n&quot;, char_str, &quot;\n\n&quot;, sep = &quot;&quot;)
          }
        }
      )
    )
    
    return(characters)
  }
  
  # 3. Text Formatting and Annotation
  text_formatting &lt;- function() {
    formatting &lt;- list(
      
      # Annotate plot with formatted text
      annotate_plot = function(x, y, text,
                              font = 1,
                              family = &quot;sans&quot;,
                              cex = 1,
                              col = &quot;black&quot;,
                              adj = c(0.5, 0.5),
                              srt = 0,
                              ...) {
        
        # Handle expressions
        if (is.expression(text) || is.call(text)) {
          # It&#x27;s already an expression
          expr_text &lt;- text
        } else if (is.character(text) &amp;&amp; grepl(&quot;\\$.*\\$&quot;, text)) {
          # Contains LaTeX-like math
          expr_text &lt;- parse(text = gsub(&quot;\\$(.*?)\\$&quot;, &quot;\\1&quot;, text))
        } else {
          # Regular text
          expr_text &lt;- text
        }
        
        # Plot the text
        text(x, y, labels = expr_text,
             font = font, family = family,
             cex = cex, col = col,
             adj = adj, srt = srt, ...)
      },
      
      # Add text with background box
      text_with_box = function(x, y, text,
                              col = &quot;black&quot;,
                              bg = &quot;white&quot;,
                              border = &quot;black&quot;,
                              padding = 0.1,
                              ...) {
        
        # Calculate text dimensions
        text_width &lt;- strwidth(text, ...)
        text_height &lt;- strheight(text, ...)
        
        # Add padding
        pad_x &lt;- text_width * padding
        pad_y &lt;- text_height * padding
        
        # Draw background box
        rect(x - text_width/2 - pad_x,
             y - text_height/2 - pad_y,
             x + text_width/2 + pad_x,
             y + text_height/2 + pad_y,
             col = bg, border = border)
        
        # Draw text
        text(x, y, text, col = col, ...)
      },
      
      # Add curved text along a path
      curved_text = function(x, y, text,
                            radius = NULL,
                            start_angle = 0,
                            end_angle = 360,
                            clockwise = FALSE,
                            ...) {
        
        # Convert angles to radians
        start_rad &lt;- start_angle * pi / 180
        end_rad &lt;- end_angle * pi / 180
        
        # Calculate radius if not provided
        if (is.null(radius)) {
          radius &lt;- sqrt(x^2 + y^2)
        }
        
        # Calculate angles for each character
        n_chars &lt;- nchar(text)
        if (clockwise) {
          angles &lt;- seq(end_rad, start_rad, length.out = n_chars)
        } else {
          angles &lt;- seq(start_rad, end_rad, length.out = n_chars)
        }
        
        # Plot each character separately
        chars &lt;- strsplit(text, &quot;&quot;)[[1]]
        for (i in 1:n_chars) {
          char_x &lt;- radius * cos(angles[i])
          char_y &lt;- radius * sin(angles[i])
          
          text(char_x, char_y, chars[i],
               srt = angles[i] * 180 / pi,
               adj = c(0.5, 0.5), ...)
        }
      },
      
      # Add text with arrow pointing to feature
      text_with_arrow = function(x, y, text,
                                point_x, point_y,
                                arrow_length = 0.1,
                                arrow_angle = 30,
                                text_offset = 0.05,
                                ...) {
        
        # Draw arrow from text to point
        arrows(x, y, point_x, point_y,
               length = arrow_length, angle = arrow_angle)
        
        # Draw text
        text(x, y, text, ...)
      },
      
      # Create text gradient (color change along text)
      gradient_text = function(x, y, text,
                              colors = c(&quot;red&quot;, &quot;yellow&quot;, &quot;green&quot;),
                              direction = &quot;horizontal&quot;,
                              ...) {
        
        chars &lt;- strsplit(text, &quot;&quot;)[[1]]
        n_chars &lt;- length(chars)
        
        # Create color gradient
        color_gradient &lt;- colorRampPalette(colors)(n_chars)
        
        # Calculate character positions
        if (direction == &quot;horizontal&quot;) {
          char_width &lt;- strwidth(text, ...) / n_chars
          x_positions &lt;- seq(x - strwidth(text, ...)/2 + char_width/2,
                            x + strwidth(text, ...)/2 - char_width/2,
                            length.out = n_chars)
          y_positions &lt;- rep(y, n_chars)
        } else {
          char_height &lt;- strheight(text, ...) / n_chars
          x_positions &lt;- rep(x, n_chars)
          y_positions &lt;- seq(y - strheight(text, ...)/2 + char_height/2,
                            y + strheight(text, ...)/2 - char_height/2,
                            length.out = n_chars)
        }
        
        # Plot each character with its own color
        for (i in 1:n_chars) {
          text(x_positions[i], y_positions[i], chars[i],
               col = color_gradient[i], ...)
        }
      }
    )
    
    return(formatting)
  }
  
  # 4. Label Positioning System
  label_positioning &lt;- function() {
    positioning &lt;- list(
      
      # Smart label placement to avoid overlaps
      smart_labels = function(x, y, labels,
                             cex = 1,
                             avoid_points = TRUE,
                             avoid_edges = TRUE,
                             margin = 0.05,
                             max_iter = 100) {
        
        n &lt;- length(x)
        usr &lt;- par(&quot;usr&quot;)
        
        # Calculate initial label positions
        label_x &lt;- x
        label_y &lt;- y
        
        # Calculate label dimensions
        label_widths &lt;- strwidth(labels, cex = cex)
        label_heights &lt;- strheight(labels, cex = cex)
        
        # Adjust positions to avoid overlaps
        if (avoid_points) {
          for (i in 1:n) {
            # Check for overlaps with other labels
            for (j in 1:n) {
              if (i != j) {
                dx &lt;- abs(label_x[i] - label_x[j])
                dy &lt;- abs(label_y[i] - label_y[j])
                
                if (dx &lt; (label_widths[i] + label_widths[j])/2 &amp;&amp;
                    dy &lt; (label_heights[i] + label_heights[j])/2) {
                  # Move label to avoid overlap
                  angle &lt;- atan2(label_y[i] - y[i], label_x[i] - x[i])
                  label_x[i] &lt;- x[i] + cos(angle) * label_widths[i]
                  label_y[i] &lt;- y[i] + sin(angle) * label_heights[i]
                }
              }
            }
          }
        }
        
        # Adjust positions to stay within plot area
        if (avoid_edges) {
          x_margin &lt;- diff(usr[1:2]) * margin
          y_margin &lt;- diff(usr[3:4]) * margin
          
          label_x &lt;- pmax(usr[1] + x_margin + label_widths/2,
                         pmin(usr[2] - x_margin - label_widths/2, label_x))
          label_y &lt;- pmax(usr[3] + y_margin + label_heights/2,
                         pmin(usr[4] - y_margin - label_heights/2, label_y))
        }
        
        # Draw labels
        text(label_x, label_y, labels, cex = cex)
        
        # Draw connecting lines if labels moved
        if (any(label_x != x | label_y != y)) {
          segments(x, y, label_x, label_y, col = &quot;gray&quot;, lty = 2)
        }
        
        return(data.frame(x = label_x, y = label_y))
      },
      
      # Place labels along a curve
      labels_along_curve = function(fun, from, to, labels,
                                   n = length(labels),
                                   offset = 0.1,
                                   ...) {
        
        # Calculate curve points
        x_vals &lt;- seq(from, to, length.out = n * 10)
        y_vals &lt;- fun(x_vals)
        
        # Sample points for labels
        label_indices &lt;- seq(1, length(x_vals), length.out = n + 2)[2:(n + 1)]
        label_x &lt;- x_vals[label_indices]
        label_y &lt;- y_vals[label_indices]
        
        # Calculate normals for offset
        for (i in 1:n) {
          # Estimate derivative (slope)
          idx &lt;- label_indices[i]
          if (idx &gt; 1 &amp;&amp; idx &lt; length(x_vals)) {
            dy &lt;- y_vals[idx + 1] - y_vals[idx - 1]
            dx &lt;- x_vals[idx + 1] - x_vals[idx - 1]
            slope &lt;- dy / dx
            
            # Calculate normal angle
            normal_angle &lt;- atan2(-dx, dy)
            
            # Apply offset
            label_x[i] &lt;- label_x[i] + offset * cos(normal_angle)
            label_y[i] &lt;- label_y[i] + offset * sin(normal_angle)
          }
        }
        
        # Draw labels
        text(label_x, label_y, labels, ...)
        
        return(data.frame(x = label_x, y = label_y))
      },
      
      # Interactive label placement
      interactive_labels = function(x, y, labels, ...) {
        cat(&quot;Interactive Label Placement\n&quot;)
        cat(&quot;Click to place each label, or press ESC to skip.\n\n&quot;)
        
        n &lt;- length(x)
        placed_labels &lt;- list()
        
        plot(x, y, pch = 19, ...)
        
        for (i in 1:n) {
          cat(&quot;Place label for point&quot;, i, &quot;:&quot;, labels[i], &quot;\n&quot;)
          coords &lt;- locator(1)
          
          if (!is.null(coords)) {
            text(coords$x, coords$y, labels[i])
            segments(x[i], y[i], coords$x, coords$y, col = &quot;gray&quot;, lty = 2)
            placed_labels[[i]] &lt;- list(
              point = c(x[i], y[i]),
              label_pos = c(coords$x, coords$y),
              text = labels[i]
            )
          } else {
            cat(&quot;Skipped label&quot;, i, &quot;\n&quot;)
          }
        }
        
        return(placed_labels)
      }
    )
    
    return(positioning)
  }
  
  # 5. Complete Demonstration
  demonstrate_text_notation &lt;- function() {
    cat(&quot;ADVANCED TEXT AND NOTATION DEMONSTRATION\n&quot;)
    cat(&quot;=========================================\n\n&quot;)
    
    # Get the systems
    math_expr &lt;- mathematical_expressions()
    unicode &lt;- unicode_characters()
    formatting &lt;- text_formatting()
    positioning &lt;- label_positioning()
    
    # Create demonstration plot
    old_par &lt;- par(no.readonly = TRUE)
    layout(matrix(1:4, nrow = 2, byrow = TRUE))
    
    # Plot 1: Mathematical Expressions
    par(mar = c(5, 4, 4, 2) + 0.1)
    plot(0, 0, type = &quot;n&quot;, xlim = c(0, 10), ylim = c(0, 10),
         main = &quot;Mathematical Expressions&quot;, axes = FALSE,
         xlab = &quot;&quot;, ylab = &quot;&quot;)
    
    # Display various expressions
    expressions &lt;- list(
      math_expr$statistics$regression,
      math_expr$fractions(&quot;a + b&quot;, &quot;c - d&quot;),
      math_expr$superscript(&quot;x&quot;, &quot;2&quot;),
      math_expr$subscript(&quot;X&quot;, &quot;i&quot;),
      math_expr$both_scripts(&quot;X&quot;, &quot;n&quot;, &quot;i&quot;),
      math_expr$sqrt_expr(&quot;x + y&quot;),
      math_expr$log_expr(&quot;x&quot;, 10),
      math_expr$scientific$energy
    )
    
    y_pos &lt;- seq(9, 1, length.out = length(expressions))
    for (i in 1:length(expressions)) {
      text(1, y_pos[i], expressions[[i]], cex = 1.5, adj = 0)
    }
    
    # Plot 2: Unicode and Special Characters
    par(mar = c(5, 4, 4, 2) + 0.1)
    plot(0, 0, type = &quot;n&quot;, xlim = c(0, 10), ylim = c(0, 10),
         main = &quot;Unicode Characters&quot;, axes = FALSE,
         xlab = &quot;&quot;, ylab = &quot;&quot;)
    
    # Display Unicode characters
    unicode_examples &lt;- list(
      &quot;Greek: α β γ δ ε&quot;,
      &quot;Math: ± × ÷ ≠ ≤ ≥ ≈ ∞&quot;,
      &quot;Arrows: ← → ↑ ↓ ↔ ↕&quot;,
      &quot;Currency: $ € £ ¥ ₹&quot;,
      &quot;Symbols: ★ ☆ ☁ ❄ ♥&quot;,
      &quot;Marks: ✓ ✗ ☑ ☐&quot;
    )
    
    # Convert to expressions with Unicode
    unicode_text &lt;- sapply(unicode_examples, function(x) {
      # Replace Unicode codes with actual characters
      x &lt;- gsub(&quot;alpha&quot;, unicode$greek$alpha, x)
      x &lt;- gsub(&quot;beta&quot;, unicode$greek$beta, x)
      x &lt;- gsub(&quot;gamma&quot;, unicode$greek$gamma, x)
      x &lt;- gsub(&quot;delta&quot;, unicode$greek$delta, x)
      x &lt;- gsub(&quot;epsilon&quot;, unicode$greek$epsilon, x)
      return(x)
    })
    
    y_pos &lt;- seq(9, 1, length.out = length(unicode_text))
    for (i in 1:length(unicode_text)) {
      text(1, y_pos[i], unicode_text[i], cex = 1.5, adj = 0)
    }
    
    # Plot 3: Text Formatting
    par(mar = c(5, 4, 4, 2) + 0.1)
    plot(0, 0, type = &quot;n&quot;, xlim = c(0, 10), ylim = c(0, 10),
         main = &quot;Text Formatting&quot;, axes = FALSE,
         xlab = &quot;&quot;, ylab = &quot;&quot;)
    
    # Text with boxes
    formatting$text_with_box(3, 8, &quot;Text with Box&quot;,
                            cex = 1.5, col = &quot;darkblue&quot;,
                            bg = &quot;lightblue&quot;, border = &quot;blue&quot;)
    
    # Gradient text
    formatting$gradient_text(3, 6, &quot;Gradient Text&quot;,
                            colors = c(&quot;red&quot;, &quot;yellow&quot;, &quot;green&quot;),
                            cex = 2, font = 2)
    
    # Text with arrow
    formatting$text_with_arrow(7, 8, &quot;Important Point&quot;,
                              point_x = 5, point_y = 4,
                              cex = 1.2, col = &quot;darkred&quot;)
    
    # Curved text
    angles &lt;- seq(0, 180, length.out = 10)
    for (angle in angles) {
      formatting$curved_text(5, 2, &quot;CURVED&quot;,
                            radius = 2,
                            start_angle = angle,
                            end_angle = angle + 180,
                            cex = 0.8,
                            col = rainbow(length(angles))[which(angles == angle)])
    }
    
    # Plot 4: Smart Label Positioning
    par(mar = c(5, 4, 4, 2) + 0.1)
    
    # Create data with potential label overlaps
    set.seed(123)
    n &lt;- 20
    x &lt;- runif(n, 0, 10)
    y &lt;- runif(n, 0, 10)
    labels &lt;- paste0(&quot;P&quot;, 1:n)
    
    # Some overlapping points
    x[5:7] &lt;- c(5, 5.1, 4.9)
    y[5:7] &lt;- c(5, 5.1, 4.9)
    
    plot(x, y, pch = 19, col = &quot;blue&quot;, cex = 1.5,
         main = &quot;Smart Label Positioning&quot;,
         xlim = c(0, 10), ylim = c(0, 10))
    grid()
    
    # Use smart label positioning
    label_positions &lt;- positioning$smart_labels(x, y, labels,
                                               cex = 0.8,
                                               avoid_points = TRUE,
                                               avoid_edges = TRUE)
    
    # Compare with direct labeling (would overlap)
    text(x, y + 0.3, labels, cex = 0.6, col = &quot;gray&quot;)
    
    # Legend
    legend(&quot;bottomright&quot;,
           legend = c(&quot;Data Points&quot;, &quot;Smart Labels&quot;, &quot;Direct Labels&quot;),
           col = c(&quot;blue&quot;, &quot;black&quot;, &quot;gray&quot;),
           pch = c(19, NA, NA),
           lty = c(NA, 2, NA),
           bg = &quot;white&quot;)
    
    # Additional: Interactive demonstration
    cat(&quot;\n\nInteractive Label Placement Demonstration\n&quot;)
    cat(&quot;-----------------------------------------\n&quot;)
    
    dev.new()  # Open new window
    
    # Create simple plot for interaction
    plot(1:5, 1:5, pch = 19, cex = 2, col = &quot;red&quot;,
         main = &quot;Interactive Label Placement\nClick to place labels&quot;,
         xlim = c(0, 6), ylim = c(0, 6))
    
    labels &lt;- c(&quot;First&quot;, &quot;Second&quot;, &quot;Third&quot;, &quot;Fourth&quot;, &quot;Fifth&quot;)
    
    # Use interactive labeling
    placed &lt;- positioning$interactive_labels(1:5, 1:5, labels,
                                            main = &quot;&quot;,
                                            xlim = c(0, 6), ylim = c(0, 6))
    
    cat(&quot;\nLabel placement complete.\n&quot;)
    cat(&quot;Number of labels placed:&quot;, length(placed), &quot;\n&quot;)
    
    # Reset parameters
    par(old_par)
    
    cat(&quot;\nDemonstration complete.\n&quot;)
    
    # Return the systems for further use
    return(list(
      mathematical = math_expr,
      unicode = unicode,
      formatting = formatting,
      positioning = positioning
    ))
  }
  
  # 6. Return complete text notation system
  return(list(
    mathematical_expressions = mathematical_expressions(),
    unicode_characters = unicode_characters(),
    text_formatting = text_formatting(),
    label_positioning = label_positioning(),
    demonstration = demonstrate_text_notation
  ))
}

# Create advanced text notation system
text_notation_system &lt;- advanced_text_notation()

# Run demonstration
text_demo &lt;- text_notation_system$demonstration()</code></pre>
            </div>
            

            <div class="special-block reference">
                <div class="special-label">Reference: Davies (2016) Chapter 20; Pawgi (2022) Chapter 15</div>
                <div class="special-content"></div>
            </div>
            
<hr class="content-hr">
</section>

            <section class="content-section" id="5-defining-colors-and-plotting-in-higher-dimensions">
                <h2 class="section-heading"><strong>5. Defining Colors and Plotting in Higher Dimensions</strong></h2>
            
</section>

            <section class="content-section" id="a-comprehensive-color-system">
                <h3 class="section-heading"><strong>A. Comprehensive Color System</strong></h3>
            

            <div class="code-block">
                <pre><code class="language-r"># Advanced Color Management System
advanced_color_system &lt;- function() {
  
  # 1. Color Spaces and Conversions
  color_spaces &lt;- function() {
    spaces &lt;- list(
      
      # RGB to other color spaces
      rgb_to_hsv = function(r, g, b) {
        # Normalize to [0, 1]
        r &lt;- r / 255
        g &lt;- g / 255
        b &lt;- b / 255
        
        cmax &lt;- pmax(r, g, b)
        cmin &lt;- pmin(r, g, b)
        delta &lt;- cmax - cmin
        
        # Calculate Hue
        h &lt;- numeric(length(r))
        h[delta == 0] &lt;- 0
        h[cmax == r] &lt;- (60 * ((g[cmax == r] - b[cmax == r]) / delta[cmax == r]) + 360) %% 360
        h[cmax == g] &lt;- (60 * ((b[cmax == g] - r[cmax == g]) / delta[cmax == g]) + 120) %% 360
        h[cmax == b] &lt;- (60 * ((r[cmax == b] - g[cmax == b]) / delta[cmax == b]) + 240) %% 360
        
        # Calculate Saturation
        s &lt;- ifelse(cmax == 0, 0, delta / cmax)
        
        # Value (Brightness)
        v &lt;- cmax
        
        return(data.frame(h = h, s = s, v = v))
      },
      
      hsv_to_rgb = function(h, s, v) {
        h &lt;- h %% 360
        c &lt;- v * s
        x &lt;- c * (1 - abs((h / 60) %% 2 - 1))
        m &lt;- v - c
        
        r1 &lt;- g1 &lt;- b1 &lt;- numeric(length(h))
        
        # 0-60 degrees
        idx &lt;- h &lt; 60
        r1[idx] &lt;- c[idx]
        g1[idx] &lt;- x[idx]
        b1[idx] &lt;- 0
        
        # 60-120 degrees
        idx &lt;- h &gt;= 60 &amp; h &lt; 120
        r1[idx] &lt;- x[idx]
        g1[idx] &lt;- c[idx]
        b1[idx] &lt;- 0
        
        # 120-180 degrees
        idx &lt;- h &gt;= 120 &amp; h &lt; 180
        r1[idx] &lt;- 0
        g1[idx] &lt;- c[idx]
        b1[idx] &lt;- x[idx]
        
        # 180-240 degrees
        idx &lt;- h &gt;= 180 &amp; h &lt; 240
        r1[idx] &lt;- 0
        g1[idx] &lt;- x[idx]
        b1[idx] &lt;- c[idx]
        
        # 240-300 degrees
        idx &lt;- h &gt;= 240 &amp; h &lt; 300
        r1[idx] &lt;- x[idx]
        g1[idx] &lt;- 0
        b1[idx] &lt;- c[idx]
        
        # 300-360 degrees
        idx &lt;- h &gt;= 300
        r1[idx] &lt;- c[idx]
        g1[idx] &lt;- 0
        b1[idx] &lt;- x[idx]
        
        r &lt;- (r1 + m) * 255
        g &lt;- (g1 + m) * 255
        b &lt;- (b1 + m) * 255
        
        return(data.frame(r = round(r), g = round(g), b = round(b)))
      },
      
      # RGB to HSL
      rgb_to_hsl = function(r, g, b) {
        r &lt;- r / 255
        g &lt;- g / 255
        b &lt;- b / 255
        
        cmax &lt;- pmax(r, g, b)
        cmin &lt;- pmin(r, g, b)
        delta &lt;- cmax - cmin
        
        # Calculate Lightness
        l &lt;- (cmax + cmin) / 2
        
        # Calculate Saturation
        s &lt;- numeric(length(r))
        s[delta == 0] &lt;- 0
        s[delta != 0] &lt;- delta[delta != 0] / (1 - abs(2 * l[delta != 0] - 1))
        
        # Calculate Hue
        h &lt;- numeric(length(r))
        h[delta == 0] &lt;- 0
        h[cmax == r] &lt;- (60 * ((g[cmax == r] - b[cmax == r]) / delta[cmax == r]) + 360) %% 360
        h[cmax == g] &lt;- (60 * ((b[cmax == g] - r[cmax == g]) / delta[cmax == g]) + 120) %% 360
        h[cmax == b] &lt;- (60 * ((r[cmax == b] - g[cmax == b]) / delta[cmax == b]) + 240) %% 360
        
        return(data.frame(h = h, s = s, l = l))
      },
      
      # Color temperature (approximate)
      rgb_to_temperature = function(r, g, b) {
        # Convert to XYZ color space first (simplified)
        x &lt;- 0.4124564 * r + 0.3575761 * g + 0.1804375 * b
        y &lt;- 0.2126729 * r + 0.7151522 * g + 0.0721750 * b
        z &lt;- 0.0193339 * r + 0.1191920 * g + 0.9503041 * b
        
        # Convert to chromaticity
        x_chrom &lt;- x / (x + y + z)
        y_chrom &lt;- y / (x + y + z)
        
        # Approximate temperature using McCamy&#x27;s formula
        n &lt;- (x_chrom - 0.3320) / (0.1858 - y_chrom)
        temp &lt;- 449 * n^3 + 3525 * n^2 + 6823.3 * n + 5520.33
        
        return(temp)
      }
    )
    
    return(spaces)
  }
  
  # 2. Color Palettes and Schemes
  color_palettes &lt;- function() {
    palettes &lt;- list(
      
      # Sequential palettes (for ordered data)
      sequential = list(
        blues = colorRampPalette(c(&quot;#F7FBFF&quot;, &quot;#DEEBF7&quot;, &quot;#C6DBEF&quot;, 
                                  &quot;#9ECAE1&quot;, &quot;#6BAED6&quot;, &quot;#4292C6&quot;,
                                  &quot;#2171B5&quot;, &quot;#08519C&quot;, &quot;#08306B&quot;)),
        greens = colorRampPalette(c(&quot;#F7FCF5&quot;, &quot;#E5F5E0&quot;, &quot;#C7E9C0&quot;,
                                   &quot;#A1D99B&quot;, &quot;#74C476&quot;, &quot;#41AB5D&quot;,
                                   &quot;#238B45&quot;, &quot;#006D2C&quot;, &quot;#00441B&quot;)),
        grays = colorRampPalette(c(&quot;#FFFFFF&quot;, &quot;#F0F0F0&quot;, &quot;#D9D9D9&quot;,
                                  &quot;#BDBDBD&quot;, &quot;#969696&quot;, &quot;#737373&quot;,
                                  &quot;#525252&quot;, &quot;#252525&quot;, &quot;#000000&quot;))
      ),
      
      # Diverging palettes (for data with midpoint)
      diverging = list(
        red_blue = colorRampPalette(c(&quot;#67001F&quot;, &quot;#B2182B&quot;, &quot;#D6604D&quot;,
                                     &quot;#F4A582&quot;, &quot;#FDDBC7&quot;, &quot;#F7F7F7&quot;,
                                     &quot;#D1E5F0&quot;, &quot;#92C5DE&quot;, &quot;#4393C3&quot;,
                                     &quot;#2166AC&quot;, &quot;#053061&quot;)),
        purple_green = colorRampPalette(c(&quot;#762A83&quot;, &quot;#9970AB&quot;, &quot;#C2A5CF&quot;,
                                         &quot;#E7D4E8&quot;, &quot;#F7F7F7&quot;, &quot;#D9F0D3&quot;,
                                         &quot;#ACD39E&quot;, &quot;#5AAE61&quot;, &quot;#1B7837&quot;)),
        brown_bluegreen = colorRampPalette(c(&quot;#8C510A&quot;, &quot;#BF812D&quot;, &quot;#DFC27D&quot;,
                                            &quot;#F6E8C3&quot;, &quot;#F5F5F5&quot;, &quot;#C7EAE5&quot;,
                                            &quot;#80CDC1&quot;, &quot;#35978F&quot;, &quot;#01665E&quot;))
      ),
      
      # Qualitative palettes (for categorical data)
      qualitative = list(
        set1 = c(&quot;#E41A1C&quot;, &quot;#377EB8&quot;, &quot;#4DAF4A&quot;, &quot;#984EA3&quot;,
                &quot;#FF7F00&quot;, &quot;#FFFF33&quot;, &quot;#A65628&quot;, &quot;#F781BF&quot;),
        set2 = c(&quot;#66C2A5&quot;, &quot;#FC8D62&quot;, &quot;#8DA0CB&quot;, &quot;#E78AC3&quot;,
                &quot;#A6D854&quot;, &quot;#FFD92F&quot;, &quot;#E5C494&quot;, &quot;#B3B3B3&quot;),
        set3 = c(&quot;#8DD3C7&quot;, &quot;#FFFFB3&quot;, &quot;#BEBADA&quot;, &quot;#FB8072&quot;,
                &quot;#80B1D3&quot;, &quot;#FDB462&quot;, &quot;#B3DE69&quot;, &quot;#FCCDE5&quot;)
      ),
      
      # Scientific palettes
      scientific = list(
        viridis = viridis::viridis,
        plasma = viridis::plasma,
        inferno = viridis::inferno,
        magma = viridis::magma,
        cividis = viridis::cividis
      ),
      
      # Custom palette generators
      generators = list(
        # Generate palette from colors
        from_colors = function(colors, n = 10) {
          colorRampPalette(colors)(n)
        },
        
        # Generate complementary colors
        complementary = function(color, n = 2) {
          rgb &lt;- col2rgb(color)
          hsv &lt;- rgb2hsv(rgb)
          hsv[1, ] &lt;- (hsv[1, ] + 0.5) %% 1
          hsv(1, hsv[2, ], hsv[3, ])
        },
        
        # Generate analogous colors
        analogous = function(color, n = 5, spread = 0.1) {
          rgb &lt;- col2rgb(color)
          hsv &lt;- rgb2hsv(rgb)
          hues &lt;- seq(hsv[1, 1] - spread * (n-1)/2,
                     hsv[1, 1] + spread * (n-1)/2,
                     length.out = n) %% 1
          sapply(hues, function(h) hsv(h, hsv[2, 1], hsv[3, 1]))
        },
        
        # Generate triadic colors
        triadic = function(color) {
          rgb &lt;- col2rgb(color)
          hsv &lt;- rgb2hsv(rgb)
          hues &lt;- (hsv[1, 1] + c(0, 1/3, 2/3)) %% 1
          sapply(hues, function(h) hsv(h, hsv[2, 1], hsv[3, 1]))
        },
        
        # Generate tetradic colors
        tetradic = function(color) {
          rgb &lt;- col2rgb(color)
          hsv &lt;- rgb2hsv(rgb)
          hues &lt;- (hsv[1, 1] + c(0, 0.25, 0.5, 0.75)) %% 1
          sapply(hues, function(h) hsv(h, hsv[2, 1], hsv[3, 1]))
        },
        
        # Generate monochromatic scheme
        monochromatic = function(color, n = 5) {
          rgb &lt;- col2rgb(color)
          hsv &lt;- rgb2hsv(rgb)
          values &lt;- seq(0.2, 1, length.out = n)
          sapply(values, function(v) hsv(hsv[1, 1], hsv[2, 1], v))
        }
      )
    )
    
    return(palettes)
  }
  
  # 3. Color Blindness Simulation
  color_blindness &lt;- function() {
    simulations &lt;- list(
      
      # Deuteranopia (red-green blindness)
      deuteranopia = function(colors) {
        # Conversion matrix for deuteranopia
        conv_matrix &lt;- matrix(c(0.625, 0.375, 0,
                               0.7, 0.3, 0,
                               0, 0.3, 0.7), nrow = 3, byrow = TRUE)
        apply_color_matrix(colors, conv_matrix)
      },
      
      # Protanopia (red-blindness)
      protanopia = function(colors) {
        conv_matrix &lt;- matrix(c(0.567, 0.433, 0,
                               0.558, 0.442, 0,
                               0, 0.242, 0.758), nrow = 3, byrow = TRUE)
        apply_color_matrix(colors, conv_matrix)
      },
      
      # Tritanopia (blue-yellow blindness)
      tritanopia = function(colors) {
        conv_matrix &lt;- matrix(c(0.95, 0.05, 0,
                               0, 0.433, 0.567,
                               0, 0.475, 0.525), nrow = 3, byrow = TRUE)
        apply_color_matrix(colors, conv_matrix)
      },
      
      # Achromatopsia (complete color blindness)
      achromatopsia = function(colors) {
        # Convert to grayscale
        rgb_vals &lt;- col2rgb(colors)
        gray_vals &lt;- 0.299 * rgb_vals[1, ] + 
                    0.587 * rgb_vals[2, ] + 
                    0.114 * rgb_vals[3, ]
        rgb(gray_vals, gray_vals, gray_vals, maxColorValue = 255)
      },
      
      # Helper function to apply color matrix
      apply_color_matrix = function(colors, matrix) {
        rgb_vals &lt;- col2rgb(colors)
        converted &lt;- matrix %*% rgb_vals
        rgb(converted[1, ], converted[2, ], converted[3, ], maxColorValue = 255)
      },
      
      # Test palette for color blindness
      test_palette = function(palette, n = 8) {
        colors &lt;- palette(n)
        
        # Original palette
        plot(1:n, rep(1, n), pch = 15, cex = 10, col = colors,
             xlim = c(0.5, n + 0.5), ylim = c(0, 5),
             axes = FALSE, xlab = &quot;&quot;, ylab = &quot;&quot;,
             main = &quot;Color Blindness Simulation&quot;)
        
        # Deuteranopia
        points(1:n, rep(2, n), pch = 15, cex = 10, 
               col = deuteranopia(colors))
        
        # Protanopia
        points(1:n, rep(3, n), pch = 15, cex = 10,
               col = protanopia(colors))
        
        # Tritanopia
        points(1:n, rep(4, n), pch = 15, cex = 10,
               col = tritanopia(colors))
        
        # Achromatopsia
        points(1:n, rep(5, n), pch = 15, cex = 10,
               col = achromatopsia(colors))
        
        # Labels
        text(mean(1:n), 5.2, &quot;Achromatopsia&quot;, font = 2)
        text(mean(1:n), 4.2, &quot;Tritanopia&quot;, font = 2)
        text(mean(1:n), 3.2, &quot;Protanopia&quot;, font = 2)
        text(mean(1:n), 2.2, &quot;Deuteranopia&quot;, font = 2)
        text(mean(1:n), 1.2, &quot;Original&quot;, font = 2)
        
        # Return simulated colors
        return(list(
          original = colors,
          deuteranopia = deuteranopia(colors),
          protanopia = protanopia(colors),
          tritanopia = tritanopia(colors),
          achromatopsia = achromatopsia(colors)
        ))
      }
    )
    
    return(simulations)
  }
  
  # 4. Color in Statistical Graphics
  statistical_color &lt;- function() {
    color_applications &lt;- list(
      
      # Color mapping for continuous variables
      continuous_mapping = function(values, palette = viridis::viridis, 
                                   na.color = &quot;gray&quot;) {
        # Normalize values to [0, 1]
        if (all(is.na(values))) {
          return(rep(na.color, length(values)))
        }
        
        vals_norm &lt;- (values - min(values, na.rm = TRUE)) / 
          (max(values, na.rm = TRUE) - min(values, na.rm = TRUE))
        
        # Get colors from palette
        colors &lt;- palette(256)[round(vals_norm * 255) + 1]
        
        # Handle NA values
        colors[is.na(values)] &lt;- na.color
        
        return(colors)
      },
      
      # Color mapping for categorical variables
      categorical_mapping = function(factors, palette = NULL) {
        if (!is.factor(factors)) {
          factors &lt;- as.factor(factors)
        }
        
        n_levels &lt;- nlevels(factors)
        
        if (is.null(palette)) {
          # Use colorBrewer Set3 for small numbers, Set1 for larger
          if (n_levels &lt;= 8) {
            colors &lt;- RColorBrewer::brewer.pal(max(3, n_levels), &quot;Set1&quot;)
          } else if (n_levels &lt;= 12) {
            colors &lt;- RColorBrewer::brewer.pal(n_levels, &quot;Set3&quot;)
          } else {
            # Generate colors using hue wheel
            colors &lt;- hcl(h = seq(0, 360, length.out = n_levels + 1)[1:n_levels],
                         c = 60, l = 65)
          }
        } else {
          if (is.function(palette)) {
            colors &lt;- palette(n_levels)
          } else {
            colors &lt;- rep(palette, length.out = n_levels)
          }
        }
        
        names(colors) &lt;- levels(factors)
        return(colors[as.character(factors)])
      },
      
      # Heatmap color scaling
      heatmap_colors = function(matrix, 
                               col = colorRampPalette(c(&quot;blue&quot;, &quot;white&quot;, &quot;red&quot;))(256),
                               symmetric = FALSE,
                               na.color = &quot;gray&quot;) {
        
        if (symmetric) {
          max_abs &lt;- max(abs(matrix), na.rm = TRUE)
          breaks &lt;- seq(-max_abs, max_abs, length.out = length(col) + 1)
        } else {
          breaks &lt;- seq(min(matrix, na.rm = TRUE), 
                       max(matrix, na.rm = TRUE), 
                       length.out = length(col) + 1)
        }
        
        # Create color index
        color_index &lt;- findInterval(matrix, breaks)
        colors &lt;- col[color_index]
        colors[is.na(color_index)] &lt;- na.color
        
        return(list(colors = matrix(colors, nrow = nrow(matrix)),
                   breaks = breaks,
                   col = col))
      },
      
      # Color for statistical significance
      significance_colors = function(p_values, 
                                    alpha = 0.05,
                                    sig_color = &quot;red&quot;,
                                    ns_color = &quot;gray&quot;) {
        
        ifelse(p_values &lt; alpha, sig_color, ns_color)
      },
      
      # Color for correlation matrix
      correlation_colors = function(cor_matrix,
                                   col = colorRampPalette(c(&quot;blue&quot;, &quot;white&quot;, &quot;red&quot;))(256)) {
        
        # Ensure values are in [-1, 1]
        cor_matrix &lt;- pmin(pmax(cor_matrix, -1), 1)
        
        # Map to colors
        color_index &lt;- round((cor_matrix + 1) * (length(col) - 1) / 2) + 1
        colors &lt;- col[color_index]
        
        return(matrix(colors, nrow = nrow(cor_matrix)))
      }
    )
    
    return(color_applications)
  }
  
  # 5. 3D Scatter Plots and Higher Dimensions
  three_d_plots &lt;- function() {
    plot_3d &lt;- list(
      
      # Basic 3D scatter plot
      scatter3d = function(x, y, z,
                          col = &quot;blue&quot;,
                          size = 1,
                          alpha = 1,
                          add = FALSE,
                          xlab = &quot;X&quot;,
                          ylab = &quot;Y&quot;,
                          zlab = &quot;Z&quot;,
                          main = &quot;3D Scatter Plot&quot;) {
        
        if (!add) {
          # Create empty 3D plot
          plot3d(x, y, z, type = &quot;n&quot;,
                 xlab = xlab, ylab = ylab, zlab = zlab,
                 main = main)
        }
        
        # Add points
        points3d(x, y, z, col = col, size = size, alpha = alpha)
        
        # Add grid
        grid3d(c(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;))
        
        # Add bounding box
        box3d()
      },
      
      # 3D scatter with color mapping
      scatter3d_color = function(x, y, z, color_var,
                                palette = viridis::viridis,
                                size = 3,
                                main = &quot;3D Scatter with Color Mapping&quot;) {
        
        # Map colors to variable
        colors &lt;- continuous_mapping(color_var, palette)
        
        # Create plot
        scatter3d(x = x, y = y, z = z,
                  col = colors,
                  size = size,
                  main = main)
        
        # Add color legend
        legend3d(&quot;topright&quot;,
                legend = c(&quot;Low&quot;, &quot;Medium&quot;, &quot;High&quot;),
                col = palette(3),
                pch = 16,
                cex = 1,
                inset = 0.05)
      },
      
      # 3D surface plot
      surface3d = function(x, y, z,
                          col = terrain.colors(256),
                          alpha = 1,
                          main = &quot;3D Surface Plot&quot;) {
        
        # Create color mapping
        z_range &lt;- range(z, na.rm = TRUE)
        color_index &lt;- round((z - z_range[1]) / 
                            (z_range[2] - z_range[1]) * (length(col) - 1)) + 1
        
        # Create surface
        surface3d(x, y, z,
                  col = col[color_index],
                  alpha = alpha,
                  main = main)
        
        # Add color bar
        bgplot3d({
          plot.new()
          par(mar = c(5, 4, 4, 5))
          image.plot(zlim = z_range,
                     col = col,
                     legend.only = TRUE,
                     horizontal = FALSE,
                     legend.width = 0.8,
                     legend.mar = 4)
        })
      },
      
      # 3D contour plot
      contour3d = function(x, y, z,
                          nlevels = 10,
                          col = heat.colors(nlevels),
                          alpha = 0.7,
                          main = &quot;3D Contour Plot&quot;) {
        
        # Create contours
        contour_levels &lt;- pretty(range(z, na.rm = TRUE), nlevels)
        
        for (i in 1:length(contour_levels)) {
          level &lt;- contour_levels[i]
          # Extract contour lines (simplified)
          # In practice, use contourLines() function
          cl &lt;- contourLines(x, y, z, levels = level)
          
          for (contour in cl) {
            lines3d(contour$x, contour$y, rep(level, length(contour$x)),
                    col = col[i], lwd = 2, alpha = alpha)
          }
        }
        
        title3d(main)
      },
      
      # 3D density plot
      density3d = function(x, y, z,
                          n = 50,
                          col = heat.colors(256),
                          alpha = 0.7,
                          main = &quot;3D Density Plot&quot;) {
        
        # Create kernel density estimate
        dens &lt;- kde3d(x, y, z, n = n)
        
        # Create isosurfaces
        threshold &lt;- quantile(dens$d, probs = c(0.5, 0.75, 0.9))
        
        for (i in 1:length(threshold)) {
          # Create isosurface
          # This would use contour3d() from misc3d package
          # Simplified version:
          cat(&quot;Isosurface at density:&quot;, threshold[i], &quot;\n&quot;)
        }
        
        # Add points
        points3d(x, y, z, size = 1, alpha = 0.3)
        
        title3d(main)
      },
      
      # Interactive 3D plot
      interactive_3d = function(x, y, z, ...) {
        plot3d(x, y, z, ...)
        
        cat(&quot;\nInteractive 3D Plot Controls:\n&quot;)
        cat(&quot;  Left drag: Rotate\n&quot;)
        cat(&quot;  Right drag: Zoom\n&quot;)
        cat(&quot;  Middle drag: Pan\n&quot;)
        cat(&quot;  Wheel: Zoom in/out\n&quot;)
        cat(&quot;  Press ESC to exit interactive mode\n&quot;)
        
        # Keep plot open
        rgl::play3d(rgl::spin3d(axis = c(0, 0, 1), rpm = 5), duration = 10)
      }
    )
    
    return(plot_3d)
  }
  
  # 6. Higher Dimensional Visualization
  higher_dimensions &lt;- function() {
    techniques &lt;- list(
      
      # Parallel coordinates plot
      parallel_coordinates = function(data,
                                     col = NULL,
                                     alpha = 0.5,
                                     lwd = 1,
                                     main = &quot;Parallel Coordinates Plot&quot;) {
        
        n &lt;- nrow(data)
        p &lt;- ncol(data)
        
        # Normalize data
        data_norm &lt;- apply(data, 2, function(x) {
          (x - min(x)) / (max(x) - min(x))
        })
        
        # Set up plot
        plot(0, 0, type = &quot;n&quot;,
             xlim = c(1, p), ylim = c(0, 1),
             xaxt = &quot;n&quot;, xlab = &quot;&quot;, ylab = &quot;Normalized Value&quot;,
             main = main)
        
        # Add axes
        axis(1, at = 1:p, labels = colnames(data))
        
        # Add grid
        abline(h = seq(0, 1, by = 0.2), col = &quot;gray90&quot;, lty = 3)
        abline(v = 1:p, col = &quot;gray90&quot;, lty = 3)
        
        # Plot lines
        if (is.null(col)) {
          col &lt;- rainbow(n, alpha = alpha)
        }
        
        for (i in 1:n) {
          lines(1:p, data_norm[i, ], 
                col = col[i], lwd = lwd)
        }
        
        # Add legend if colors represent groups
        if (!is.null(names(col))) {
          legend(&quot;topright&quot;,
                 legend = names(col),
                 col = unique(col),
                 lwd = 2,
                 bg = &quot;white&quot;)
        }
      },
      
      # Andrews curves
      andrews_curves = function(data, groups = NULL,
                               n_points = 100,
                               alpha = 0.3,
                               lwd = 1,
                               main = &quot;Andrews Curves&quot;) {
        
        n &lt;- nrow(data)
        p &lt;- ncol(data)
        
        # Create Andrews curves function
        andrews_function &lt;- function(t, x) {
          result &lt;- x[1] / sqrt(2)
          for (j in 2:p) {
            if (j %% 2 == 0) {
              result &lt;- result + x[j] * sin((j/2) * t)
            } else {
              result &lt;- result + x[j] * cos(((j-1)/2) * t)
            }
          }
          return(result)
        }
        
        # Create t values
        t_vals &lt;- seq(-pi, pi, length.out = n_points)
        
        # Set up plot
        plot(0, 0, type = &quot;n&quot;,
             xlim = range(t_vals), ylim = c(-3, 3),
             xlab = &quot;t&quot;, ylab = &quot;f(t)&quot;,
             main = main)
        
        # Add grid
        abline(h = seq(-3, 3, by = 1), col = &quot;gray90&quot;, lty = 3)
        abline(v = seq(-pi, pi, by = pi/2), col = &quot;gray90&quot;, lty = 3)
        
        # Calculate curves
        curves &lt;- matrix(NA, nrow = n, ncol = n_points)
        for (i in 1:n) {
          curves[i, ] &lt;- sapply(t_vals, function(t) andrews_function(t, data[i, ]))
        }
        
        # Plot curves
        if (is.null(groups)) {
          col &lt;- rainbow(n, alpha = alpha)
          for (i in 1:n) {
            lines(t_vals, curves[i, ], col = col[i], lwd = lwd)
          }
        } else {
          group_colors &lt;- rainbow(length(unique(groups)), alpha = alpha)
          names(group_colors) &lt;- unique(groups)
          
          for (i in 1:n) {
            lines(t_vals, curves[i, ], 
                  col = group_colors[groups[i]], 
                  lwd = lwd)
          }
          
          # Add legend
          legend(&quot;topright&quot;,
                 legend = names(group_colors),
                 col = group_colors,
                 lwd = 2,
                 bg = &quot;white&quot;)
        }
      },
      
      # Radar chart (spider plot)
      radar_chart = function(data, 
                            groups = NULL,
                            col = NULL,
                            alpha = 0.3,
                            lwd = 2,
                            main = &quot;Radar Chart&quot;) {
        
        n &lt;- nrow(data)
        p &lt;- ncol(data)
        
        # Normalize data
        data_norm &lt;- apply(data, 2, function(x) {
          (x - min(x)) / (max(x) - min(x))
        })
        
        # Calculate angles
        angles &lt;- seq(0, 2 * pi, length.out = p + 1)[1:p]
        
        # Set up plot
        plot(0, 0, type = &quot;n&quot;,
             xlim = c(-1.2, 1.2), ylim = c(-1.2, 1.2),
             asp = 1, axes = FALSE,
             xlab = &quot;&quot;, ylab = &quot;&quot;, main = main)
        
        # Add radial grid
        for (r in seq(0, 1, by = 0.2)) {
          polygon(r * cos(angles), r * sin(angles),
                  border = &quot;gray90&quot;, lty = 3)
        }
        
        # Add radial lines
        for (i in 1:p) {
          lines(c(0, cos(angles[i])), c(0, sin(angles[i])),
                col = &quot;gray80&quot;, lty = 3)
        }
        
        # Add variable labels
        label_pos &lt;- 1.1
        for (i in 1:p) {
          text(label_pos * cos(angles[i]), 
               label_pos * sin(angles[i]),
               colnames(data)[i])
        }
        
        # Plot data
        if (is.null(groups)) {
          if (is.null(col)) col &lt;- rainbow(n, alpha = alpha)
          for (i in 1:n) {
            polygon(data_norm[i, ] * cos(angles),
                    data_norm[i, ] * sin(angles),
                    border = col[i], col = adjustcolor(col[i], alpha.f = 0.3),
                    lwd = lwd)
          }
        } else {
          group_colors &lt;- rainbow(length(unique(groups)), alpha = alpha)
          names(group_colors) &lt;- unique(groups)
          
          for (i in 1:n) {
            polygon(data_norm[i, ] * cos(angles),
                    data_norm[i, ] * sin(angles),
                    border = group_colors[groups[i]],
                    col = adjustcolor(group_colors[groups[i]], alpha.f = 0.3),
                    lwd = lwd)
          }
          
          # Add legend
          legend(&quot;topright&quot;,
                 legend = names(group_colors),
                 col = group_colors,
                 lwd = 2,
                 bg = &quot;white&quot;)
        }
      },
      
      # PCA biplot
      pca_biplot = function(data, 
                           groups = NULL,
                           col = NULL,
                           alpha = 0.7,
                           main = &quot;PCA Biplot&quot;) {
        
        # Perform PCA
        pca_result &lt;- prcomp(data, scale. = TRUE)
        
        # Scores (observations)
        scores &lt;- pca_result$x[, 1:2]
        
        # Loadings (variables)
        loadings &lt;- pca_result$rotation[, 1:2]
        
        # Set up plot
        plot(0, 0, type = &quot;n&quot;,
             xlim = range(scores[, 1], loadings[, 1] * 3),
             ylim = range(scores[, 2], loadings[, 2] * 3),
             xlab = paste(&quot;PC1 (&quot;, 
                         round(summary(pca_result)$importance[2, 1] * 100, 1),
                         &quot;%)&quot;, sep = &quot;&quot;),
             ylab = paste(&quot;PC2 (&quot;,
                         round(summary(pca_result)$importance[2, 2] * 100, 1),
                         &quot;%)&quot;, sep = &quot;&quot;),
             main = main)
        
        # Add grid
        abline(h = 0, v = 0, col = &quot;gray90&quot;, lty = 3)
        
        # Plot scores
        if (is.null(groups)) {
          if (is.null(col)) col &lt;- rainbow(nrow(scores), alpha = alpha)
          points(scores, pch = 19, col = col, cex = 1.2)
        } else {
          group_colors &lt;- rainbow(length(unique(groups)), alpha = alpha)
          names(group_colors) &lt;- unique(groups)
          
          for (i in 1:nrow(scores)) {
            points(scores[i, 1], scores[i, 2],
                   pch = 19, col = group_colors[groups[i]], cex = 1.2)
          }
          
          # Add legend
          legend(&quot;topright&quot;,
                 legend = names(group_colors),
                 col = group_colors,
                 pch = 19,
                 bg = &quot;white&quot;)
        }
        
        # Plot loadings (variables)
        arrows(0, 0, loadings[, 1] * 3, loadings[, 2] * 3,
               length = 0.1, angle = 20, col = &quot;red&quot;, lwd = 2)
        
        # Add variable labels
        text(loadings[, 1] * 3.2, loadings[, 2] * 3.2,
             rownames(loadings), col = &quot;darkred&quot;, font = 2)
        
        # Add variance explained
        text(min(scores[, 1]), max(scores[, 2]),
             paste(&quot;Total Variance Explained:&quot;,
                   round(sum(summary(pca_result)$importance[2, 1:2]) * 100, 1), &quot;%&quot;),
             pos = 4, col = &quot;darkblue&quot;)
      }
    )
    
    return(techniques)
  }
  
  # 7. Complete Color and 3D Visualization Demonstration
  demonstrate_color_3d &lt;- function() {
    cat(&quot;ADVANCED COLOR AND 3D VISUALIZATION DEMONSTRATION\n&quot;)
    cat(&quot;==================================================\n\n&quot;)
    
    # Get the systems
    spaces &lt;- color_spaces()
    palettes &lt;- color_palettes()
    blindness &lt;- color_blindness()
    stats_color &lt;- statistical_color()
    plots_3d &lt;- three_d_plots()
    higher_dims &lt;- higher_dimensions()
    
    # Create sample data
    set.seed(123)
    
    # 3D data
    n_3d &lt;- 100
    x_3d &lt;- rnorm(n_3d)
    y_3d &lt;- rnorm(n_3d)
    z_3d &lt;- x_3d + y_3d + rnorm(n_3d, sd = 0.5)
    color_var_3d &lt;- sqrt(x_3d^2 + y_3d^2 + z_3d^2)
    
    # High-dimensional data
    n_high &lt;- 50
    p_high &lt;- 8
    data_high &lt;- matrix(rnorm(n_high * p_high), nrow = n_high)
    colnames(data_high) &lt;- paste0(&quot;Var&quot;, 1:p_high)
    groups_high &lt;- sample(c(&quot;Group A&quot;, &quot;Group B&quot;, &quot;Group C&quot;), 
                         n_high, replace = TRUE)
    
    # Setup multi-panel plot
    old_par &lt;- par(no.readonly = TRUE)
    layout(matrix(1:4, nrow = 2, byrow = TRUE))
    
    # Plot 1: Color Space Demonstration
    par(mar = c(5, 4, 4, 2) + 0.1)
    
    # Create RGB color wheel
    angles &lt;- seq(0, 2 * pi, length.out = 360)
    radius &lt;- 1
    
    plot(0, 0, type = &quot;n&quot;, 
         xlim = c(-1.2, 1.2), ylim = c(-1.2, 1.2),
         asp = 1, axes = FALSE,
         xlab = &quot;&quot;, ylab = &quot;&quot;, 
         main = &quot;RGB Color Wheel&quot;)
    
    # Draw color wheel
    for (i in 1:360) {
      # Convert angle to RGB
      angle &lt;- angles[i] * 180 / pi
      hsv_color &lt;- c(angle/360, 1, 1)
      rgb_color &lt;- hsv(hsv_color[1], hsv_color[2], hsv_color[3])
      
      # Draw segment
      polygon(c(0, radius * cos(angles[i]), radius * cos(angles[(i %% 360) + 1]), 0),
              c(0, radius * sin(angles[i]), radius * sin(angles[(i %% 360) + 1]), 0),
              col = rgb_color, border = NA)
    }
    
    # Add center
    points(0, 0, pch = 19, cex = 2, col = &quot;white&quot;)
    
    # Add labels
    text(0, 1.1, &quot;0° (Red)&quot;, col = &quot;white&quot;, font = 2)
    text(1.1, 0, &quot;90° (Green)&quot;, col = &quot;white&quot;, font = 2)
    text(0, -1.1, &quot;180° (Cyan)&quot;, col = &quot;white&quot;, font = 2)
    text(-1.1, 0, &quot;270° (Blue)&quot;, col = &quot;white&quot;, font = 2)
    
    # Plot 2: Color Blindness Simulation
    par(mar = c(5, 4, 4, 2) + 0.1)
    
    # Test a palette
    test_colors &lt;- blindness$test_palette(palettes$qualitative$set1, n = 8)
    
    # Plot 3: Statistical Color Mapping
    par(mar = c(5, 4, 4, 2) + 0.1)
    
    # Create correlation matrix
    cor_matrix &lt;- cor(data_high)
    
    # Create heatmap
    image(1:p_high, 1:p_high, cor_matrix,
          col = stats_color$heatmap_colors(cor_matrix, symmetric = TRUE)$col,
          main = &quot;Correlation Matrix Heatmap&quot;,
          xlab = &quot;&quot;, ylab = &quot;&quot;, axes = FALSE)
    
    axis(1, at = 1:p_high, labels = colnames(data_high), las = 2)
    axis(2, at = 1:p_high, labels = colnames(data_high), las = 2)
    
    # Add correlation values
    for (i in 1:p_high) {
      for (j in 1:p_high) {
        text(i, j, round(cor_matrix[i, j], 2),
             cex = 0.8, col = ifelse(abs(cor_matrix[i, j]) &gt; 0.5, &quot;white&quot;, &quot;black&quot;))
      }
    }
    
    # Add color legend
    colorlegend &lt;- stats_color$heatmap_colors(matrix(seq(-1, 1, length.out = 100)), 
                                             symmetric = TRUE)
    image.plot(zlim = c(-1, 1), col = colorlegend$col,
               legend.only = TRUE, horizontal = FALSE,
               legend.width = 0.8, legend.mar = 3.5,
               smallplot = c(0.85, 0.88, 0.2, 0.8))
    
    # Plot 4: Higher Dimensional Visualization
    par(mar = c(5, 4, 4, 2) + 0.1)
    
    # Parallel coordinates plot
    higher_dims$parallel_coordinates(data_high,
                                    groups = groups_high,
                                    main = &quot;Parallel Coordinates Plot&quot;)
    
    # Reset parameters
    par(old_par)
    
    # 3D Plot Demonstration (separate window)
    cat(&quot;\nCreating 3D scatter plot in new window...\n&quot;)
    
    # Open rgl device for 3D plotting
    if (requireNamespace(&quot;rgl&quot;, quietly = TRUE)) {
      # Create 3D scatter plot with color mapping
      plots_3d$scatter3d_color(x_3d, y_3d, z_3d, color_var_3d,
                              main = &quot;3D Scatter Plot with Color Mapping&quot;)
      
      cat(&quot;\n3D Plot Controls:\n&quot;)
      cat(&quot;  Left drag: Rotate\n&quot;)
      cat(&quot;  Right drag: Zoom\n&quot;)
      cat(&quot;  Middle drag: Pan\n&quot;)
      cat(&quot;  Wheel: Zoom in/out\n\n&quot;)
      
    } else {
      cat(&quot;Install &#x27;rgl&#x27; package for 3D plotting.\n&quot;)
    }
    
    # Additional: High-dimensional visualization
    cat(&quot;\nCreating PCA biplot for high-dimensional data...\n&quot;)
    dev.new()
    
    higher_dims$pca_biplot(data_high, groups = groups_high,
                          main = &quot;PCA Biplot of High-Dimensional Data&quot;)
    
    cat(&quot;\nDemonstration complete.\n&quot;)
    
    # Return the systems for further use
    return(list(
      color_spaces = spaces,
      color_palettes = palettes,
      color_blindness = blindness,
      statistical_color = stats_color,
      three_d_plots = plots_3d,
      higher_dimensions = higher_dims
    ))
  }
  
  # 8. Return complete color and 3D system
  return(list(
    color_spaces = color_spaces(),
    color_palettes = color_palettes(),
    color_blindness = color_blindness(),
    statistical_color = statistical_color(),
    three_d_plots = three_d_plots(),
    higher_dimensions = higher_dimensions(),
    demonstration = demonstrate_color_3d
  ))
}

# Create advanced color and 3D system
color_3d_system &lt;- advanced_color_system()

# Run demonstration
color_3d_demo &lt;- color_3d_system$demonstration()</code></pre>
            </div>
            

            <div class="special-block reference">
                <div class="special-label">Reference: Davies (2016) Chapter 21; Pawgi (2022) Chapter 16</div>
                <div class="special-content"></div>
            </div>
            
<hr class="content-hr">
</section>

            <section class="content-section" id="6-complete-unit-4-integration-example">
                <h2 class="section-heading"><strong>6. Complete Unit 4 Integration Example</strong></h2>
            

            <div class="code-block">
                <pre><code class="language-r"># Complete Unit 4 Integration: Regression with Advanced Visualization
unit_4_integration &lt;- function() {
  cat(&quot;UNIT 4 INTEGRATION: REGRESSION WITH ADVANCED VISUALIZATION\n&quot;)
  cat(&quot;===========================================================\n\n&quot;)
  
  # 1. Create comprehensive dataset
  set.seed(123)
  n &lt;- 200
  
  # Generate predictors
  data &lt;- data.frame(
    # Continuous predictors
    age = rnorm(n, mean = 45, sd = 15),
    income = rnorm(n, mean = 50000, sd = 15000),
    education = rnorm(n, mean = 16, sd = 4),
    
    # Categorical predictors
    gender = factor(sample(c(&quot;Male&quot;, &quot;Female&quot;), n, replace = TRUE)),
    region = factor(sample(c(&quot;North&quot;, &quot;South&quot;, &quot;East&quot;, &quot;West&quot;), n, replace = TRUE)),
    
    # Interaction terms
    age_income = rnorm(n, mean = 45, sd = 15) * rnorm(n, mean = 50000, sd = 15000) / 100000
  )
  
  # Generate response variable with complex relationship
  data$satisfaction &lt;- 
    50 + 
    0.5 * scale(data$age) + 
    0.8 * scale(data$income) + 
    0.3 * scale(data$education) +
    ifelse(data$gender == &quot;Male&quot;, 5, 0) +
    ifelse(data$region == &quot;North&quot;, 3,
           ifelse(data$region == &quot;South&quot;, -2,
                  ifelse(data$region == &quot;East&quot;, 1, 0))) +
    0.2 * scale(data$age_income) +
    rnorm(n, sd = 10)
  
  # 2. Multiple Linear Regression
  cat(&quot;1. MULTIPLE LINEAR REGRESSION ANALYSIS\n&quot;)
  cat(&quot;--------------------------------------\n&quot;)
  
  # Full model
  full_model &lt;- lm(satisfaction ~ age + income + education + 
                   gender + region + age_income, 
                   data = data)
  
  # Model summary
  cat(&quot;Full Model Formula:\n&quot;)
  cat(&quot;  satisfaction ~ age + income + education + gender + region + age_income\n\n&quot;)
  
  cat(&quot;Model Summary:\n&quot;)
  full_summary &lt;- summary(full_model)
  print(full_summary)
  
  # 3. Model Diagnostics with Advanced Graphics
  cat(&quot;\n2. MODEL DIAGNOSTICS WITH ADVANCED GRAPHICS\n&quot;)
  cat(&quot;-------------------------------------------\n&quot;)
  
  # Setup diagnostic plots
  old_par &lt;- par(no.readonly = TRUE)
  layout(matrix(1:9, nrow = 3, byrow = TRUE))
  
  # Plot 1: Actual vs Predicted
  par(mar = c(4, 4, 3, 2))
  plot(fitted(full_model), data$satisfaction,
       pch = 19, col = rgb(0, 0, 1, 0.6), cex = 1.2,
       main = &quot;Actual vs Predicted&quot;,
       xlab = &quot;Predicted Satisfaction&quot;,
       ylab = &quot;Actual Satisfaction&quot;)
  abline(0, 1, col = &quot;red&quot;, lwd = 2)
  lines(lowess(fitted(full_model), data$satisfaction), 
        col = &quot;green&quot;, lwd = 2)
  
  # Add R-squared annotation
  r2 &lt;- round(full_summary$r.squared, 3)
  text(min(fitted(full_model)), max(data$satisfaction),
       paste(&quot;R² =&quot;, r2), pos = 4, col = &quot;darkred&quot;, font = 2)
  
  # Plot 2: Residuals vs Fitted
  par(mar = c(4, 4, 3, 2))
  plot(fitted(full_model), residuals(full_model),
       pch = 19, col = rgb(0.5, 0, 0.5, 0.6),
       main = &quot;Residuals vs Fitted&quot;,
       xlab = &quot;Fitted Values&quot;, ylab = &quot;Residuals&quot;)
  abline(h = 0, col = &quot;red&quot;, lwd = 2)
  lines(lowess(fitted(full_model), residuals(full_model)),
        col = &quot;blue&quot;, lwd = 2)
  
  # Plot 3: Q-Q Plot of Residuals
  par(mar = c(4, 4, 3, 2))
  qqnorm(residuals(full_model), pch = 19,
         col = rgb(0, 0.5, 0, 0.6),
         main = &quot;Normal Q-Q Plot&quot;)
  qqline(residuals(full_model), col = &quot;red&quot;, lwd = 2)
  
  # Add Shapiro-Wilk test
  sw_test &lt;- shapiro.test(residuals(full_model))
  text(min(residuals(full_model)), max(residuals(full_model)) * 0.9,
       paste(&quot;Shapiro-Wilk p =&quot;, 
             format.pval(sw_test$p.value, digits = 3)),
       pos = 4, col = &quot;darkblue&quot;)
  
  # Plot 4: Scale-Location Plot
  par(mar = c(4, 4, 3, 2))
  sqrt_abs_resid &lt;- sqrt(abs(rstandard(full_model)))
  plot(fitted(full_model), sqrt_abs_resid,
       pch = 19, col = rgb(1, 0.5, 0, 0.6),
       main = &quot;Scale-Location Plot&quot;,
       xlab = &quot;Fitted Values&quot;,
       ylab = expression(sqrt(&quot;|Standardized Residuals|&quot;)))
  lines(lowess(fitted(full_model), sqrt_abs_resid),
        col = &quot;purple&quot;, lwd = 2)
  
  # Plot 5: Residuals vs Leverage
  par(mar = c(4, 4, 3, 2))
  plot(hatvalues(full_model), rstudent(full_model),
       pch = 19, col = rgb(0, 0.5, 0.5, 0.6),
       main = &quot;Residuals vs Leverage&quot;,
       xlab = &quot;Leverage&quot;, ylab = &quot;Studentized Residuals&quot;)
  abline(h = c(-2, 0, 2), col = c(&quot;red&quot;, &quot;black&quot;, &quot;red&quot;), lty = c(2, 1, 2))
  abline(v = 2 * length(coef(full_model)) / n, col = &quot;blue&quot;, lty = 2)
  
  # Highlight influential points
  cooks_d &lt;- cooks.distance(full_model)
  influential &lt;- which(cooks_d &gt; 4/n)
  if (length(influential) &gt; 0) {
    points(hatvalues(full_model)[influential],
           rstudent(full_model)[influential],
           pch = 21, bg = &quot;red&quot;, col = &quot;darkred&quot;, cex = 1.5)
    text(hatvalues(full_model)[influential],
         rstudent(full_model)[influential],
         influential, pos = 3, col = &quot;darkred&quot;, cex = 0.8)
  }
  
  # Plot 6: Cook&#x27;s Distance
  par(mar = c(4, 4, 3, 2))
  plot(cooks_d, type = &quot;h&quot;,
       col = ifelse(cooks_d &gt; 4/n, &quot;red&quot;, &quot;blue&quot;),
       main = &quot;Cook&#x27;s Distance&quot;,
       xlab = &quot;Observation Index&quot;, ylab = &quot;Cook&#x27;s Distance&quot;)
  abline(h = 4/n, col = &quot;red&quot;, lty = 2, lwd = 2)
  text(n * 0.8, 4/n * 1.2, &quot;Threshold = 4/n&quot;, col = &quot;red&quot;)
  
  # Plot 7: Added Variable Plots
  par(mar = c(4, 4, 3, 2))
  # For age
  avPlot(full_model, variable = &quot;age&quot;,
         main = &quot;Added Variable Plot: Age&quot;,
         pch = 19, col = &quot;blue&quot;, lwd = 2)
  
  # Plot 8: Coefficient Plot with Custom Colors
  par(mar = c(6, 4, 3, 2))
  coef_data &lt;- coef(full_model)[-1]  # Exclude intercept
  coef_names &lt;- names(coef_data)
  
  # Create color gradient based on coefficient magnitude
  coef_abs &lt;- abs(coef_data)
  coef_colors &lt;- colorRampPalette(c(&quot;blue&quot;, &quot;red&quot;))(100)[
    round((coef_abs - min(coef_abs)) / 
          (max(coef_abs) - min(coef_abs)) * 99) + 1
  ]
  
  barplot(coef_data, names.arg = coef_names,
          col = coef_colors, border = &quot;black&quot;,
          main = &quot;Coefficient Estimates&quot;,
          ylab = &quot;Coefficient Value&quot;,
          las = 2, cex.names = 0.8)
  abline(h = 0, col = &quot;black&quot;, lwd = 1)
  
  # Add significance stars
  p_values &lt;- full_summary$coefficients[-1, 4]
  sig_levels &lt;- cut(p_values, 
                   breaks = c(0, 0.001, 0.01, 0.05, 0.1, 1),
                   labels = c(&quot;***&quot;, &quot;**&quot;, &quot;*&quot;, &quot;.&quot;, &quot;&quot;))
  
  y_pos &lt;- ifelse(coef_data &gt; 0, coef_data + 0.5, coef_data - 0.5)
  text(1:length(coef_data), y_pos, sig_levels, cex = 1.2)
  
  # Plot 9: 3D Visualization of Key Predictors
  par(mar = c(4, 4, 3, 2))
  
  # Create 3D scatter using 2D projection with color
  library(scatterplot3d)
  
  # Select three key predictors
  scatterplot3d(data$age, data$income, data$satisfaction,
                color = as.numeric(data$gender),
                pch = 19, cex.symbols = 0.8,
                main = &quot;3D Scatter: Age, Income, Satisfaction&quot;,
                xlab = &quot;Age&quot;, ylab = &quot;Income&quot;, zlab = &quot;Satisfaction&quot;,
                angle = 55)
  
  # Add regression plane
  # plane_model &lt;- lm(satisfaction ~ age + income, data = data)
  # plane &lt;- expand.grid(age = range(data$age),
  #                      income = range(data$income))
  # plane$satisfaction &lt;- predict(plane_model, newdata = plane)
  # 
  # with(plane, {
  #   scatterplot3d(age, income, satisfaction, type = &quot;l&quot;,
  #                 add = TRUE, col = &quot;blue&quot;, lty = 2)
  # })
  
  # Reset parameters
  par(old_par)
  
  # 4. Model Selection
  cat(&quot;\n3. MODEL SELECTION\n&quot;)
  cat(&quot;-----------------\n&quot;)
  
  # Stepwise selection
  null_model &lt;- lm(satisfaction ~ 1, data = data)
  
  forward_model &lt;- step(null_model,
                       scope = list(lower = null_model, upper = full_model),
                       direction = &quot;forward&quot;, trace = 0)
  
  backward_model &lt;- step(full_model,
                        direction = &quot;backward&quot;, trace = 0)
  
  stepwise_model &lt;- step(null_model,
                        scope = list(lower = null_model, upper = full_model),
                        direction = &quot;both&quot;, trace = 0)
  
  cat(&quot;Forward Selection Model:\n&quot;)
  print(summary(forward_model))
  
  cat(&quot;\nBackward Elimination Model:\n&quot;)
  print(summary(backward_model))
  
  cat(&quot;\nStepwise Selection Model:\n&quot;)
  print(summary(stepwise_model))
  
  # 5. Prediction with Confidence Intervals
  cat(&quot;\n4. PREDICTION WITH CONFIDENCE INTERVALS\n&quot;)
  cat(&quot;----------------------------------------\n&quot;)
  
  # Create new data for prediction
  new_data &lt;- data.frame(
    age = c(30, 45, 60),
    income = c(40000, 50000, 60000),
    education = c(12, 16, 20),
    gender = factor(c(&quot;Male&quot;, &quot;Female&quot;, &quot;Male&quot;), levels = levels(data$gender)),
    region = factor(c(&quot;North&quot;, &quot;South&quot;, &quot;East&quot;), levels = levels(data$region)),
    age_income = c(30*40000/100000, 45*50000/100000, 60*60000/100000)
  )
  
  # Make predictions
  predictions &lt;- predict(stepwise_model, newdata = new_data,
                        interval = &quot;prediction&quot;, level = 0.95)
  
  pred_results &lt;- cbind(new_data, predictions)
  
  cat(&quot;Predictions for New Data:\n&quot;)
  print(pred_results)
  
  # 6. Advanced Visualization of Results
  cat(&quot;\n5. ADVANCED VISUALIZATION OF RESULTS\n&quot;)
  cat(&quot;-------------------------------------\n&quot;)
  
  # Create final summary plot
  dev.new()
  layout(matrix(1:4, nrow = 2, byrow = TRUE))
  
  # Plot 1: Model Comparison
  models &lt;- list(Full = full_model, 
                Forward = forward_model,
                Backward = backward_model,
                Stepwise = stepwise_model)
  
  comparison_metrics &lt;- data.frame(
    Model = names(models),
    R2 = sapply(models, function(m) round(summary(m)$r.squared, 3)),
    Adj_R2 = sapply(models, function(m) round(summary(m)$adj.r.squared, 3)),
    AIC = round(sapply(models, AIC), 1),
    BIC = round(sapply(models, BIC), 1)
  )
  
  par(mar = c(8, 4, 4, 2))
  barplot(comparison_metrics$R2, names.arg = comparison_metrics$Model,
          col = rainbow(nrow(comparison_metrics)),
          main = &quot;Model Comparison: R-squared&quot;,
          ylab = &quot;R-squared&quot;, ylim = c(0, 1),
          las = 2)
  
  # Plot 2: Residual Distribution by Group
  par(mar = c(5, 4, 4, 2))
  boxplot(residuals(stepwise_model) ~ data$gender,
          col = c(&quot;lightblue&quot;, &quot;lightpink&quot;),
          main = &quot;Residual Distribution by Gender&quot;,
          xlab = &quot;Gender&quot;, ylab = &quot;Residuals&quot;)
  abline(h = 0, col = &quot;red&quot;, lty = 2)
  
  # Plot 3: Interaction Effect Visualization
  par(mar = c(5, 4, 4, 2))
  
  # Create interaction plot
  interaction.plot(data$gender, data$region, data$satisfaction,
                  main = &quot;Interaction: Gender × Region&quot;,
                  xlab = &quot;Gender&quot;, ylab = &quot;Mean Satisfaction&quot;,
                  trace.label = &quot;Region&quot;,
                  col = rainbow(length(unique(data$region))),
                  lwd = 2, type = &quot;b&quot;, pch = 19)
  
  # Plot 4: Prediction Interval Visualization
  par(mar = c(5, 4, 4, 2))
  
  # Sort predictions
  pred_sorted &lt;- pred_results[order(pred_results$fit), ]
  
  plot(1:nrow(pred_sorted), pred_sorted$fit, type = &quot;b&quot;,
       pch = 19, col = &quot;blue&quot;, lwd = 2, ylim = range(pred_sorted[, 7:9]),
       main = &quot;Predictions with 95% Prediction Intervals&quot;,
       xlab = &quot;Observation&quot;, ylab = &quot;Predicted Satisfaction&quot;,
       xaxt = &quot;n&quot;)
  axis(1, at = 1:nrow(pred_sorted), 
       labels = paste(&quot;Obs&quot;, 1:nrow(pred_sorted)))
  
  # Add prediction intervals
  arrows(1:nrow(pred_sorted), pred_sorted$lwr,
         1:nrow(pred_sorted), pred_sorted$upr,
         angle = 90, code = 3, length = 0.1, col = &quot;red&quot;, lwd = 2)
  
  # Add actual values if available (for demonstration)
  points(1:nrow(pred_sorted), 
         sample(data$satisfaction, nrow(pred_sorted)),
         pch = 17, col = &quot;green&quot;, cex = 1.5)
  
  legend(&quot;topleft&quot;,
         legend = c(&quot;Predicted&quot;, &quot;95% Prediction Interval&quot;, &quot;Actual (sample)&quot;),
         col = c(&quot;blue&quot;, &quot;red&quot;, &quot;green&quot;),
         pch = c(19, NA, 17),
         lwd = c(2, 2, NA),
         lty = c(1, 1, NA),
         bg = &quot;white&quot;)
  
  # 7. Return Comprehensive Results
  cat(&quot;\n6. SUMMARY AND CONCLUSIONS\n&quot;)
  cat(&quot;--------------------------\n&quot;)
  
  cat(&quot;Based on the analysis:\n&quot;)
  cat(&quot;1. Best model (by stepwise selection):\n&quot;)
  cat(&quot;   &quot;, deparse(formula(stepwise_model)), &quot;\n&quot;)
  cat(&quot;2. R-squared:&quot;, round(summary(stepwise_model)$r.squared, 3), &quot;\n&quot;)
  cat(&quot;3. Key predictors (p &lt; 0.05):\n&quot;)
  
  sig_coefs &lt;- full_summary$coefficients[full_summary$coefficients[, 4] &lt; 0.05, ]
  if (nrow(sig_coefs) &gt; 0) {
    for (i in 1:nrow(sig_coefs)) {
      cat(&quot;   &quot;, rownames(sig_coefs)[i], &quot;: β = &quot;, 
          round(sig_coefs[i, 1], 3), 
          &quot;, p = &quot;, format.pval(sig_coefs[i, 4], digits = 3), &quot;\n&quot;, sep = &quot;&quot;)
    }
  } else {
    cat(&quot;   No predictors significant at α = 0.05\n&quot;)
  }
  
  cat(&quot;4. Model assumptions:\n&quot;)
  cat(&quot;   - Normality: Shapiro-Wilk p =&quot;, 
      format.pval(sw_test$p.value, digits = 3), &quot;\n&quot;)
  cat(&quot;   - Homoscedasticity: Check scale-location plot\n&quot;)
  cat(&quot;   - Independence: Durbin-Watson test recommended\n&quot;)
  
  cat(&quot;5. Recommendations:\n&quot;)
  cat(&quot;   - Use stepwise model for prediction\n&quot;)
  cat(&quot;   - Consider interaction terms if domain knowledge suggests\n&quot;)
  cat(&quot;   - Validate model on new data\n&quot;)
  
  # Return all results
  return(list(
    data = data,
    models = models,
    model_comparison = comparison_metrics,
    predictions = pred_results,
    diagnostics = list(
      shapiro_test = sw_test,
      influential_points = influential,
      cooks_distance = cooks_d
    ),
    summary = list(
      best_model = stepwise_model,
      significant_predictors = if (exists(&quot;sig_coefs&quot;)) sig_coefs else NULL,
      r_squared = summary(stepwise_model)$r.squared,
      adj_r_squared = summary(stepwise_model)$adj.r.squared
    )
  ))
}

# Run the complete Unit 4 integration
unit_4_results &lt;- unit_4_integration()</code></pre>
            </div>
            
<hr class="content-hr">
</section>

            <section class="content-section" id="books-reference-as-per-karnataka-university-dharwad">
                <h2 class="section-heading"><strong>Books Reference as per Karnataka University Dharwad</strong></h2>
            
</section>

            <section class="content-section" id="primary-references">
                <h3 class="section-heading"><strong>Primary References:</strong></h3>
            
<ol class="content-list"><li><strong>Tilman M. Davies (2016)</strong> - "The Book of R"</li></ol>
<p class="paragraph">- Chapters 17-21 cover regression, model selection, and advanced graphics
   - Comprehensive examples with R code
   - Practical approach to statistical modelling</p>
<ol class="content-list"><li><strong>Vishwas R. Pawgi (2022)</strong> - "Statistical Computing using R Software"</li></ol>
<p class="paragraph">- Chapters 12-16 cover Unit 4 topics
   - Indian context examples
   - Exam-oriented approach with problems</p>
</section>

            <section class="content-section" id="additional-references">
                <h3 class="section-heading"><strong>Additional References:</strong></h3>
            
<ul class="content-list"><li>James et al. (2013) - "An Introduction to Statistical Learning"</li>
<li>Faraway (2005) - "Linear Models with R"</li>
<li>Murrell (2011) - "R Graphics"</li>
<li>Chang (2013) - "R Graphics Cookbook"</li></ul>
</section>

            <section class="content-section" id="r-specific-references">
                <h3 class="section-heading"><strong>R-specific References:</strong></h3>
            
<ul class="content-list"><li>Wickham (2016) - "ggplot2: Elegant Graphics for Data Analysis"</li>
<li>Kabacoff (2015) - "R in Action" (Graphics and visualization chapters)</li></ul>
<hr class="content-hr">
</section>

            <section class="content-section" id="important-formulas-and-concepts">
                <h2 class="section-heading"><strong>Important Formulas and Concepts</strong></h2>
            
</section>

            <section class="content-section" id="linear-regression-formulas">
                <h3 class="section-heading"><strong>Linear Regression Formulas:</strong></h3>
            
<ol class="content-list"><li><strong>Simple Linear Regression</strong>:</li></ol>
<p class="paragraph">- Slope: <code>β₁ = Σ((xᵢ - x̄)(yᵢ - ȳ)) / Σ(xᵢ - x̄)²</code>
   - Intercept: <code>β₀ = ȳ - β₁x̄</code>
   - R²: <code>1 - (SS_residual / SS_total)</code></p>
<ol class="content-list"><li><strong>Multiple Linear Regression</strong>:</li></ol>
<p class="paragraph">- Matrix form: <code>β = (X'X)⁻¹X'y</code>
   - Standard error: <code>SE(βⱼ) = √(MSE * (X'X)ⱼⱼ⁻¹)</code>
   - F-statistic: <code>F = (SS_regression/p) / (SS_residual/(n-p-1))</code></p>
</section>

            <section class="content-section" id="model-selection-criteria">
                <h3 class="section-heading"><strong>Model Selection Criteria:</strong></h3>
            
<ol class="content-list"><li><strong>AIC</strong>: <code>-2*log(L) + 2k</code></li>
<li><strong>BIC</strong>: <code>-2<em>log(L) + k</em>log(n)</code></li>
<li><strong>Adjusted R²</strong>: <code>1 - [(1-R²)(n-1)/(n-k-1)]</code></li></ol>
</section>

            <section class="content-section" id="color-theory-concepts">
                <h3 class="section-heading"><strong>Color Theory Concepts:</strong></h3>
            
<ol class="content-list"><li><strong>RGB</strong>: Additive color model (Red, Green, Blue)</li>
<li><strong>HSV/HSL</strong>: Hue, Saturation, Value/Lightness</li>
<li><strong>Color Blindness Types</strong>: Deuteranopia, Protanopia, Tritanopia</li>
<li><strong>Palette Types</strong>: Sequential, Diverging, Qualitative</li></ol>
<hr class="content-hr">
</section>

            <section class="content-section" id="examination-preparation">
                <h2 class="section-heading"><strong>Examination Preparation</strong></h2>
            
</section>

            <section class="content-section" id="key-concepts-for-exams">
                <h3 class="section-heading"><strong>Key Concepts for Exams:</strong></h3>
            
<ol class="content-list"><li><strong>Regression Analysis</strong>:</li></ol>
<p class="paragraph">- Assumptions of linear regression
   - Interpretation of coefficients
   - Model diagnostics and validation
   - Multicollinearity detection</p>
<ol class="content-list"><li><strong>Graphics and Visualization</strong>:</li></ol>
<p class="paragraph">- Customizing plot elements
   - Color theory and application
   - 3D and high-dimensional visualization
   - Interactive graphics</p>
<ol class="content-list"><li><strong>Model Selection</strong>:</li></ol>
<p class="paragraph">- Criteria for model comparison
   - Stepwise selection procedures
   - Regularization methods</p>
</section>

            <section class="content-section" id="problem-solving-framework">
                <h3 class="section-heading"><strong>Problem-Solving Framework:</strong></h3>
            

            <div class="code-block">
                <pre><code class="language-r"># Template for regression problems
solve_regression_problem &lt;- function(data, response_var, predictor_vars) {
  cat(&quot;1. Exploratory data analysis\n&quot;)
  cat(&quot;2. Check assumptions\n&quot;)
  cat(&quot;3. Fit initial model\n&quot;)
  cat(&quot;4. Perform model diagnostics\n&quot;)
  cat(&quot;5. Consider model selection\n&quot;)
  cat(&quot;6. Validate final model\n&quot;)
  cat(&quot;7. Interpret results\n&quot;)
  cat(&quot;8. Create visualizations\n&quot;)
}</code></pre>
            </div>
            
</section>

            <section class="content-section" id="practice-problems-with-r-code">
                <h3 class="section-heading"><strong>Practice Problems with R Code:</strong></h3>
            

            <div class="code-block">
                <pre><code class="language-r"># Practice Problem 1: Housing price prediction
# Variables: size, bedrooms, bathrooms, location
# Perform multiple regression and diagnostics

# Practice Problem 2: Customer satisfaction survey
# Analyze relationship between service quality, price, and satisfaction
# Include interaction terms

# Practice Problem 3: Time series with seasonality
# Create advanced visualization showing trend and seasonal components

# Practice Problem 4: High-dimensional data
# Use PCA and create biplot with custom colors</code></pre>
            </div>
            
</section>
        </main>
        
        <footer class="document-footer">
            <div class="footer-content">
                <pre>Document generated on January 02, 2026 at 18:02</p>
                <p class="document-stats">56 sections • 115 code blocks • with references</p>
            </div>
        </footer>
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-cpp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-sql.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
    <script>
        // Smooth scrolling for TOC links
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const targetId = this.getAttribute('href');
                if (targetId === '#') return;
                
                const targetElement = document.querySelector(targetId);
                if (targetElement) {
                    window.scrollTo({
                        top: targetElement.offsetTop - 80,
                        behavior: 'smooth'
                    });
                }
            });
        });
        
        // Copy code blocks
        document.querySelectorAll('pre code').forEach(codeBlock => {
            const copyButton = document.createElement('button');
            copyButton.className = 'copy-button';
            copyButton.innerHTML = '📋 Copy';
            copyButton.title = 'Copy to clipboard';
            
            const pre = codeBlock.parentNode;
            pre.style.position = 'relative';
            pre.insertBefore(copyButton, codeBlock);
            
            copyButton.addEventListener('click', async () => {
                try {
                    await navigator.clipboard.writeText(codeBlock.textContent);
                    copyButton.innerHTML = '✓ Copied!';
                    copyButton.classList.add('copied');
                    setTimeout(() => {
                        copyButton.innerHTML = '📋 Copy';
                        copyButton.classList.remove('copied');
                    }, 2000);
                } catch (err) {
                    console.error('Failed to copy: ', err);
                }
            });
        });
    </script>
</body>
</html>