<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DESIGN AND ANALYSIS OF ALGORITHM</title>
    <style>
        /* ============================================================================
   SIMPLE ELEGANT CSS FOR QUESTION PAPER CONVERTER
   Clean book/PDF style with white background and black text
   ============================================================================ */

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

html {
    font-size: 16px;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
    line-height: 1.6;
    color: #000000;
    background: #ffffff;
    min-height: 100vh;
    overflow-x: hidden;
}

/* ============================================================================
   DOCUMENT CONTAINER
   ============================================================================ */

.document {
    max-width: 8.5in;
    margin: 0 auto;
    padding: 40px;
    background: #ffffff;
}

/* ============================================================================
   HEADER STYLES
   ============================================================================ */

.header {
    text-align: center;
    margin-bottom: 40px;
    padding-bottom: 20px;
    border-bottom: 2px solid #000000;
}

.title {
    font-size: 28px;
    font-weight: 700;
    line-height: 1.3;
    margin-bottom: 15px;
    color: #000000;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.meta-info {
    display: flex;
    justify-content: center;
    gap: 20px;
    margin-top: 15px;
    flex-wrap: wrap;
}

.meta-item {
    font-size: 14px;
    color: #333333;
    font-weight: 500;
}

/* ============================================================================
   CONTENT AREA
   ============================================================================ */

.content {
    padding: 20px 0;
}

/* ============================================================================
   PART SECTIONS
   ============================================================================ */

.part {
    margin-bottom: 40px;
    page-break-inside: avoid;
}

.part-title {
    font-size: 20px;
    font-weight: 700;
    color: #000000;
    margin-bottom: 15px;
    padding-bottom: 5px;
    border-bottom: 1px solid #333333;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.part-description {
    font-size: 14px;
    color: #333333;
    margin-bottom: 20px;
    padding-left: 10px;
    font-style: italic;
}

/* ============================================================================
   QUESTIONS CONTAINER
   ============================================================================ */

.questions {
    display: flex;
    flex-direction: column;
    gap: 25px;
}

/* ============================================================================
   QUESTION STYLES
   ============================================================================ */

.question {
    margin-bottom: 20px;
    page-break-inside: auto;
}

.question-header {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 8px;
}

.question-number {
    font-size: 16px;
    font-weight: 700;
    color: #000000;
    min-width: 25px;
}

.marks {
    font-size: 13px;
    color: #666666;
    font-weight: 500;
}

.question-text {
    font-size: 15px;
    font-weight: 600;
    color: #000000;
    line-height: 1.7;
    margin-bottom: 15px;
}

/* ============================================================================
   ANSWER STYLES
   ============================================================================ */

.answer {
    margin-top: 15px;
}

.answer-label {
    font-size: 15px;
    font-weight: 700;
    color: #000000;
    margin-bottom: 8px;
}

.answer-text {
    font-size: 15px;
    font-weight: 400;
    color: #333333;
    line-height: 1.7;
}

/* Bold styling for highlighted keywords */
.answer-text strong {
    font-weight: 700;
    color: #000000;
}

/* ============================================================================
   TEXT LINES AND INDENTATION
   ============================================================================ */

.text-line {
    margin-bottom: 8px;
    line-height: 1.7;
}

.empty-line {
    height: 10px;
}

.indent-1 {
    padding-left: 20px;
}

.indent-2 {
    padding-left: 40px;
}

.indent-3 {
    padding-left: 60px;
}

.indent-4 {
    padding-left: 80px;
}

/* ============================================================================
   FOOTER
   ============================================================================ */

.footer {
    margin-top: 50px;
    padding-top: 20px;
    border-top: 1px solid #cccccc;
    text-align: center;
}

.footer-content p {
    font-size: 13px;
    color: #666666;
}

/* ============================================================================
   RESPONSIVE DESIGN
   ============================================================================ */

@media (max-width: 900px) {
    .document {
        padding: 30px;
        max-width: 100%;
    }
    
    .title {
        font-size: 24px;
    }
    
    .meta-info {
        gap: 15px;
    }
}

@media (max-width: 768px) {
    .document {
        padding: 20px;
    }
    
    .title {
        font-size: 22px;
    }
    
    .part-title {
        font-size: 18px;
    }
    
    .question-text {
        font-size: 14px;
    }
    
    .answer-text {
        font-size: 14px;
    }
    
    .meta-info {
        flex-direction: column;
        gap: 5px;
        align-items: center;
    }
    
    /* Adjust indentation for mobile */
    .indent-1 { padding-left: 15px; }
    .indent-2 { padding-left: 30px; }
    .indent-3 { padding-left: 45px; }
    .indent-4 { padding-left: 60px; }
}

@media (max-width: 480px) {
    .document {
        padding: 15px;
    }
    
    .title {
        font-size: 20px;
    }
    
    .part-title {
        font-size: 16px;
    }
    
    .question-header {
        flex-direction: column;
        align-items: flex-start;
        gap: 5px;
    }
    
    .question-number {
        font-size: 15px;
    }
    
    .question-text {
        font-size: 13px;
    }
    
    .answer-text {
        font-size: 13px;
    }
    
    .indent-1 { padding-left: 12px; }
    .indent-2 { padding-left: 24px; }
    .indent-3 { padding-left: 36px; }
    .indent-4 { padding-left: 48px; }
}

/* ============================================================================
   PRINT STYLES
   ============================================================================ */

@media print {
    @page {
        margin: 0.5in;
        size: letter;
    }
    
    body {
        font-size: 12pt;
        line-height: 1.5;
        background: white !important;
        color: black !important;
    }
    
    .document {
        max-width: 100%;
        padding: 0;
        margin: 0;
    }
    
    .header {
        border-bottom: 1pt solid black;
        margin-bottom: 0.3in;
        padding-bottom: 0.2in;
    }
    
    .title {
        font-size: 16pt;
        margin-bottom: 0.1in;
    }
    
    .meta-item {
        font-size: 10pt;
    }
    
    .part {
        margin-bottom: 0.3in;
        page-break-inside: avoid;
    }
    
    .part-title {
        font-size: 14pt;
        border-bottom: 0.5pt solid black;
    }
    
    .question {
        margin-bottom: 0.2in;
        page-break-inside: auto;
    }
    
    .question-number {
        font-size: 11pt;
    }
    
    .marks {
        font-size: 9pt;
    }
    
    .question-text {
        font-size: 11pt;
        font-weight: 600;
    }
    
    .answer-label {
        font-size: 11pt;
        font-weight: 700;
    }
    
    .answer-text {
        font-size: 11pt;
        font-weight: 400;
    }
    
    .answer-text strong {
        font-weight: 700;
    }
    
    .text-line {
        margin-bottom: 0.05in;
    }
    
    .footer {
        margin-top: 0.3in;
        padding-top: 0.1in;
        border-top: 0.5pt solid #ccc;
    }
    
    .footer-content p {
        font-size: 9pt;
    }
    
    /* Remove all transitions and shadows for print */
    * {
        box-shadow: none !important;
        transition: none !important;
    }
    
    /* Ensure proper page breaks between parts */
    .part {
        page-break-after: auto;
        page-break-before: auto;
    }
    
    /* Don't break inside questions */
    .question {
        page-break-inside: avoid;
    }
}

/* ============================================================================
   UTILITY CLASSES
   ============================================================================ */

::selection {
    background: rgba(0, 0, 0, 0.1);
}

/* Hide scrollbar for print */
@media print {
    ::-webkit-scrollbar {
        display: none;
    }
}
    </style>
</head>
<body>
    <div class="document">
        
        <header class="header">
            <h1 class="title">
                DESIGN AND ANALYSIS OF ALGORITHM
            </h1>
            <div class="meta-info">
                
                <div class="meta-item">February - 2024</div>
                
                
            </div>
        </header>
        
        <main class="content">
            
            <div class="part" id="part-1">
                <h2 class="part-title">PART - A</h2>
            

                <div class="part-description">
                    Answer any five questions from this part each carries two marks : (5 x 2 =10)
                </div>
                
<div class="questions">

        <div class="question" id="q1-1">
            <div class="question-header">
                <span class="question-number">1.</span>
                
            </div>
            <div class="question-text">
                <div class="text-line">What is an algorithm ?</div>
            </div>
            
        <div class="answer">
            <div class="answer-label">Ans:</div>
            <div class="answer-text">
                <div class="text-line">An algorithm is a step-by-step, unambiguous, finite, and effective procedure for solving a well-defined computational problem. It takes zero or more inputs, produces at least one output, and terminates after a finite number of steps. In essence, it is a recipe or a precise set of instructions to accomplish a specific task.</div>
            </div>
        </div>
        
        </div>
        

        <div class="question" id="q1-2">
            <div class="question-header">
                <span class="question-number">2.</span>
                
            </div>
            <div class="question-text">
                <div class="text-line">What is time complexity of an algorithm ?</div>
            </div>
            
        <div class="answer">
            <div class="answer-label">Ans:</div>
            <div class="answer-text">
                <div class="text-line">Time complexity:</div>
<div class="text-line">	A measure of how the running time of an algorithm grows with the size of its input n. It is usually expressed using asymptotic notation (e.g., O(n),O(n2)) and counts the 	number of basic operations rather than actual clock time.</div>
            </div>
        </div>
        
        </div>
        

        <div class="question" id="q1-3">
            <div class="question-header">
                <span class="question-number">3.</span>
                
            </div>
            <div class="question-text">
                <div class="text-line">Define graph.</div>
            </div>
            
        <div class="answer">
            <div class="answer-label">Ans:</div>
            <div class="answer-text">
                <div class="text-line">A graph is a non-linear data structure consisting of a finite set of vertices (nodes) and a finite set of edges that connect pairs of vertices.</div>
<div class="text-line">	Formally, a graph G is represented as:</div>
<div class="text-line">	G = (V, E)</div>
<div class="text-line">	where</div>
<div class="text-line">	V = set of vertices</div>
<div class="text-line">	E = set of edges connecting the vertices</div>
            </div>
        </div>
        
        </div>
        

        <div class="question" id="q1-4">
            <div class="question-header">
                <span class="question-number">4.</span>
                
            </div>
            <div class="question-text">
                <div class="text-line">What is minimum spanning tree ?</div>
            </div>
            
        <div class="answer">
            <div class="answer-label">Ans:</div>
            <div class="answer-text">
                <div class="text-line">A Minimum Spanning Tree (MST) is a subgraph of a connected, weighted, undirected graph that:</div>
<div class="text-line">	Includes all the vertices of the graph</div>
<div class="text-line">	Is a tree (i.e., has no cycles)</div>
<div class="text-line">	Has the minimum possible total edge weight among all spanning trees of the graph</div>
<div class="text-line">	If a graph has V vertices, then its MST will contain exactly V − 1 edges.</div>
            </div>
        </div>
        
        </div>
        

        <div class="question" id="q1-5">
            <div class="question-header">
                <span class="question-number">5.</span>
                
            </div>
            <div class="question-text">
                <div class="text-line">Define greedy method.</div>
            </div>
            
        <div class="answer">
            <div class="answer-label">Ans:</div>
            <div class="answer-text">
                <div class="text-line">The Greedy Method is a problem-solving technique in which a solution is built step-by-step, and at each step the best possible (locally optimal) choice is selected without reconsidering previous decisions.</div>
<div class="text-line">	The hope is that these locally optimal choices will lead to a globally optimal solution.</div>
<div class="text-line">	This method works correctly only for problems that satisfy optimal substructure and the greedy-choice property. Examples include Kruskal’s algorithm, Prim’s algorithm, and the Fractional Knapsack problem.</div>
            </div>
        </div>
        
        </div>
        

        <div class="question" id="q1-6">
            <div class="question-header">
                <span class="question-number">6.</span>
                
            </div>
            <div class="question-text">
                <div class="text-line">What do you mean by divide and conquer technique ?</div>
            </div>
            
        <div class="answer">
            <div class="answer-label">Ans:</div>
            <div class="answer-text">
                <div class="text-line">Divide and Conquer is a problem-solving technique in which a problem is broken into smaller subproblems, each subproblem is solved independently, and then the solutions of the subproblems are combined to obtain the final solution.</div>
<div class="text-line">	It works in three phases:</div>
<div class="text-line">	Divide</div>
<div class="text-line">	The original problem is divided into two or more smaller subproblems of the same type.</div>
<div class="text-line">	Conquer</div>
<div class="text-line">	Each subproblem is solved recursively. If the subproblem is small enough, it is solved directly.</div>
<div class="text-line">	Combine</div>
<div class="text-line">	The solutions of the subproblems are merged to obtain the solution of the original problem.</div>
<div class="text-line">	Examples of algorithms using this technique include Merge Sort, Quick Sort, Binary Search, and Strassen’s Matrix Multiplication.</div>
            </div>
        </div>
        
        </div>
        
</div>
</div>

            <div class="part" id="part-2">
                <h2 class="part-title">PART - B</h2>
            

                <div class="part-description">
                    Answer any four questions.Each question carries 5 marks : (4 x 5 = 20)
                </div>
                
<div class="questions">

        <div class="question" id="q2-1">
            <div class="question-header">
                <span class="question-number">7.</span>
                
            </div>
            <div class="question-text">
                <div class="text-line">Write an algorithm for bubble sort and find its time complexity.</div>
            </div>
            
        <div class="answer">
            <div class="answer-label">Ans:</div>
            <div class="answer-text">
                <div class="text-line">Bubble Sort is a simple comparison-based sorting algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. The pass through the list is repeated until no swaps are needed.</div>
<div class="text-line">	Algorithm (Step-by-Step)</div>
<div class="text-line">	Algorithm BubbleSort(A[0..n-1])</div>
<div class="text-line">	// Sorts a given array by bubble sort</div>
<div class="text-line">	// Input: An array A[0..n-1] of orderable elements</div>
<div class="text-line">	// Output: Array A[0..n-1] sorted in non-decreasing order</div>
<div class="text-line">	for i ← 0 to n-2 do</div>
<div class="text-line indent-1">	    for j ← 0 to n-2-i do</div>
<div class="text-line indent-2">	        if A[j+1] < A[j]</div>
<div class="text-line indent-3">	            // Swap A[j] and A[j+1]</div>
<div class="text-line indent-3">	            temp ← A[j]</div>
<div class="text-line indent-3">	            A[j] ← A[j+1]</div>
<div class="text-line indent-3">	            A[j+1] ← temp</div>
<div class="text-line">	In each pass (outer loop), the largest unsorted element "bubbles up" to its correct position at the end.</div>
<div class="text-line">	The inner loop compares adjacent pairs and swaps them if they're in wrong order.</div>
<div class="text-line">	After each pass, the next largest element is in place, so inner loop range decreases.</div>
<div class="text-line">	The optimized version stops early if no swaps occur (array is sorted).</div>
<div class="text-line">	Time Complexity</div>
<div class="text-line">	Best Case (Optimized): O(n) - Array already sorted, one pass with n-1 comparisons</div>
<div class="text-line">	Average Case: Θ(n²)</div>
<div class="text-line">	Worst Case: O(n²) - Array sorted in reverse order</div>
<div class="text-line">	Space Complexity</div>
<div class="text-line">	O(1) - Constant space, in-place sorting.</div>
            </div>
        </div>
        
        </div>
        

        <div class="question" id="q2-2">
            <div class="question-header">
                <span class="question-number">8.</span>
                
            </div>
            <div class="question-text">
                <div class="text-line">Solve the given Lnapsack problem using Brute Force technique. (W1,W2,W3)=(20,25,10) ,(P1,P2,P3)=(30,40,35), M=40</div>
            </div>
            
        <div class="answer">
            <div class="answer-label">Ans:</div>
            <div class="answer-text">
                <div class="text-line">We list all possible combinations of items and select the one that gives the maximum profit without exceeding the capacity.</div>
<div class="text-line">	Step 1: List all subsets with total weight and profit</div>
<div class="text-line">	No item selected</div>
<div class="text-line">	Total Weight = 0</div>
<div class="text-line">	Total Profit = 0</div>
<div class="text-line">	Item 1</div>
<div class="text-line">	Weight = 20</div>
<div class="text-line">	Profit = 30</div>
<div class="text-line">	Item 2</div>
<div class="text-line">	Weight = 25</div>
<div class="text-line">	Profit = 40</div>
<div class="text-line">	Item 3</div>
<div class="text-line">	Weight = 10</div>
<div class="text-line">	Profit = 35</div>
<div class="text-line">	Item 1 + Item 2</div>
<div class="text-line">	Weight = 20 + 25 = 45 > 40 (Not allowed)</div>
<div class="text-line">	Item 1 + Item 3</div>
<div class="text-line">	Weight = 20 + 10 = 30</div>
<div class="text-line">	Profit = 30 + 35 = 65</div>
<div class="text-line">	Item 2 + Item 3</div>
<div class="text-line">	Weight = 25 + 10 = 35</div>
<div class="text-line">	Profit = 40 + 35 = 75</div>
<div class="text-line">	Item 1 + Item 2 + Item 3</div>
<div class="text-line">	Weight = 20 + 25 + 10 = 55 > 40 (Not allowed)</div>
<div class="text-line">	Step 2: Choose valid combination with maximum profit</div>
<div class="text-line">	Valid combinations and profits are:</div>
<div class="text-line">	• Item 1 → Profit = 30</div>
<div class="text-line">	• Item 2 → Profit = 40</div>
<div class="text-line">	• Item 3 → Profit = 35</div>
<div class="text-line">	• Item 1 + 3 → Profit = 65</div>
<div class="text-line">	• Item 2 + 3 → Profit = 75 ← Maximum</div>
<div class="text-line">	• None → Profit = 0</div>
<div class="text-line">	Result</div>
<div class="text-line">	The optimal solution is:</div>
<div class="text-line">	Select Item 2 and Item 3</div>
<div class="text-line">	Total Weight = 35 (≤ 40)</div>
<div class="text-line">	Total Profit = 75</div>
            </div>
        </div>
        
        </div>
        

        <div class="question" id="q2-3">
            <div class="question-header">
                <span class="question-number">9.</span>
                
            </div>
            <div class="question-text">
                <div class="text-line">Find the minimum spaning tree using Prim's algorithm for the below graph.1-2=25,1-3=15,2-5=40,2-4=30,2-6=35,3-5=20,4-5=10,5-6=45.</div>
            </div>
            
        <div class="answer">
            <div class="answer-label">Ans:</div>
            <div class="answer-text">
                <div class="text-line">Start with vertex 1.</div>
<div class="text-line">	Step 1</div>
<div class="text-line">	Current tree vertices: {1}</div>
<div class="text-line">	Available edges:</div>
<div class="text-line">	1–2 = 25</div>
<div class="text-line">	1–3 = 15 ← minimum</div>
<div class="text-line">	Select 1–3 (15)</div>
<div class="text-line">	Tree vertices: {1, 3}</div>
<div class="text-line">	Step 2</div>
<div class="text-line">	Available edges from the tree:</div>
<div class="text-line">	1–2 = 25</div>
<div class="text-line">	3–5 = 20 ← minimum</div>
<div class="text-line">	Select 3–5 (20)</div>
<div class="text-line">	Tree vertices: {1, 3, 5}</div>
<div class="text-line">	Step 3</div>
<div class="text-line">	Available edges:</div>
<div class="text-line">	1–2 = 25</div>
<div class="text-line">	2–5 = 40</div>
<div class="text-line">	4–5 = 10 ← minimum</div>
<div class="text-line">	5–6 = 45</div>
<div class="text-line">	Select 4–5 (10)</div>
<div class="text-line">	Tree vertices: {1, 3, 5, 4}</div>
<div class="text-line">	Step 4</div>
<div class="text-line">	Available edges:</div>
<div class="text-line">	1–2 = 25 ← minimum</div>
<div class="text-line">	2–5 = 40</div>
<div class="text-line">	2–4 = 30</div>
<div class="text-line">	5–6 = 45</div>
<div class="text-line">	Select 1–2 (25)</div>
<div class="text-line">	Tree vertices: {1, 2, 3, 4, 5}</div>
<div class="text-line">	Step 5</div>
<div class="text-line">	Remaining vertex: 6</div>
<div class="text-line">	Available edges to 6:</div>
<div class="text-line">	2–6 = 35 ← minimum</div>
<div class="text-line">	5–6 = 45</div>
<div class="text-line">	Select 2–6 (35)</div>
<div class="text-line">	Tree vertices: {1, 2, 3, 4, 5, 6}</div>
<div class="text-line">	All vertices are now included.</div>
<div class="text-line">	Minimum Spanning Tree Edges</div>
<div class="text-line">	1–3 = 15</div>
<div class="text-line">	3–5 = 20</div>
<div class="text-line">	5–4 = 10</div>
<div class="text-line">	1–2 = 25</div>
<div class="text-line">	2–6 = 35</div>
<div class="text-line">	Total Minimum Cost</div>
<div class="text-line">	Total weight = 15 + 20 + 10 + 25 + 35</div>
<div class="text-line">	= 105</div>
            </div>
        </div>
        
        </div>
        

        <div class="question" id="q2-4">
            <div class="question-header">
                <span class="question-number">10.</span>
                
            </div>
            <div class="question-text">
                <div class="text-line">Write a program to implement merge sort algorithm for sorting a list of integers in ascending order.</div>
            </div>
            
        <div class="answer">
            <div class="answer-label">Ans:</div>
            <div class="answer-text">
                <div class="text-line">def merge_sort(arr):</div>
<div class="text-line indent-1">	    if len(arr) > 1:</div>
<div class="text-line indent-2">	        mid = len(arr) // 2</div>
<div class="text-line indent-2">	        left = arr[:mid]</div>
<div class="text-line indent-2">	        right = arr[mid:]</div>
<div class="text-line indent-2">	        merge_sort(left)</div>
<div class="text-line indent-2">	        merge_sort(right)</div>
<div class="text-line indent-2">	        i = j = k = 0</div>
<div class="text-line indent-2">	        # Merge the two halves</div>
<div class="text-line indent-2">	        while i < len(left) and j < len(right):</div>
<div class="text-line indent-3">	            if left[i] <= right[j]:</div>
<div class="text-line indent-4">	                arr[k] = left[i]</div>
<div class="text-line indent-4">	                i += 1</div>
<div class="text-line indent-3">	            else:</div>
<div class="text-line indent-4">	                arr[k] = right[j]</div>
<div class="text-line indent-4">	                j += 1</div>
<div class="text-line indent-3">	            k += 1</div>
<div class="text-line indent-2">	        # Copy remaining elements of left[]</div>
<div class="text-line indent-2">	        while i < len(left):</div>
<div class="text-line indent-3">	            arr[k] = left[i]</div>
<div class="text-line indent-3">	            i += 1</div>
<div class="text-line indent-3">	            k += 1</div>
<div class="text-line indent-2">	        # Copy remaining elements of right[]</div>
<div class="text-line indent-2">	        while j < len(right):</div>
<div class="text-line indent-3">	            arr[k] = right[j]</div>
<div class="text-line indent-3">	            j += 1</div>
<div class="text-line indent-3">	            k += 1</div>
<div class="text-line">	# Driver code</div>
<div class="text-line">	n = int(input("Enter number of elements: "))</div>
<div class="text-line">	arr = []</div>
<div class="text-line">	print("Enter the elements:")</div>
<div class="text-line">	for _ in range(n):</div>
<div class="text-line indent-1">	    arr.append(int(input()))</div>
<div class="text-line">	merge_sort(arr)</div>
<div class="text-line">	print("Sorted list in ascending order:")</div>
<div class="text-line">	print(arr)</div>
            </div>
        </div>
        
        </div>
        

        <div class="question" id="q2-5">
            <div class="question-header">
                <span class="question-number">11.</span>
                
            </div>
            <div class="question-text">
                <div class="text-line">Explain Dijkstra's algorithm with an example.</div>
            </div>
            
        <div class="answer">
            <div class="answer-label">Ans:</div>
            <div class="answer-text">
                <div class="text-line">Dijkstra’s Algorithm is a greedy method used to find the shortest path from a single source vertex to all other vertices in a weighted, connected graph with non-negative edge weights.</div>
<div class="text-line">	The algorithm maintains a set of vertices whose shortest distance from the source is already known, and repeatedly selects the vertex with the minimum temporary distance.</div>
<div class="text-line">	Basic Idea</div>
<div class="text-line">	Assign a distance value to every vertex:</div>
<div class="text-line">	• 0 for the source vertex</div>
<div class="text-line">	• ∞ (infinity) for all others</div>
<div class="text-line">	Mark all vertices as unvisited.</div>
<div class="text-line">	Select the unvisited vertex with the smallest distance value.</div>
<div class="text-line">	Update the distance of its neighbouring vertices.</div>
<div class="text-line">	Mark the selected vertex as visited.</div>
<div class="text-line">	Repeat steps 3–5 until all vertices are visited.</div>
<div class="text-line">	Notation</div>
<div class="text-line">	dist[v] = shortest known distance from source to vertex v</div>
<div class="text-line">	Example</div>
<div class="text-line">	Consider the following weighted graph:</div>
<div class="text-line">	A–B = 4</div>
<div class="text-line">	A–C = 2</div>
<div class="text-line">	B–C = 5</div>
<div class="text-line">	B–D = 10</div>
<div class="text-line">	C–E = 3</div>
<div class="text-line">	E–D = 4</div>
<div class="text-line">	D–F = 11</div>
<div class="text-line">	Source vertex = A</div>
<div class="text-line">	Step-by-Step Execution</div>
<div class="text-line">	Initial distances:</div>
<div class="text-line">	Vertex Distance from A</div>
<div class="text-line">	A 0</div>
<div class="text-line">	B ∞</div>
<div class="text-line">	C ∞</div>
<div class="text-line">	D ∞</div>
<div class="text-line">	E ∞</div>
<div class="text-line">	F ∞</div>
<div class="text-line">	Visited set = { }</div>
<div class="text-line">	Step 1: Select A (smallest distance = 0)</div>
<div class="text-line">	Update neighbours:</div>
<div class="text-line">	B = min(∞ , 0 + 4) = 4</div>
<div class="text-line">	C = min(∞ , 0 + 2) = 2</div>
<div class="text-line">	Visited = {A}</div>
<div class="text-line">	Step 2: Select C (distance = 2)</div>
<div class="text-line">	Update neighbours:</div>
<div class="text-line">	E = min(∞ , 2 + 3) = 5</div>
<div class="text-line">	B = min(4 , 2 + 5) = 4 (unchanged)</div>
<div class="text-line">	Visited = {A, C}</div>
<div class="text-line">	Step 3: Select B (distance = 4)</div>
<div class="text-line">	Update neighbours:</div>
<div class="text-line">	D = min(∞ , 4 + 10) = 14</div>
<div class="text-line">	Visited = {A, C, B}</div>
<div class="text-line">	Step 4: Select E (distance = 5)</div>
<div class="text-line">	Update neighbours:</div>
<div class="text-line">	D = min(14 , 5 + 4) = 9 ← updated</div>
<div class="text-line">	Visited = {A, C, B, E}</div>
<div class="text-line">	Step 5: Select D (distance = 9)</div>
<div class="text-line">	Update neighbours:</div>
<div class="text-line">	F = min(∞ , 9 + 11) = 20</div>
<div class="text-line">	Visited = {A, C, B, E, D}</div>
<div class="text-line">	Step 6: Select F (distance = 20)</div>
<div class="text-line">	Visited = {A, C, B, E, D, F}</div>
<div class="text-line">	All vertices are processed.</div>
<div class="text-line">	Final Shortest Distances from A</div>
<div class="text-line">	A → A = 0</div>
<div class="text-line">	A → C = 2</div>
<div class="text-line">	A → B = 4</div>
<div class="text-line">	A → E = 5</div>
<div class="text-line">	A → D = 9</div>
<div class="text-line">	A → F = 20</div>
<div class="text-line"><strong>	Key Points</strong></div>
<div class="text-line">	• Works only for non-negative edge weights</div>
<div class="text-line">	• Based on greedy strategy</div>
<div class="text-line">	• Time complexity:</div>
<div class="text-line">	– O(V²) using matrix</div>
<div class="text-line">	– O((V + E) log V) using priority queue</div>
<div class="text-line"><strong>	Conclusion</strong></div>
<div class="text-line">	Dijkstra’s Algorithm efficiently finds the shortest path from a single source to all other vertices in a weighted graph with non negative edges by repeatedly selecting the vertex with the minimum tentative distance and updating its neighbours.</div>
            </div>
        </div>
        
        </div>
        
</div>
</div>

            <div class="part" id="part-3">
                <h2 class="part-title">PART - C</h2>
            

                <div class="part-description">
                    Answer any three questions. Each question caries 10 marks : (3 x 10 = 30)
                </div>
                
<div class="questions">

        <div class="question" id="q3-1">
            <div class="question-header">
                <span class="question-number">12.</span>
                
            </div>
            <div class="question-text">
                <div class="text-line">Explain asymptotic notations.</div>
            </div>
            
        <div class="answer">
            <div class="answer-label">Ans:</div>
            <div class="answer-text">
                <div class="text-line">Asymptotic notations are mathematical tools used to describe the growth rate of the running time or space requirement of an algorithm as the input size n becomes very	 large. They help us compare the efficiency of algorithms independent of machine and implementation details.</div>
<div class="text-line">	The three main asymptotic notations are:</div>
<div class="text-line">	Big–Oh Notation — O(f(n))</div>
<div class="text-line">	Big-Oh gives an asymptotic upper bound on the running time of an algorithm.</div>
<div class="text-line">	It represents the worst-case growth rate.</div>
<div class="text-line">	Formally,</div>
<div class="text-line">	T(n) = O(f(n))</div>
<div class="text-line">	if there exist constants c > 0 and n₀ such that</div>
<div class="text-line">	T(n) ≤ c · f(n) for all n ≥ n₀.</div>
<div class="text-line"><strong>	Example:</strong></div>
<div class="text-line">	If T(n) = 3n² + 5n + 2, then</div>
<div class="text-line">	T(n) = O(n²)</div>
<div class="text-line">	Big–Omega Notation — Ω(f(n))</div>
<div class="text-line">	Big-Omega gives an asymptotic lower bound on the running time.</div>
<div class="text-line">	It represents the best-case growth rate.</div>
<div class="text-line">	Formally,</div>
<div class="text-line">	T(n) = Ω(f(n))</div>
<div class="text-line">	if there exist constants c > 0 and n₀ such that</div>
<div class="text-line">	T(n) ≥ c · f(n) for all n ≥ n₀.</div>
<div class="text-line"><strong>	Example:</strong></div>
<div class="text-line">	T(n) = 3n² + 5n + 2</div>
<div class="text-line">	⇒ T(n) = Ω(n²)</div>
<div class="text-line">	Big–Theta Notation — Θ(f(n))</div>
<div class="text-line">	Big-Theta provides a tight bound.</div>
<div class="text-line">	It represents the exact asymptotic growth rate.</div>
<div class="text-line">	Formally,</div>
<div class="text-line">	T(n) = Θ(f(n))</div>
<div class="text-line">	if it is both O(f(n)) and Ω(f(n)).</div>
<div class="text-line"><strong>	Example:</strong></div>
<div class="text-line">	T(n) = 3n² + 5n + 2</div>
<div class="text-line">	⇒ T(n) = Θ(n²)</div>
<div class="text-line">	Why Asymptotic Notations are Used</div>
<div class="text-line">	• To analyze algorithm performance for large input sizes</div>
<div class="text-line">	• To ignore machine-dependent constants</div>
<div class="text-line">	• To compare algorithms mathematically</div>
<div class="text-line">	Common Growth Orders (fastest to slowest)</div>
<div class="text-line">	O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(2ⁿ) < O(n!)</div>
<div class="text-line"><strong>	Conclusion</strong></div>
<div class="text-line">	Asymptotic notations describe the running time of algorithms in terms of input size n and help evaluate efficiency.Big-Oh gives the upper bound, Big-Omega gives the lower bound, and Big-Theta gives the tight bound.</div>
<div class="text-line">13.Explain lower bound arguments.List and explain methods to obtain .</div>
<div class="text-line"> Ans: A lower bound of a problem is the best possible (minimum) running time that any algorithm can ever achieve for solving that problem in the worst case.</div>
<div class="text-line">	It is a theoretical limit on performance — no algorithm can do better than this bound.</div>
<div class="text-line">	If the lower bound of a problem is f(n), then every algorithm that solves this problem must take at least f(n) time in the worst case.</div>
<div class="text-line">	Examples</div>
<div class="text-line">	• Comparison-based sorting has a lower bound of Ω(n log n)</div>
<div class="text-line">	• Searching in an unsorted array has a lower bound of Ω(n)</div>
<div class="text-line">	So, lower bound arguments help us decide whether an algorithm is optimal.</div>
<div class="text-line">	If an algorithm matches the lower bound, it is called asymptotically optimal.</div>
<div class="text-line">	Methods to Obtain Lower Bounds</div>
<div class="text-line">	There are mainly three commonly used methods:</div>
<div class="text-line">	Direct Counting Argument</div>
<div class="text-line">	In this method, we directly count the minimum number of operations required to solve a problem.</div>
<div class="text-line"><strong>	Example:</strong></div>
<div class="text-line">	To search in an unsorted list of n elements, at least n comparisons may be required in the worst case.</div>
<div class="text-line">	Therefore, the lower bound is:</div>
<div class="text-line">	Ω(n)</div>
<div class="text-line">	This method is simple and usually applies to straightforward problems.</div>
<div class="text-line">	Decision Tree Method</div>
<div class="text-line">	This method is used mainly for comparison-based algorithms such as sorting and searching.</div>
<div class="text-line"><strong>	Idea:</strong></div>
<div class="text-line">	Every comparison made by the algorithm is represented as a decision (yes/no) node in a binary tree.</div>
<div class="text-line">	The height of the tree represents the minimum number of comparisons in the worst case.</div>
<div class="text-line">	For comparison-based sorting of n elements:</div>
<div class="text-line">	• Total possible permutations = n!</div>
<div class="text-line">	• A binary decision tree with height h can distinguish at most 2^h outcomes</div>
<div class="text-line">	So,</div>
<div class="text-line">	2^h ≥ n!</div>
<div class="text-line">	Taking log,</div>
<div class="text-line">	h ≥ log₂(n!)</div>
<div class="text-line">	Using Stirling’s approximation:</div>
<div class="text-line">	log₂(n!) = Ω(n log n)</div>
<div class="text-line">	So the lower bound of comparison-based sorting is:</div>
<div class="text-line">	Ω(n log n)</div>
<div class="text-line">	Adversary (or Game-Theoretic) Method</div>
<div class="text-line">	In this method, we assume an adversary (opponent) who answers the algorithm’s questions in such a way that the algorithm is forced to do the maximum possible work.</div>
<div class="text-line">	The adversary guarantees that no algorithm can solve the problem faster than a certain limit.</div>
<div class="text-line">	This helps derive tight worst-case lower bounds.</div>
<div class="text-line"><strong>	Example:</strong></div>
<div class="text-line">	In searching, the adversary can always pretend the key is not found until the last element is checked, forcing Ω(n) comparisons.</div>
<div class="text-line"><strong>	Conclusion</strong></div>
<div class="text-line">	Lower bound arguments help determine the minimum possible time complexity of a problem irrespective of the algorithm used.</div>
<div class="text-line">	The main methods to obtain lower bounds are:</div>
<div class="text-line">	• Direct Counting</div>
<div class="text-line">	• Decision Tree Method</div>
<div class="text-line">	• Adversary Method</div>
<div class="text-line">	They are fundamental in theoretical computer science for proving whether an algorithm is optimal.</div>
            </div>
        </div>
        
        </div>
        

        <div class="question" id="q3-2">
            <div class="question-header">
                <span class="question-number">14.</span>
                
            </div>
            <div class="question-text">
                <div class="text-line">Define tree. explain binary tree traversals.</div>
            </div>
            
        <div class="answer">
            <div class="answer-label">Ans:</div>
            <div class="answer-text">
                <div class="text-line">A tree is a non-linear hierarchical data structure consisting of a set of nodes connected by edges.</div>
<div class="text-line">	It has the following properties:</div>
<div class="text-line">	• There is one special node called the root</div>
<div class="text-line">	• Every node (except root) has exactly one parent</div>
<div class="text-line">	• Nodes having no children are called leaf nodes</div>
<div class="text-line">	• There are no cycles in a tree</div>
<div class="text-line">	A tree is widely used to represent hierarchical structures such as file systems, organization charts, etc.</div>
<div class="text-line">	Binary Tree</div>
<div class="text-line">	A binary tree is a tree in which each node has at most two children, usually referred to as:</div>
<div class="text-line">	• Left child</div>
<div class="text-line">	• Right child</div>
<div class="text-line">	Binary Tree Traversals</div>
<div class="text-line">	Traversal means visiting all the nodes of a binary tree in a specific order.</div>
<div class="text-line">	The main traversal methods are:</div>
<div class="text-line">	Inorder Traversal (Left – Root – Right)</div>
<div class="text-line"><strong>	Steps:</strong></div>
<div class="text-line">	Traverse the left subtree</div>
<div class="text-line">	Visit the root node</div>
<div class="text-line">	Traverse the right subtree</div>
<div class="text-line">	For a Binary Search Tree, inorder traversal gives sorted order of elements.</div>
<div class="text-line">	Example order:</div>
<div class="text-line">	Left → Root → Right</div>
<div class="text-line">	Preorder Traversal (Root – Left – Right)</div>
<div class="text-line"><strong>	Steps:</strong></div>
<div class="text-line">	Visit the root node</div>
<div class="text-line">	Traverse the left subtree</div>
<div class="text-line">	Traverse the right subtree</div>
<div class="text-line">	Used for:</div>
<div class="text-line">	• Creating copy of tree</div>
<div class="text-line">	• Prefix notation of expressions</div>
<div class="text-line">	Example order:</div>
<div class="text-line">	Root → Left → Right</div>
<div class="text-line">	Postorder Traversal (Left – Right – Root)</div>
<div class="text-line"><strong>	Steps:</strong></div>
<div class="text-line">	Traverse the left subtree</div>
<div class="text-line">	Traverse the right subtree</div>
<div class="text-line">	Visit the root node</div>
<div class="text-line">	Used for:</div>
<div class="text-line">	• Deleting/freeing tree nodes</div>
<div class="text-line">	• Postfix expression evaluation</div>
<div class="text-line">	Example order:</div>
<div class="text-line">	Left → Right → Root</div>
<div class="text-line"><strong>	Conclusion</strong></div>
<div class="text-line">	A tree is a hierarchical structure with nodes connected without cycles.</div>
<div class="text-line">	Binary tree traversal methods (Inorder, Preorder, Postorder) provide systematic ways to visit every node in a binary tree.</div>
            </div>
        </div>
        
        </div>
        

        <div class="question" id="q3-3">
            <div class="question-header">
                <span class="question-number">15.</span>
                
            </div>
            <div class="question-text">
                <div class="text-line">Write short note on :     a) Depth first search.</div>
            </div>
            
        <div class="answer">
            <div class="answer-label">Ans:</div>
            <div class="answer-text">
                <div class="text-line">Depth First Search (DFS) is a graph traversal technique used to visit all the vertices of a graph.</div>
<div class="text-line">	It starts from a selected source vertex and explores as far as possible along each branch before backtracking.</div>
<div class="text-line">	DFS uses a stack data structure, either explicitly or through recursion.</div>
<div class="text-line">	Working Principle</div>
<div class="text-line">	Visit the starting vertex and mark it as visited.</div>
<div class="text-line">	Move to any unvisited adjacent vertex and repeat the process.</div>
<div class="text-line">	If no adjacent unvisited vertex exists, backtrack to the previous vertex.</div>
<div class="text-line">	Continue until all vertices reachable from the source are visited.</div>
<div class="text-line">	Implementation</div>
<div class="text-line">	• Recursive method → uses system call stack</div>
<div class="text-line">	• Iterative method → uses an explicit stack</div>
<div class="text-line">	Applications of DFS</div>
<div class="text-line">	• Detecting cycles in graphs</div>
<div class="text-line">	• Topological sorting</div>
<div class="text-line">	• Finding connected components</div>
<div class="text-line">	• Solving puzzles like mazes</div>
<div class="text-line">	• Path finding</div>
<div class="text-line">	• Tree traversals (Preorder/Postorder)</div>
<div class="text-line">	Time Complexity</div>
<div class="text-line">	O(V + E),</div>
<div class="text-line">	where V = number of vertices and E = number of edges.</div>
<div class="text-line">	Key Features</div>
<div class="text-line">	• Goes deep before exploring siblings</div>
<div class="text-line">	• Uses stack / recursion</div>
<div class="text-line">	• Suitable for problems involving backtracking</div>
            </div>
        </div>
        
        </div>
        

        <div class="question" id="q3-4">
            <div class="question-header">
                <span class="question-number">15.</span>
                
            </div>
            <div class="question-text">
                <div class="text-line">Write short note on :     b)Decision trees.</div>
            </div>
            
        <div class="answer">
            <div class="answer-label">Ans:</div>
            <div class="answer-text">
                <div class="text-line">A Decision Tree is a tree-shaped model used to represent a sequence of decisions or comparisons for solving a problem. Each internal  node represents a decision or test condition, each edge represents the outcome of the test, and each leaf node represents a final result or solution.</div>
<div class="text-line">	In algorithm analysis, decision trees are mainly used to obtain lower bounds for comparison-based algorithms such as sorting and searching.</div>
<div class="text-line">	Decision Tree for Algorithms</div>
<div class="text-line">	• Each comparison made by the algorithm is modeled as a binary decision node (Yes/No).</div>
<div class="text-line">	• Each input leads to a path from the root to a leaf.</div>
<div class="text-line">	• The height of the tree represents the minimum number of comparisons in the worst case.</div>
<div class="text-line">	For comparison-based sorting of n elements:</div>
<div class="text-line">	Number of possible permutations = n!</div>
<div class="text-line">	A binary tree of height h can distinguish at most 2^h outcomes</div>
<div class="text-line">	Therefore,</div>
<div class="text-line">	2^h ≥ n!</div>
<div class="text-line">	⇒ h ≥ log₂(n!)</div>
<div class="text-line">	⇒ Worst-case lower bound = Ω(n log n)</div>
<div class="text-line">	So, no comparison-based sorting algorithm can perform better than n log n in the worst case.</div>
<div class="text-line">	Applications</div>
<div class="text-line">	• Proving lower bounds of algorithms</div>
<div class="text-line">	• Designing optimal decision processes</div>
<div class="text-line">	• Machine learning classification models</div>
<div class="text-line">	• Game trees and strategy analysis</div>
<div class="text-line"><strong>	Conclusion</strong></div>
<div class="text-line">	Decision Trees provide a theoretical framework to analyze and prove limits on algorithm performance, especially for comparison-based problems. They show the minimum number of decisions required to distinguish between all possible inputs.</div>
<div class="text-line">--------------------------------------------------</div>
            </div>
        </div>
        
        </div>
        
</div>
</div>
        </main>
        
        <footer class="footer">
            <div class="footer-content">
                <p>Generated on January 01, 2026 • 3 parts • 15 questions</p>
            </div>
        </footer>
        
    </div>
</body>
</html>